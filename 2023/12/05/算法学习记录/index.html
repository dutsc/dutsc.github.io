

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon-32x32.png">
  <link rel="icon" href="/img/favicon-32x32.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="dutsc">
  <meta name="keywords" content="">
  
    <meta name="description" content="算法学习记录 本文档按照时间 记录了笔者写算法题的随笔 更多题解分享与思路交流可移步笔者leetcode主页：https:&#x2F;&#x2F;leetcode.cn&#x2F;u&#x2F;dutsc&#x2F;  十一假期子序列，子串类型的动态规划 滑动窗口 HashSet 优先队列（堆，可传比较器） 单调队列（滑动窗口的最大值）（用双端队列实现Deuqe） 用map统计元素出现的频率 map.put(num,map.getOrDefaul">
<meta property="og:type" content="article">
<meta property="og:title" content="算法学习记录">
<meta property="og:url" content="http://example.com/2023/12/05/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/index.html">
<meta property="og:site_name" content="dutsc的个人博客">
<meta property="og:description" content="算法学习记录 本文档按照时间 记录了笔者写算法题的随笔 更多题解分享与思路交流可移步笔者leetcode主页：https:&#x2F;&#x2F;leetcode.cn&#x2F;u&#x2F;dutsc&#x2F;  十一假期子序列，子串类型的动态规划 滑动窗口 HashSet 优先队列（堆，可传比较器） 单调队列（滑动窗口的最大值）（用双端队列实现Deuqe） 用map统计元素出现的频率 map.put(num,map.getOrDefaul">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/dutsc/cloud-image/blog-img/202312052038181.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/dutsc/cloud-image/blog-img/202312052038387.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/dutsc/cloud-image/blog-img/202312052038506.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/dutsc/cloud-image/blog-img/202312052038606.png">
<meta property="og:image" content="c:/Users/s%27c/AppData/Roaming/Typora/typora-user-images/image-20220124140113642.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/dutsc/cloud-image/blog-img/202312052038164.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/dutsc/cloud-image/blog-img/202312052038491.png">
<meta property="og:image" content="e:/Download/qq/mpFile/1020018707/Image/Group2/@2/KR/@2KRSGV6HC2%5BZ61RPPI5%7DY5.png">
<meta property="og:image" content="e:/Download/qq/mpFile/1020018707/Image/Group2/KK/7J/KK7J737S%5DT%7D7_XFOJSBOS3I.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/dutsc/cloud-image/blog-img/202312052037784.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/dutsc/cloud-image/blog-img/202312052038427.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/dutsc/cloud-image/blog-img/202312052038456.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/dutsc/cloud-image/blog-img/202312052038901.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/dutsc/cloud-image/blog-img/202312052038019.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/dutsc/cloud-image/blog-img/202312052038868.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/dutsc/cloud-image/blog-img/202312052039704.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/dutsc/cloud-image/blog-img/202312052037678.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/dutsc/cloud-image/blog-img/202312052034202.png">
<meta property="og:image" content="c:/Users/s%27c/AppData/Roaming/Typora/typora-user-images/image-20220503100257497.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/dutsc/cloud-image/blog-img/202312052037913.png">
<meta property="article:published_time" content="2023-12-05T12:36:38.000Z">
<meta property="article:modified_time" content="2023-12-05T12:49:07.067Z">
<meta property="article:author" content="dutsc">
<meta property="article:tag" content="学习记录">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/dutsc/cloud-image/blog-img/202312052038181.png">
  
  
  
  <title>算法学习记录 - dutsc的个人博客</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.9.5","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":true,"follow_dnt":false,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":"znnF2Oz54UgHanY4ku1ECw1d-gzGzoHsz","app_key":"OusddZKdtXbjLqzj71mD9UUu","server_url":"https://znnf2oz5.lc-cn-n1-shared.com","path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  

  

  
    <!-- Google tag (gtag.js) -->
    <script async>
      if (!Fluid.ctx.dnt) {
        Fluid.utils.createScript("https://www.googletagmanager.com/gtag/js?id=", function() {
          window.dataLayer = window.dataLayer || [];
          function gtag() {
            dataLayer.push(arguments);
          }
          gtag('js', new Date());
          gtag('config', '');
        });
      }
    </script>
  

  

  

  

  
    
  



  
<meta name="generator" content="Hexo 7.0.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>dutsc</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/links/">
                <i class="iconfont icon-link-fill"></i>
                <span>友链</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="算法学习记录"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2023-12-05 20:36" pubdate>
          2023年12月5日 晚上
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          86k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          <!-- compatible with older versions-->
          428 分钟
        
      </span>
    

    
    
      
        <span id="leancloud-page-views-container" class="post-meta" style="display: none">
          <i class="iconfont icon-eye" aria-hidden="true"></i>
          <span id="leancloud-page-views"></span> 次
        </span>
        
      
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">算法学习记录</h1>
            
              <p class="note note-info">
                
                  
                    本文最后更新于：1 个月前
                  
                
              </p>
            
            
              <div class="markdown-body">
                
                <h1 id="算法学习记录"><a href="#算法学习记录" class="headerlink" title="算法学习记录"></a>算法学习记录</h1><blockquote>
<p>本文档按照时间 记录了笔者写算法题的随笔</p>
<p>更多题解分享与思路交流可移步笔者leetcode主页：<a target="_blank" rel="noopener" href="https://leetcode.cn/u/dutsc/">https://leetcode.cn/u/dutsc/</a></p>
</blockquote>
<h2 id="十一假期"><a href="#十一假期" class="headerlink" title="十一假期"></a>十一假期</h2><p>子序列，子串类型的动态规划</p>
<p>滑动窗口</p>
<p>HashSet</p>
<p>优先队列（堆，可传比较器）</p>
<p>单调队列（滑动窗口的最大值）（用双端队列实现Deuqe）</p>
<p>用map统计元素出现的频率 <code>map.put(num,map.getOrDefault(num,0)+1);</code></p>
<p>往优先队列中传入比较器，注意比较器也要有泛型(使用匿名内部类)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java">Queue&lt;Map.Entry&lt;Integer,Integer&gt;&gt; pq = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;&gt;(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Comparator</span>&lt;Map.Entry&lt;Integer,Integer&gt;&gt;()&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(Map.Entry&lt;Integer,Integer&gt; e1,Map.Entry&lt;Integer,Integer&gt; e2)</span>&#123;<br>        <span class="hljs-keyword">return</span> e1.getValue() - e2.getValue();<br>    &#125;<br>&#125;);<br><span class="hljs-comment">//Map.Entry中第一个存放num数值，第二个存放num出现的频率。</span><br><span class="hljs-comment">//优先队列实现一个小顶堆，按照出现的频率排序</span><br><span class="hljs-comment">// 完全可以使用数组int[]代替</span><br><br><span class="hljs-comment">//若存入优先队列的值是Double类型，需要使用内置的Double.compare()方法来作为compare的返回值</span><br></code></pre></td></tr></table></figure>

<p>编辑距离  dp</p>
<h2 id="10-8"><a href="#10-8" class="headerlink" title="10&#x2F;8"></a>10&#x2F;8</h2><p>优先队列题目优化，改用大顶堆，找到出现频率前k高的元素然后再poll</p>
<p>lambda表达式的写法，比比较器方便</p>
<p>深度优先搜索 dfs   ‘X’ ‘O’变化   <strong>标记法</strong></p>
<h3 id="集合的时间复杂度"><a href="#集合的时间复杂度" class="headerlink" title="集合的时间复杂度"></a>集合的时间复杂度</h3><ul>
<li><p>ArrayList     查 O（1） 增  末尾0（1）中间0（n）    删0（n）</p>
</li>
<li><p>LinkedList    查 O（n） 增 末尾0（1）中间0（n） 删0（1）<br>因为增加到中间，要先查询到增加的位置，故增加到中间时间复杂度为O(n)</p>
</li>
<li><p>Set集合有三个常见的实现类：HashSet，TreeSet，LinkedHashSet。<br>简单的说，如果你关注性能，应该使用HashSet；<br>如果你需要一个有序的Set集合，应该使用TreeSet；<br>如果你需要一个Set集合保存了原始的元素插入顺序，应该使用LinkedHashSet。</p>
<ul>
<li><p>HashSet 是基于散列表实现的，元素没有顺序；add、remove、contains方法的时间复杂度为O(1)。(contains为false时，就直接往集合里存)<br>总结：查 0（1） 增 0（1） 删0（1）</p>
</li>
<li><p>TreeSet是基于树实现的（红黑树），元素是有序的；add、remove、contains方法的时间复杂度为O(log (n))(contains为false时，插入前需要重新排序)。</p>
<p>总结：查 0（log n） 增 0（log n） 删0（log n）</p>
</li>
<li><p>LinkedHashSet介于HashSet和TreeSet之间，是基于哈希表和链表实现的，支持元素的插入顺序；基本方法的时间复杂度为O(1)；</p>
<p>待定<br>总结：查 0（1） 增 0（1） 删0（1）</p>
</li>
</ul>
</li>
<li><p>map集合有三个常见的实现类：HashMap，TreeMap，LinkedHashMap。	</p>
<ul>
<li>TreeMap基于红黑树（一种自平衡二叉查找树）实现的，时间复杂度平均能达到O(log n)。</li>
<li>HashMap是基于散列表实现的，时间复杂度平均能达到O(1)。正常是0(1)到0（n） jdk1.8添加了 红黑树 是 0（log n）</li>
<li>TreeMap的get操作的时间复杂度是O(log(n))的，相比于HashMap的O(1)还是差不少的。</li>
<li>LinkedHashMap的出现就是为了平衡这些因素，能以O(1)时间复杂度查找元素，又能够保证key的有序性</li>
</ul>
</li>
</ul>
<h2 id="10-9"><a href="#10-9" class="headerlink" title="10&#x2F;9"></a>10&#x2F;9</h2><p>并查集基础题</p>
<p>并查集困难题，应用没做出来？？</p>
<p>每日一题，不会做</p>
<h2 id="10-13"><a href="#10-13" class="headerlink" title="10&#x2F;13"></a>10&#x2F;13</h2><p>做了一些基础的模拟题，贪心题</p>
<p>String的valueOf方法   将基本数据类型转换成字符串型的方法</p>
<p>String 类别中已经提供了将基本数据型态转换成 String 的 static 方法 ，也就是 String.valueOf() 这个参数多载的方法 </p>
<h4 id="拓展：将String转为基本数据类型"><a href="#拓展：将String转为基本数据类型" class="headerlink" title="拓展：将String转为基本数据类型"></a>拓展：将String转为基本数据类型</h4><p>要将 String 转换成基本数据型态转 ，大多需要使用基本数据型态的包装类别 </p>
<p>　　比如说 String 转换成 byte ，可以使用 Byte.parseByte(String s) ，这一类的方法如果无法将 s 分析 则会丢出 NumberFormatException </p>
<p>（1）byte : Byte.parseByte(String s) : 将 s 转换成 byte </p>
<p>（2）Byte.parseByte(String s, int radix) : 以 radix 为基底 将 s 转换为 byte ，比如说 Byte.parseByte(“11”, 16) 会得到 17 </p>
<p>（3）double : Double.parseDouble(String s) : 将 s 转换成 double </p>
<p>（4）float : Double.parseFloat(String s) : 将 s 转换成 float </p>
<p>（5）int : Integer.parseInt(String s) : 将 s 转换成 int </p>
<p>（6）long : Long.parseLong(String s)</p>
<p>上述方法都可以忽略字符串中的前导0，直接转化为去除前导零的数字</p>
<h4 id="putIfAbsent-k-v"><a href="#putIfAbsent-k-v" class="headerlink" title="putIfAbsent(k,v)"></a>putIfAbsent(k,v)</h4><p>如果key不为空，就不插入新值了</p>
<p>若key不为空，则返回旧的value；若key为空，则返回null（返回旧的value）</p>
<h4 id="computeIfAbsent"><a href="#computeIfAbsent" class="headerlink" title="computeIfAbsent"></a>computeIfAbsent</h4><blockquote>
<p>putIfAbsent()中没有计算方法，直接给出value，而computeIfAbsent()中可以有value的计算方法（函数），也可以使用lambda表达式</p>
</blockquote>
<p> java8之前。从map中根据key获取value操作可能会有下面的操作</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Object</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> map.get(<span class="hljs-string">&quot;key&quot;</span>);<br><span class="hljs-keyword">if</span> (key == <span class="hljs-literal">null</span>) &#123;<br>    key = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>    map.put(<span class="hljs-string">&quot;key&quot;</span>, key);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>java8之后。上面的操作可以简化为一行，若key对应的value为空，会将第二个参数的返回值存入并返回</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Object</span> <span class="hljs-variable">key2</span> <span class="hljs-operator">=</span> map.computeIfAbsent(<span class="hljs-string">&quot;key&quot;</span>, k -&gt; <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>());<br></code></pre></td></tr></table></figure>



<p>如果v已经计算好了，那么适合使用putIfAbsent(k, v)，如果v还未计算，同时计算需要一些耗时,那么建议使用computeIfAbsent，将获取v值的计算放到lambada表达式体内，这样只有再map不含有k对应值时才会进行获取v值的计算，可以优化性能</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MapInfo</span> &#123;<br> <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">computeIfAbsent</span><span class="hljs-params">()</span>&#123; <span class="hljs-comment">// jdk1.8新特性哦</span><br>        HashMap&lt;String&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&amp;lt;&gt;();<br>        map.put(<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;is map&quot;</span>);<br>        map.put(<span class="hljs-string">&quot;2&quot;</span>,<span class="hljs-string">&quot;contains a mapping&quot;</span>);<br>        map.put(<span class="hljs-string">&quot;3&quot;</span>,<span class="hljs-string">&quot;specified&quot;</span>);<br>        map.put(<span class="hljs-string">&quot;4&quot;</span>,<span class="hljs-string">&quot;inappropriate&quot;</span>);<br>        map.computeIfAbsent(<span class="hljs-string">&quot;5&quot;</span>, MapInfo::apply);<br>        System.out.println(map.get(<span class="hljs-string">&quot;5&quot;</span>));<br>    &#125;<br> <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title function_">apply</span><span class="hljs-params">(String v)</span> &#123;<br>        <span class="hljs-type">return</span> <span class="hljs-variable">v</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;is 5&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h2 id="10-16"><a href="#10-16" class="headerlink" title="10&#x2F;16"></a>10&#x2F;16</h2><p>720.词典中最长的单词</p>
<p>注意：</p>
<ol>
<li>注意返回值为String，返回null是不对的，若为null应该返回””</li>
<li>只找最大或最小的值，考虑优先队列存储，传入比较器</li>
</ol>
<h2 id="10-18"><a href="#10-18" class="headerlink" title="10&#x2F;18"></a>10&#x2F;18</h2><h3 id="移位运算符"><a href="#移位运算符" class="headerlink" title="移位运算符"></a>移位运算符</h3><p>根据这个规则，左移32位后，右边补上32个0值是不是就变成了十进制的0了？答案是NO，当int类型进行左移操作时，左移位数大于等于32位操作时，会先求余（%）后再进行左移操作。也就是说左移32位相当于不进行移位操作，左移40位相当于左移8位（40%32&#x3D;8）。当long类型进行左移操作时，long类型在二进制中的体现是64位的，因此求余操作的基数也变成了64，也就是说左移64位相当于没有移位，左移72位相当于左移8位（72%64&#x3D;8）<br>注意：其它几种整形byte，short移位前会先转换为int类型（32位）再进行移位</p>
<p>和左移一样，int类型移位大于等于32位时，long类型大于等于64位时，会先做求余处理再位移处理，byte，short移位前会先转换为int类型（32位）再进行移位。以上是正数的位移，我们再来看看负数的右移运算，</p>
<h3 id="无符号移位"><a href="#无符号移位" class="headerlink" title="无符号移位&gt;&gt;&gt;"></a>无符号移位&gt;&gt;&gt;</h3><p>无符号右移运算符&gt;&gt;&gt;和右移运算符&gt;&gt;是一样的，只不过右移时左边是补上符号位，而无符号右移运算符是补上0，也就是说，对于正数移位来说等同于：&gt;&gt;，负数通过此移位运算符能移位成正数。</p>
<p>在不大于自身数值类型最大位数的移位时，一个数左移n位，就是将这个数乘以2的n次幂；一个数右移n位，就是将这个数除2的n次幂，然后取整。<br>比如int32位的（64位也是同样方法）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">7</span> &gt;&gt; <span class="hljs-number">1</span>  = <span class="hljs-number">7</span>/<span class="hljs-number">2</span>  取整为<span class="hljs-number">3</span><br><span class="hljs-number">7</span> &lt;&lt; <span class="hljs-number">1</span>  = <span class="hljs-number">7</span>*<span class="hljs-number">2</span>  为<span class="hljs-number">14</span><br></code></pre></td></tr></table></figure>

<p>如果移动位数超过了32位怎么办？把移位数和32取余数得到的数字套用即可：</p>
<p>如 9 &gt;&gt; 67<br>1、先67对32取余，结果是3<br>2、然后9&#x2F;8 得到结果为1</p>
<h4 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h4><p>C艹里面1最大左移31位，变成最小负数，然后这个数不能再-1</p>
<h5 id="java"><a href="#java" class="headerlink" title="java"></a>java</h5><h2 id="10-20"><a href="#10-20" class="headerlink" title="10&#x2F;20"></a>10&#x2F;20</h2><h3 id="Tree的bfs与图的bfs的区别"><a href="#Tree的bfs与图的bfs的区别" class="headerlink" title="Tree的bfs与图的bfs的区别"></a>Tree的bfs与图的bfs的区别</h3><p>相信对于Tree的BFS大家都已经轻车熟路了：要把root节点先入队，然后再一层一层的无脑遍历就行了。</p>
<p>对于图的BFS也是一样滴～ 与Tree的BFS区别如下：<br>1、tree只有1个root，而图可以有多个源点，所以首先需要把多个源点都入队。<br>2、tree是有向的因此不需要标志是否访问过，而对于无向图来说，必须得标志是否访问过！<br>并且为了防止某个节点多次入队，需要在入队之前就将其设置成已访问！</p>
<p>图的bfs遍历时，需要创建一个used数组来标记某个节点是否已经入队。已经入队的节点标记为true，将某个节点入队之前先判断它是否已经被访问过，若没有被访问过再入队。</p>
<p>入队之前判断，这样可以保证一个节点不会重复入队。</p>
<h3 id="1162-地图分析"><a href="#1162-地图分析" class="headerlink" title="1162.地图分析"></a>1162.地图分析</h3><p>这是一道典型的BFS基础应用，为什么这么说呢？<br>因为我们只要先把所有的陆地都入队，然后从各个陆地同时开始一层一层的向海洋扩散，那么最后扩散到的海洋就是最远的海洋！<br>并且这个海洋肯定是被离他最近的陆地给扩散到的！</p>
<h3 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h3><p>课程表题目210 207   给出课程学习的拓扑排序，利用BFS</p>
<h3 id="c-map的性质"><a href="#c-map的性质" class="headerlink" title="c++map的性质"></a>c++map的性质</h3><p><img src="https://cdn.jsdelivr.net/gh/dutsc/cloud-image/blog-img/202312052038181.png" srcset="/img/loading.gif" lazyload alt="cpp中map的性质"></p>
<p>输出1 4 3 5</p>
<p>若key与之前的key相等，则不会替换之前的map</p>
<p>map可以通过m3[1]直接获取key为1的value值，并且通过++来使value+1</p>
<h2 id="10-26"><a href="#10-26" class="headerlink" title="10&#x2F;26"></a>10&#x2F;26</h2><p>拓扑排序+动态规划   类型的困难题  1857</p>
<p>快速获取数组中的最大值最小值的方法：</p>
<p>Java</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Arrays.stream(nums).max().getAsInt();<br></code></pre></td></tr></table></figure>

<p>C++</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">*<span class="hljs-built_in">max_element</span>(array,array+n);<br><span class="hljs-type">int</span> myMax = *<span class="hljs-built_in">min_element</span>(arr.<span class="hljs-built_in">begin</span>(),arr.<span class="hljs-built_in">end</span>());<span class="hljs-comment">//也可以</span><br></code></pre></td></tr></table></figure>



<h2 id="10-28"><a href="#10-28" class="headerlink" title="10&#x2F;28"></a>10&#x2F;28</h2><p>判断一个数是不是2的整数次幂</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">if</span>(!num&amp;(num<span class="hljs-number">-1</span>)) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br></code></pre></td></tr></table></figure>

<p>此操作，翻转了num最右边的1</p>
<p>c++将数字转化为字符串</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">to_string</span>();<br></code></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/dutsc/cloud-image/blog-img/202312052038387.png" srcset="/img/loading.gif" lazyload></p>
<p>将字符串转化为数字</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><br>atoi;<span class="hljs-comment">//string to int   可以直接忽略前导0  超过上下界输出上下界</span><br>atof;<span class="hljs-comment">//string to float</span><br></code></pre></td></tr></table></figure>



<h2 id="11-2"><a href="#11-2" class="headerlink" title="11&#x2F;2"></a>11&#x2F;2</h2><p>只知道当前节点，想要删除当前节点的方法：</p>
<p><strong>不可取的设计模式！</strong> 本质上来说，单链表节点无法做到在链表里删除自身</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//只适用于Java，因为Java有垃圾回收器GC</span><br><span class="hljs-keyword">if</span>(node.next!=<span class="hljs-literal">null</span>)&#123;<br>    node.val = node.next.val;<br>    node.next = node.next.next;<br>&#125;<br><span class="hljs-keyword">else</span>&#123;<br>    node = <span class="hljs-literal">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure>



<p>lambda表达式中的差值，若是long类型，则必须转换为 int类型，否则会报错。因为compare方法返回的是int类型，要想不强转，只能重写compare方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">long</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">long</span>[<span class="hljs-number">2</span>][n];<br>PriorityQueue&lt;<span class="hljs-type">long</span>[]&gt; minHeap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;&gt;((a,b)-&gt;a[<span class="hljs-number">1</span>]-b[<span class="hljs-number">1</span>]);<br></code></pre></td></tr></table></figure>



<h2 id="11-3"><a href="#11-3" class="headerlink" title="11&#x2F;3"></a>11&#x2F;3</h2><p>取出一个点，一次遍历它的上下左右的技巧：</p>
<p><img src="https://cdn.jsdelivr.net/gh/dutsc/cloud-image/blog-img/202312052038506.png" srcset="/img/loading.gif" lazyload alt="遍历一个矩阵中上下左右四个位置"></p>
<h2 id="11-11"><a href="#11-11" class="headerlink" title="11&#x2F;11"></a>11&#x2F;11</h2><h4 id="记忆化深度优先搜索："><a href="#记忆化深度优先搜索：" class="headerlink" title="记忆化深度优先搜索："></a>记忆化深度优先搜索：</h4><p>当发现DFS出现大量重复计算时，若是矩阵，则可以创建一个缓存矩阵，来存储其已经遍历到的结果，这样就可以不用每次DFS的时候都要重新遍历了。</p>
<p>省下used数组空间的小技巧：</p>
<p>329.矩阵中的最长递增路径   一题中，memo矩阵存储从该点开始DFS的最长路径，将其初始值置为0，这样在遍历过程中，若$memo[i][j]$是0，就可以认为该位置没有被遍历过，就要重新遍历；</p>
<p>若$memo[i][j]$ 不是0，则直接返回该点的值即可，不需要再重新遍历。</p>
<h2 id="11-16"><a href="#11-16" class="headerlink" title="11&#x2F;16"></a>11&#x2F;16</h2><p>判断连接成完美矩形的条件：</p>
<ul>
<li>左下，右上，右下，左上的点只出现一次，其他的点成对出现<br>于是这就有了思路：若某一节点不在哈希表中，则加入，若已经在哈希表中，则删除，最后判断哈希表中元素个数是否为4，而且是左下，右上，右下，左上四个节点</li>
<li>每个矩形面积的累加和，看是不是等于最大的右上值减去最小的左下值，相等则true，不相等则false</li>
</ul>
<p>这里有一个小技巧：判断矩形的某一个点是已经存在。</p>
<p>由于矩形的点是用一个二元组来表示的，常规想法不太好存储，有一个小妙招：Set中存储<string> ，将矩形每个点的坐标拼接起来，这个String就代表该点的坐标，只需要判断该String是否在哈希表中即可。</p>
<p><strong>非常巧妙的变二维为一维的思想！</strong></p>
<h2 id="11-17"><a href="#11-17" class="headerlink" title="11&#x2F;17"></a>11&#x2F;17</h2><p>c++中，size()  和 length() 返回值类型是无符号数unsigned，若需要转为int类型则需要调用强制类型转换函数</p>
<h2 id="11-22"><a href="#11-22" class="headerlink" title="11&#x2F;22"></a>11&#x2F;22</h2><p>java数组的clone方法</p>
<p>A.一维数组：深克隆（重新分配空间，并将元素复制过去）</p>
<p>对clone后的数组进行修改不会影响源数组。<br>B.二维数组：浅克隆（只传递引用）</p>
<p>对clone后的数组进行修改时，将对源数组也产生影响（因为复制的是引用，实际上指向的是同一个地址）</p>
<p>实现二维数组的深克隆</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span>[][] a=&#123;&#123;<span class="hljs-number">3</span>,<span class="hljs-number">1</span>,<span class="hljs-number">4</span>,<span class="hljs-number">2</span>,<span class="hljs-number">5</span>&#125;,&#123;<span class="hljs-number">4</span>,<span class="hljs-number">2</span>&#125;&#125;;<br><span class="hljs-type">int</span>[][] b=<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[a.length][];<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;a.length;i++)&#123;<br>        b[i]=a[i].clone();<br>&#125;<br></code></pre></td></tr></table></figure>



<h2 id="11-28"><a href="#11-28" class="headerlink" title="11&#x2F;28"></a>11&#x2F;28</h2><h3 id="筛法求素数"><a href="#筛法求素数" class="headerlink" title="筛法求素数"></a>筛法求素数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-type">int</span> n;<br><span class="hljs-type">Scanner</span> <span class="hljs-variable">sc</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>n = sc.nextInt();<br><span class="hljs-type">int</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>; i &lt; n; i++) &#123;<br>    arr[i] = i;<br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>; i &lt; n; i++) &#123;<br>    <span class="hljs-keyword">if</span> (arr[i] != <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-type">int</span> j, temp;<br>        temp = arr[i];<br>        <span class="hljs-keyword">for</span> (j = <span class="hljs-number">2</span> * temp; j &lt; n; j = j + temp) &#123; <span class="hljs-comment">//这一步可以直接从temp[i]*temp[i]开始进行查找，可以证明</span><br>            arr[j] = <span class="hljs-number">0</span>;<br>        &#125;<br>        System.out.print(arr[i] + <span class="hljs-string">&quot; &quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>下标就是其值</p>
<h2 id="11-29"><a href="#11-29" class="headerlink" title="11&#x2F;29"></a>11&#x2F;29</h2><p>c++优先队列自定义排序    </p>
<p>优先队列使用仿函数，仿函数后面不加()，sort中使用仿函数，必须要加()；sort使用普通函数，必须使用static的函数，</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(<span class="hljs-type">int</span> &amp;a,<span class="hljs-type">int</span> &amp;b)</span></span>&#123;<br>        <span class="hljs-keyword">return</span> a&gt;b;<br>    &#125;<br><br> <span class="hljs-built_in">sort</span>(candidates.<span class="hljs-built_in">begin</span>(),candidates.<span class="hljs-built_in">end</span>(),cmp);<br></code></pre></td></tr></table></figure>

<p>注意：</p>
<ol>
<li><p>若有两个数，使用pair比使用vector快得多</p>
</li>
<li><p>使用emplace比push快，push要加上{}，emplace不用，直接写两个数就可以</p>
</li>
<li><p>priority_queue的排序返回值类型是bool，不是int  注意！！而且，&gt;  前者&gt;后者是从小到大排序，&lt; 前者&lt;后者是从大到小排序  ，优先队列使用仿函数排序，不能加()；使用普通函数排序，必须是static，而且必须使用函数指针（*暂时还没有研究）</p>
</li>
<li><p>sort排序顺序与java中的相同，与priority_queue相反，&lt; 表示从小到大排序，&gt;表示从大到小排序。<strong>sort使用仿函数必须加()，sort使用普通函数不加()，但是普通函数必须是static的</strong></p>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">cmpo</span>&#123;<br>    <span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; &amp;x,pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; &amp;y)</span></span>&#123;<br>        <span class="hljs-keyword">return</span> x.first*y.second&gt;x.second*y.first;<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">// class cmpv&#123;</span><br><span class="hljs-comment">//     public:</span><br><span class="hljs-comment">//     bool operator()(vector&lt;int&gt; &amp;x,vector&lt;int&gt; &amp;y)&#123;</span><br><span class="hljs-comment">//         return x[0]*y[1]&gt;x[1]*y[0];</span><br><span class="hljs-comment">//     &#125;</span><br><span class="hljs-comment">// &#125;;</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// bool cmp(pair&lt;int,int&gt; x,pair&lt;int,int&gt; y)&#123;</span><br>    <span class="hljs-comment">//     return x.first*y.second-x.second*y.first;</span><br>    <span class="hljs-comment">// &#125;</span><br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">kthSmallestPrimeFraction</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; arr, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = arr.<span class="hljs-built_in">size</span>();<br>        priority_queue&lt;pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;,vector&lt;pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; &gt;,cmpo&gt; minHeap;<br>        <span class="hljs-comment">// priority_queue&lt;vector&lt;int&gt;,vector&lt;vector&lt;int&gt;&gt;,cmpv&gt; minHeap;</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = i+<span class="hljs-number">1</span>;j&lt;n;j++)&#123;<br>                <span class="hljs-comment">// minHeap.push(&#123;arr[i],arr[j]&#125;);</span><br>                minHeap.<span class="hljs-built_in">emplace</span>(arr[i],arr[j]);<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">int</span> len = minHeap.<span class="hljs-built_in">size</span>();<br>        pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; temp;<br>        <span class="hljs-comment">// vector&lt;int&gt; temp; </span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i&lt;len;++i)&#123;<br>            <span class="hljs-keyword">if</span>(i==k<span class="hljs-number">-1</span>)&#123;<br>                temp = minHeap.<span class="hljs-built_in">top</span>();<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-comment">// pair&lt;int,int&gt; t = minHeap.top();</span><br>            <span class="hljs-comment">// cout &lt;&lt; t.first &lt;&lt; &quot; &quot; &lt;&lt; t.second &lt;&lt; endl;</span><br>            minHeap.<span class="hljs-built_in">pop</span>();<br>        &#125;<br>        vector&lt;<span class="hljs-type">int</span>&gt; a;<br>        a.<span class="hljs-built_in">push_back</span>(temp.first);<br>        a.<span class="hljs-built_in">push_back</span>(temp.second);<br>        <span class="hljs-comment">// a.push_back(temp[0]);</span><br>        <span class="hljs-comment">// a.push_back(temp[1]);</span><br>        <span class="hljs-keyword">return</span> a;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>c++排序方法：</p>
<p><img src="https://cdn.jsdelivr.net/gh/dutsc/cloud-image/blog-img/202312052038606.png" srcset="/img/loading.gif" lazyload alt="cpp排序方法"></p>
<h2 id="2022-1-8"><a href="#2022-1-8" class="headerlink" title="2022 1&#x2F;8"></a>2022 1&#x2F;8</h2><p>java中可以使用path.split(“&#x2F;“)将字符串path使用&#x2F;进行分割，并返回一个字符串数组。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">String[] names = path.split(<span class="hljs-string">&quot;/&quot;</span>);<br></code></pre></td></tr></table></figure>

<p>中间有不定数量空格隔开的字符串，也能分割成字符串数组</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-type">BufferedReader</span> <span class="hljs-variable">br</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InputStreamReader</span>(System.in));<br>String[] tt = br.readLine().split(<span class="hljs-string">&quot; +&quot;</span>);<br></code></pre></td></tr></table></figure>



<h2 id="背包问题"><a href="#背包问题" class="headerlink" title="背包问题"></a>背包问题</h2><h2 id="01背包"><a href="#01背包" class="headerlink" title="01背包"></a>01背包</h2><p>若采用先遍历物品，再遍历背包容量的方式，背包容量要从大到小遍历</p>
<h2 id="完全背包"><a href="#完全背包" class="headerlink" title="完全背包"></a>完全背包</h2><p>遍历顺序与01背包不同，若采用先遍历物品，再遍历背包容量的方式，背包容量要从小到大遍历，这样每一个物品都可以无限次被拿取。</p>
<p>求一共有多少种零钱组合金额的题目，就是求有多少种物品放入背包的方式，递推公式一般为$dp[i] +&#x3D; dp[i-cost[i]]$ ，而且注意，$dp[0]$ 一定要初始化为1，否则后面都是0，没有意义。</p>
<p>&#x3D;&#x3D;for循环的遍历顺序与 是 组合还是排列  有关系！&#x3D;&#x3D;</p>
<ol>
<li>先遍历物品（钱币金额），再遍历背包容量（金钱总额），求的是组合数</li>
<li>先遍历背包容量（金钱总额），再遍历物品（钱币金额），求的是排列数。</li>
</ol>
<p>滚动数组中，倒序遍历是为了保证每个物品只被添加一次</p>
<h2 id="子序列问题"><a href="#子序列问题" class="headerlink" title="子序列问题"></a>子序列问题</h2><blockquote>
<p>子序列默认不连续，子数组默认连续</p>
</blockquote>
<h3 id="最长递增子序列（LIS）"><a href="#最长递增子序列（LIS）" class="headerlink" title="最长递增子序列（LIS）"></a>最长递增子序列（LIS）</h3><p>对于每一个位置，依次遍历该位置之前的所有位置，求得最长递增子序列的长度，然后再加一</p>
<p>on2</p>
<h4 id="Ologn的解法"><a href="#Ologn的解法" class="headerlink" title="Ologn的解法"></a>Ologn的解法</h4><p>利用贪心和二分的思想，维护一个最长自增子序列数组d，若a[i] &lt; d[len] ，则在d数组中二分查找第一个小于a[i] 的元素，在他的下一个位置将d数组中的元素替换成a[i] ，</p>
<p>这是因为，总是想让最长上升子序列上升的最慢。len的值(index+1) 就是最长递增子序列的长度。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-type">int</span>[] d;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">lengthOfLIS</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-keyword">if</span>(n==<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        d = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        d[<span class="hljs-number">0</span>] = nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;i&lt;n;++i)&#123;<br>            <span class="hljs-keyword">if</span>(nums[i]&gt;d[index])&#123;<br>                d[++index] = nums[i];<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nums[i]==d[index]) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">id</span> <span class="hljs-operator">=</span> binarySearch(<span class="hljs-number">0</span>,index,d,nums[i]);<br>                d[id] = nums[i];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> index+<span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-type">int</span> <span class="hljs-title function_">binarySearch</span><span class="hljs-params">(<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r,<span class="hljs-type">int</span>[] d,<span class="hljs-type">int</span> target)</span>&#123;<br>        <span class="hljs-keyword">while</span>(l&lt;r)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> ((r-l)&gt;&gt;<span class="hljs-number">1</span>)+l;<br>            <span class="hljs-keyword">if</span>(d[mid]&gt;=target) r = mid;<br>            <span class="hljs-keyword">else</span> l = mid+<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> r;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>





<h3 id="最长连续递增子序列"><a href="#最长连续递增子序列" class="headerlink" title="最长连续递增子序列"></a>最长连续递增子序列</h3><p>因为要求连续递增子序列，所以就不需要比较$dp[i]$和$dp[j] (j&lt;i)$ ，而是直接比较$dp[i+1]$ 和$dp[i]$ ，故只需要一层for循环即可。</p>
<p>区别：</p>
<ul>
<li>不连续的子序列，跟之前的所有状态都有关（0-i个状态）</li>
<li>连续的子序列，只跟前一个状态有关。</li>
</ul>
<h3 id="最长重复子数组"><a href="#最长重复子数组" class="headerlink" title="最长重复子数组"></a>最长重复子数组</h3><h3 id="最长公共子序列（LCS）"><a href="#最长公共子序列（LCS）" class="headerlink" title="最长公共子序列（LCS）"></a>最长公共子序列（LCS）</h3><h2 id="1-23"><a href="#1-23" class="headerlink" title="1&#x2F;23"></a>1&#x2F;23</h2><p>辗转相除法求最大公约数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">GCD</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (a%b == <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-keyword">return</span> b;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">GCD</span>(b, a%b);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>最小公倍数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-title function_">LCM</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span>&#123;<br>    <span class="hljs-keyword">return</span> a/GCD(a,b)*b;<br>&#125;<br></code></pre></td></tr></table></figure>





<h2 id="1-24"><a href="#1-24" class="headerlink" title="1&#x2F;24"></a>1&#x2F;24</h2><h3 id="Manacher算法"><a href="#Manacher算法" class="headerlink" title="Manacher算法"></a>Manacher算法</h3><p>马拉车算法</p>
<p>Manacher 算法是在线性时间内求解最长回文子串的算法。</p>
<p>算法要点：</p>
<p><img src="C:/Users/s%27c/AppData/Roaming/Typora/typora-user-images/image-20220124140113642.png" srcset="/img/loading.gif" lazyload alt="image-20220124140113642"></p>
<ol>
<li><p>奇偶统一判断：在每一个字符中间加入一个本字符串中没有出现过的字符（首尾也加）</p>
<p>转换之后，所有的回文串长度都是奇数</p>
<p>对于以$T[i]$ 为中心的最长回文子串，其长度为$2\times L[i]-1$ (带#)</p>
<p>可以证明，$Len$ 数组可以求出，$Len(i)$ 表示以下标为i的字符为中心，最长回文子串的长度为$Len(i)-1$ .原问题就转化为求$Len(i)$ （每一个字符的回文半径）</p>
</li>
</ol>
<p>求最长回文子串</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">addString</span><span class="hljs-params">(String s)</span>&#123;<br>        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>(<span class="hljs-string">&quot;#&quot;</span>);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i&lt;s.length();++i)&#123;<br>            sb.append(s.charAt(i));<br>            sb.append(<span class="hljs-string">&#x27;#&#x27;</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> sb.toString();<br>    &#125;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">longestPalindrome</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> s.length();<br>        <span class="hljs-keyword">if</span>(s.length()&lt;<span class="hljs-number">2</span>)&#123;<br>            <span class="hljs-keyword">return</span> s;<br>        &#125;<br>        s = addString(s);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">mx</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">loc</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">mymax</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span>[] p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">2</span>*n+<span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i&lt;<span class="hljs-number">2</span>*n+<span class="hljs-number">1</span>;++i)&#123;<br>            <span class="hljs-keyword">if</span>(mx-i&gt;<span class="hljs-number">0</span> &amp;&amp; <span class="hljs-number">2</span>*loc-i&gt;=<span class="hljs-number">0</span>)&#123;<br>                p[i] = Math.min(mx-i,p[<span class="hljs-number">2</span>*loc-i]);<br>            &#125;<br>            <span class="hljs-keyword">else</span> p[i] = <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">while</span>(i+p[i]&lt;<span class="hljs-number">2</span>*n+<span class="hljs-number">1</span> &amp;&amp; i-p[i]&gt;=<span class="hljs-number">0</span> &amp;&amp; s.charAt(i+p[i])==s.charAt(i-p[i]))&#123;<br>                p[i]++;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(i+p[i]&gt;mx)&#123;<br>                mx = i+p[i];<br>                loc = i;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(mymax&lt;p[i])&#123;<br>                mymax = p[i];<br>                start = i;<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> s.substring(start-p[start]+<span class="hljs-number">1</span>,start+p[start]);<br>        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i&lt;t.length();++i)&#123;<br>            <span class="hljs-keyword">if</span>(t.charAt(i)==<span class="hljs-string">&#x27;#&#x27;</span>)&#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            sb.append(t.charAt(i));<br>        &#125;<br>        <span class="hljs-keyword">return</span> sb.toString();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<p>求回文串的个数（把加上#的数组中，每一个p[i]的值&#x2F;2并累加）为什么？？？  好像懂了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">addString</span><span class="hljs-params">(String s)</span>&#123;<br>        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>        sb.append(<span class="hljs-string">&#x27;#&#x27;</span>);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> s.length();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i&lt;n;++i)&#123;<br>            sb.append(s.charAt(i));<br>            sb.append(<span class="hljs-string">&#x27;#&#x27;</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> sb.toString();<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">countSubstrings</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-keyword">if</span>(s.length()&lt;<span class="hljs-number">2</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        &#125;<br>        s = addString(s);<br>        <span class="hljs-comment">// System.out.println(s);</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> s.length();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">mx</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>,loc = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span>[] p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        <span class="hljs-type">char</span>[] c = s.toCharArray();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i&lt;n;++i)&#123;<br>            <span class="hljs-keyword">if</span>(mx&gt;i &amp;&amp; <span class="hljs-number">2</span>*loc-i&gt;=<span class="hljs-number">0</span>)&#123;<br>                p[i] = Math.min(mx-i,p[<span class="hljs-number">2</span>*loc-i]);<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>                p[i] = <span class="hljs-number">1</span>;<br>            &#125;<br>            <span class="hljs-keyword">while</span>(i+p[i]&lt;s.length()&amp;&amp;i-p[i]&gt;=<span class="hljs-number">0</span> &amp;&amp; c[i+p[i]]==c[i-p[i]])&#123;<br>                p[i]++;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(i+p[i]&gt;mx)&#123;<br>                mx = i+p[i];<br>                loc = i;<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i&lt;p.length;++i)&#123;<br>            sum+=p[i]/<span class="hljs-number">2</span>;<br>            <span class="hljs-comment">// System.out.println(p[i]);</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> sum;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<p>唯一一个疑点：为什么取最小值？</p>
<h2 id="1-26"><a href="#1-26" class="headerlink" title="1&#x2F;26"></a>1&#x2F;26</h2><h3 id="线段树"><a href="#线段树" class="headerlink" title="线段树"></a>线段树</h3><p>查询方法：</p>
<ol>
<li>如果这个区间被完全包括在目标区间里里面，直接返回这个区间的值</li>
<li>如果这个区间的左儿子和目标区间有交集，那么搜索左儿子</li>
<li>如果这个区间的右儿子和目标区间有交集，那么搜索右儿子</li>
</ol>
<p>那么对于区间操作，我们考虑引入一个名叫“lazy tag 懒标记）的东西——之所以称其“lazy<em>”，是因为原本区间修改需要通过先改变叶子节点的值，然后不断地向上递归修改祖先节点直至到达根节点，时间复杂度最高可以到达O</em>(<em>n<strong>l</strong>o<strong>g</strong>n</em>)的级别。但当我们引入了懒标记之后，区间更新的期望复杂度就降到了<em>O</em>(<em>l<strong>o</strong>g**n</em>)的级别且甚至会更低.</p>
<h4 id="懒标记"><a href="#懒标记" class="headerlink" title="懒标记"></a>懒标记</h4><blockquote>
<p>pushdown都是在区间分裂之前进行</p>
</blockquote>
<p>懒标记的作用是，记录每次，每个结点要更新的值。     但线段树的优点不在于全记录，而是传递式记录：</p>
<p>整个区间都被操作，记录在公共祖先节点上，只修改了一部分，就只记录在这部分的公共祖先上，如果只修改了自己的话，就只改变自己。</p>
<p>懒标记的意义</p>
<p>由于我们要做的操作是区间加一个数，所以我们不妨在区间进行修改时为该区间打上一个标记，就不必再修改他的儿子所维护区间，等到要使用该节点的儿子节点维护的值时，再将懒标记下放即可，可以节省很多时间，对于每次区间修改和查询，将懒标记下传，可以节省很多时间</p>
<p>注意：也是第一次写代码一直不通过的原因：</p>
<ol>
<li>用线段树维护不同的情况（如区间和，区间最大值），pushdown的逻辑会稍有变化。<br>若是维护区间最值，第一种情况就是tree的区间是[l,r]的子集<br>若是维护区间和，第一种情况就是tree的区间与[l,r]相等</li>
<li>查询query和更新update时，要查询的l r不要变，只改变lc，rc就好</li>
<li>build时，要查询的l r都要变，lc rc也要变</li>
</ol>
<p>L,R是要查询的区间的范围</p>
<h4 id="区间都乘某个数"><a href="#区间都乘某个数" class="headerlink" title="区间都乘某个数"></a>区间都乘某个数</h4><p>若是区间乘法，（洛谷模板题2）则要设两个懒标记，一个lazyAdd，一个lazyMul。</p>
<p>乘法操作时，lazyMul*&#x3D;k   lazy+&#x3D;k</p>
<p>加法操作时 lazyMul不变   lazyAdd+&#x3D;k</p>
<h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><h5 id="区间修改"><a href="#区间修改" class="headerlink" title="区间修改"></a>区间修改</h5><ol>
<li>如果整个区间都被包含就修改整个区间，否则分裂区间，递归处理子区间后再回溯处理父节点代表的区间。</li>
<li>懒标记：如果每次递归处理到叶子节点，复杂度不行，付姐带你表示的区间是左右儿子的整合，我修改父节点表示的区间，因为打了标记，我就会把以前的修改顺带做了，并且把懒标记传递下去。</li>
</ol>
<h5 id="java对象数组特点"><a href="#java对象数组特点" class="headerlink" title="java对象数组特点"></a>java对象数组特点</h5><ol>
<li><p>对于对象数组，使用运算符new只是为数组本身分配空间，并没有对数组的元素进行初始化。即数组元素都为空，<br><img src="https://cdn.jsdelivr.net/gh/dutsc/cloud-image/blog-img/202312052038164.png" srcset="/img/loading.gif" lazyload alt="对象数组初始化"></p>
<p>正确的使用方法，应该分别对每个对象进行初始化，<strong>并且不能使用增强for循环</strong>，因为增强for循环不是本体。</p>
</li>
<li><p>对于基本数据类型，采用new初始化数组时，数组元素也进行了相应的初始化</p>
</li>
</ol>
<h4 id="带懒标记的线段树模板"><a href="#带懒标记的线段树模板" class="headerlink" title="带懒标记的线段树模板"></a>带懒标记的线段树模板</h4><blockquote>
<p>Java版本</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span>&#123;<br>    <span class="hljs-type">int</span> l;<br>    <span class="hljs-type">int</span> r;<br>    <span class="hljs-type">int</span> add;<br>    <span class="hljs-type">int</span> sum;<br><span class="hljs-comment">//    int mul;</span><br>    Node(<span class="hljs-type">int</span> _l,<span class="hljs-type">int</span> _r)&#123;<br>        <span class="hljs-built_in">this</span>.l = _l;<br>        <span class="hljs-built_in">this</span>.r = _r;<br>    &#125;<br>    Node()&#123;<br><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SegmentTreePushdown</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[] nums;<br>    <span class="hljs-keyword">static</span> Node[] tree;<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> n;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">int</span>[] _nums = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">7</span>,<span class="hljs-number">9</span>,<span class="hljs-number">11</span>&#125;;<br>        nums = _nums;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        tree = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>[<span class="hljs-number">4</span>*n];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i&lt;<span class="hljs-number">4</span>*n;++i)&#123;<br>            tree[i] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>();<br>        &#125;<br>        build(<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,n-<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">for</span>(Node tt:tree)&#123;<br>            System.out.println(tt.l + <span class="hljs-string">&quot; &quot;</span> + tt.r + <span class="hljs-string">&quot; &quot;</span> + tt.sum);<br>        &#125;<br>        update(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">5</span>,<span class="hljs-number">3</span>);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">sumtt</span> <span class="hljs-operator">=</span> query(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">4</span>);<br>        System.out.println(sumtt);<br>    &#125;<br><br>    <span class="hljs-comment">// 建树</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">build</span><span class="hljs-params">(<span class="hljs-type">int</span> node, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end)</span>&#123;<br>        tree[node].l = start;<br>        tree[node].r = end;<br>        <span class="hljs-keyword">if</span>(start==end)&#123;<br>            tree[node].sum = nums[start];<br>            <span class="hljs-keyword">return</span> ;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> ((end-start)&gt;&gt;<span class="hljs-number">1</span>)+start;<br>        build(node&lt;&lt;<span class="hljs-number">1</span>,start,mid);<br>        build(node&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>,mid+<span class="hljs-number">1</span>,end);<br>        pushup(node);<br>    &#125;<br>    <span class="hljs-comment">// 区间更新</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">update</span><span class="hljs-params">(<span class="hljs-type">int</span> node,<span class="hljs-type">int</span> L, <span class="hljs-type">int</span> R, <span class="hljs-type">int</span> val)</span>&#123;<br>        System.out.println(<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">if</span>(L&lt;=tree[node].l &amp;&amp; R&gt;=tree[node].r)&#123;<br>            tree[node].add += val;<br>            tree[node].sum += val*(tree[node].r-tree[node].l+<span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">return</span> ;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> ((tree[node].r-tree[node].l)&gt;&gt;<span class="hljs-number">1</span>)+tree[node].l;<br>        pushdown(node);<br>        <span class="hljs-keyword">if</span>(L&lt;=mid)<br>            update(node&lt;&lt;<span class="hljs-number">1</span>,L,R,val);<br>        <span class="hljs-keyword">if</span>(R&gt;mid)<br>            update(node&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>,L,R,val);<br>        pushup(node);<br>    &#125;<br>    <span class="hljs-comment">// 区间查询</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">query</span><span class="hljs-params">(<span class="hljs-type">int</span> node, <span class="hljs-type">int</span> L,<span class="hljs-type">int</span> R)</span>&#123;<br>        <span class="hljs-keyword">if</span>(L&gt;tree[node].r || R&lt;tree[node].l) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span>(L&lt;=tree[node].l &amp;&amp; R&gt;=tree[node].r) <span class="hljs-keyword">return</span> tree[node].sum;<br>        pushdown(node);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> ((tree[node].r-tree[node].l)&gt;&gt;<span class="hljs-number">1</span>)+tree[node].l;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span>(L&lt;=mid)<br>            res += query(node&lt;&lt;<span class="hljs-number">1</span>,L,R);<br>        <span class="hljs-keyword">if</span>(R&gt;mid)<br>            res += query(node&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>,L,R);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-comment">// 回溯更新</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">pushup</span><span class="hljs-params">(<span class="hljs-type">int</span> node)</span>&#123;<br>        tree[node].sum = tree[node&lt;&lt;<span class="hljs-number">1</span>].sum+tree[node&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>].sum;<br>    &#125;<br>    <span class="hljs-comment">// 下传懒标记</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">pushdown</span><span class="hljs-params">(<span class="hljs-type">int</span> node)</span>&#123;<br>        <span class="hljs-keyword">if</span>(tree[node].add!=<span class="hljs-number">0</span>)&#123;<br>            tree[node&lt;&lt;<span class="hljs-number">1</span>].add += tree[node].add;<br>            tree[node&lt;&lt;<span class="hljs-number">1</span>].sum += tree[node].add*(tree[node&lt;&lt;<span class="hljs-number">1</span>].r-tree[node&lt;&lt;<span class="hljs-number">1</span>].l+<span class="hljs-number">1</span>);<br>            tree[node&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>].add += tree[node].add;<br>            tree[node&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>].sum += tree[node].add*(tree[node&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>].r-tree[node&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>].l+<span class="hljs-number">1</span>);<br>            tree[node].add = <span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这份代码第一次写，出错的地方：</p>
<ol>
<li><code>update</code> 和<code>query</code> 在判断递归条件的时候，要用L R和mid作比较，而不是用tree的lr。</li>
<li>pushdown操作中，子节点的懒标记要使用+&#x3D;，而不是直接赋值。因为可能子节点之前就有懒标记了。</li>
</ol>
<blockquote>
<p>c++版本</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//</span><br><span class="hljs-comment">// Created by s&#x27;c on 2022/4/4.</span><br><span class="hljs-comment">//</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;iostream&quot;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MAX = <span class="hljs-number">100010</span>;<br><span class="hljs-type">int</span> nums[MAX]=&#123;<span class="hljs-number">0</span>&#125;;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span>&#123;<br>    <span class="hljs-type">int</span> l;<br>    <span class="hljs-type">int</span> r;<br>    ll add;<br>    ll sum;<br>&#125;;<br>node tree[<span class="hljs-number">4</span>*MAX];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pushup</span><span class="hljs-params">(<span class="hljs-type">int</span> node)</span></span>&#123;<br>    tree[node].sum = tree[node&lt;&lt;<span class="hljs-number">1</span>].sum + tree[node&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>].sum;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">build</span><span class="hljs-params">(<span class="hljs-type">int</span> node,<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r)</span></span>&#123;<br>    tree[node].l = l;<br>    tree[node].r = r;<br>    <span class="hljs-keyword">if</span>(l==r)&#123;<br>        tree[node].sum = nums[l];<br>        <span class="hljs-keyword">return</span> ;<br>    &#125;<br>    <span class="hljs-type">int</span> mid = ((r-l)&gt;&gt;<span class="hljs-number">1</span>)+l;<br>    <span class="hljs-built_in">build</span>(node&lt;&lt;<span class="hljs-number">1</span>,l,mid);<br>    <span class="hljs-built_in">build</span>(node&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>,mid+<span class="hljs-number">1</span>,r);<br>    <span class="hljs-built_in">pushup</span>(node);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pushdown</span><span class="hljs-params">(<span class="hljs-type">int</span> node)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(tree[node].add)&#123;<br>        tree[node&lt;&lt;<span class="hljs-number">1</span>].add += tree[node].add;<br>        tree[node&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>].add += tree[node].add;<br>        tree[node&lt;&lt;<span class="hljs-number">1</span>].sum += tree[node].add*(tree[node&lt;&lt;<span class="hljs-number">1</span>].r-tree[node&lt;&lt;<span class="hljs-number">1</span>].l+<span class="hljs-number">1</span>);<br>        tree[node&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>].sum += tree[node].add*(tree[node&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>].r-tree[node&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>].l+<span class="hljs-number">1</span>);<br>        tree[node].add = <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">update</span><span class="hljs-params">(<span class="hljs-type">int</span> node,<span class="hljs-type">int</span> L,<span class="hljs-type">int</span> R,<span class="hljs-type">int</span> val)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(L&lt;=tree[node].l &amp;&amp; R&gt;=tree[node].r)&#123;<br>        tree[node].sum += val*(tree[node].r-tree[node].l+<span class="hljs-number">1</span>);<br>        tree[node].add += val;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-type">int</span> mid = ((tree[node].r-tree[node].l)&gt;&gt;<span class="hljs-number">1</span>)+tree[node].l;<br>    <span class="hljs-built_in">pushdown</span>(node);<br>    <span class="hljs-keyword">if</span>(L&lt;=mid) <span class="hljs-built_in">update</span>(node&lt;&lt;<span class="hljs-number">1</span>,L,R,val);<br>    <span class="hljs-keyword">if</span>(R&gt;mid) <span class="hljs-built_in">update</span>(node&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>,L,R,val);<br>    <span class="hljs-built_in">pushup</span>(node);<br>&#125;<br><span class="hljs-function">ll <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> node,<span class="hljs-type">int</span> L,<span class="hljs-type">int</span> R)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(R&lt;tree[node].l || L&gt;tree[node].r) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span>(L&lt;=tree[node].l &amp;&amp; R&gt;=tree[node].r) <span class="hljs-keyword">return</span> tree[node].sum;<br>    <span class="hljs-type">int</span> mid = ((tree[node].r-tree[node].l)&gt;&gt;<span class="hljs-number">1</span>)+tree[node].l;<br>    <span class="hljs-built_in">pushdown</span>(node);<br>    ll res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span>(L&lt;=mid) res+=<span class="hljs-built_in">query</span>(node&lt;&lt;<span class="hljs-number">1</span>,L,R);<br>    <span class="hljs-keyword">if</span>(R&gt;mid) res+=<span class="hljs-built_in">query</span>(node&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>,L,R);<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> n,m;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i&lt;n;++i)&#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;nums[i]);<br>    &#125;<br>    <span class="hljs-built_in">build</span>(<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,n<span class="hljs-number">-1</span>);<br>    <span class="hljs-keyword">while</span>(m--&gt;<span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-type">int</span> tt;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;tt);<br>        <span class="hljs-keyword">if</span>(tt==<span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-comment">// update</span><br>            <span class="hljs-type">int</span> l,r,k;<br>            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>,&amp;l,&amp;r,&amp;k);<br>            <span class="hljs-built_in">update</span>(<span class="hljs-number">1</span>,l<span class="hljs-number">-1</span>,r<span class="hljs-number">-1</span>,k);<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-comment">// query</span><br>            <span class="hljs-type">int</span> l,r;<br>            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;l,&amp;r);<br>            ll ans = <span class="hljs-built_in">query</span>(<span class="hljs-number">1</span>,l<span class="hljs-number">-1</span>,r<span class="hljs-number">-1</span>);<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%ld\n&quot;</span>,ans);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>





<h3 id="树状数组"><a href="#树状数组" class="headerlink" title="树状数组"></a>树状数组</h3><h4 id="区间长度"><a href="#区间长度" class="headerlink" title="区间长度"></a>区间长度</h4><p>$c[i]$ 存储的值的区间长度为$lowbit(i)$ 则$lowbit(i)&#x3D;(-i)&amp;i$  </p>
<h4 id="前驱和后继"><a href="#前驱和后继" class="headerlink" title="前驱和后继"></a>前驱和后继</h4><p>$c[i]$ 的直接前驱为$c[i-lowbit(i)]$ ,$c[i]$ 的直接后继为$c[i+lowbit(i)]$ </p>
<p>前驱，即$c[i]$ 的直接前驱的直接前驱，即$c[i]$ 左侧所有子树的根</p>
<p>后继，即$c[i]$ 直接后继的直接后继，即$c[i]$ 的所有祖先</p>
<h4 id="查询前缀和"><a href="#查询前缀和" class="headerlink" title="查询前缀和"></a>查询前缀和</h4><p>$c[i]$ 的前缀和$sum[i]$ 等于$c[i]$ 加上$c[i]$ 的前驱</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sum</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span></span>&#123;<br>    <span class="hljs-type">int</span> s = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(;i&gt;<span class="hljs-number">0</span>;i-=<span class="hljs-built_in">lowbit</span>(i))&#123;<br>        s+=c[i];<br>    &#125;<br>    <span class="hljs-keyword">return</span> s;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="点更新"><a href="#点更新" class="headerlink" title="点更新"></a>点更新</h4><p>若对$a[i]$ 修改，则只需要对$c[i]$ 及其所有的后继（祖先节点）进行修改即可，不需要修改其他节点</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> i,<span class="hljs-type">int</span> v)</span></span>&#123;<br>    <span class="hljs-keyword">for</span>(;i&lt;=n;i+=<span class="hljs-built_in">lowbit</span>(i))&#123;<br>        c[i]+=v;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>注意：树状数组的下标必须从1开始，而不能从0开始，因为lowbit(i)&#x3D;0会出现死循环</p>
<h4 id="查询区间和"><a href="#查询区间和" class="headerlink" title="查询区间和"></a>查询区间和</h4><p>用前缀和数组的思想</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sum</span><span class="hljs-params">(<span class="hljs-type">int</span> i,<span class="hljs-type">int</span> j)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">sum</span>(j)-<span class="hljs-built_in">sum</span>(i<span class="hljs-number">-1</span>);<br>&#125;<br></code></pre></td></tr></table></figure>



<h2 id="1-30"><a href="#1-30" class="headerlink" title="1&#x2F;30"></a>1&#x2F;30</h2><h3 id="快速幂算法"><a href="#快速幂算法" class="headerlink" title="快速幂算法"></a>快速幂算法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">PowerMod</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b, <span class="hljs-type">int</span> c)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> ans = <span class="hljs-number">1</span>;<br>    a = a % c;<br>    <span class="hljs-keyword">while</span>(b&gt;<span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">if</span>(b % <span class="hljs-number">2</span> = = <span class="hljs-number">1</span>)<br>        	ans = (ans * a) % c;<br>        b = b/<span class="hljs-number">2</span>;<br>        a = (a * a) % c;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="矩阵快速幂"><a href="#矩阵快速幂" class="headerlink" title="矩阵快速幂"></a>矩阵快速幂</h3><p>就是把整数的乘法换成矩阵的乘法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//矩阵乘法    </span><br><span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[][] Mul(<span class="hljs-type">int</span>[][] a,<span class="hljs-type">int</span>[][] b, <span class="hljs-type">int</span> n, <span class="hljs-type">int</span> mod)&#123;<br>        <span class="hljs-type">int</span>[][] temp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n][n];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i&lt;n;++i)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;j&lt;n;++j)&#123;<br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;k&lt;n;++k)&#123;<br>                    temp[i][j] += ((a[i][k]%mod)*(b[k][j]%mod))%mod;<br>                    temp[i][j] %= mod;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> temp;<br>    &#125;<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[][] FastPow(<span class="hljs-type">int</span>[][] a,<span class="hljs-type">int</span> p,<span class="hljs-type">int</span> mod)&#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> a.length;<br>        <span class="hljs-comment">//对于矩阵乘法来说，应该初始化为单位矩阵</span><br>        <span class="hljs-type">int</span>[][] res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n][n];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i&lt;n;++i)&#123;<br>            res[i][i] = <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">while</span>(p&gt;<span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">if</span>(p%<span class="hljs-number">2</span>==<span class="hljs-number">1</span>) res = Mul(res,a,n,mod);<br>            p = p&gt;&gt;<span class="hljs-number">1</span>;<br>            a = Mul(a,a,n,mod);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br></code></pre></td></tr></table></figure>



<h2 id="2-8"><a href="#2-8" class="headerlink" title="2&#x2F;8"></a>2&#x2F;8</h2><h3 id="贝祖定理"><a href="#贝祖定理" class="headerlink" title="贝祖定理"></a>贝祖定理</h3><p>如果$ax+by&#x3D;z$ 成立，那么一定满足$z$ 是$x$ 和$y$ 的最大公约数的倍数，$a,b,x,y,z$ 都是整数。</p>
<p>若java中，lc提交时出现int与二进制数不能进行位运算的错误，则给运算整体加上括号。</p>
<h3 id="2的幂"><a href="#2的幂" class="headerlink" title="2的幂"></a>2的幂</h3><p>判断一个数是2的幂的条件</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++">n&amp;(n<span class="hljs-number">-1</span>)==<span class="hljs-number">0</span>;<br>或者<br>n&amp;(-n) = n;<br></code></pre></td></tr></table></figure>



<h3 id="交换法实现全排列"><a href="#交换法实现全排列" class="headerlink" title="交换法实现全排列"></a>交换法实现全排列</h3><p>　　原理：假设以字符串第0个位置（也就是第一个字符）为起点，分别与后面的每一个位置对应的字符进行交换。直到k等于字符串最后一个位置时，就会排列出新的组合。</p>
<h3 id="数组所能开辟的最大空间"><a href="#数组所能开辟的最大空间" class="headerlink" title="数组所能开辟的最大空间"></a>数组所能开辟的最大空间</h3><ul>
<li><p><strong>函数内申请的变量，数组，是在栈（stack）中申请的一段连续的空间。栈的默认大小为2M或1M，开的比较小。</strong></p>
</li>
<li><p><strong>全局变量，全局数组，静态数组（static）则是开在全局区（静态区）（static）。大小为2G，所以能够开的很大。</strong>(1.5-1.8G之间)</p>
<p>1e7  ——1e9    </p>
</li>
<li><p><strong>而malloc、new出的空间，则是开在堆（heap）的一段不连续的空间。理论上则是硬盘大小。</strong></p>
</li>
</ul>
<h3 id="dfs中的两个函数"><a href="#dfs中的两个函数" class="headerlink" title="dfs中的两个函数"></a>dfs中的两个函数</h3><p>约束函数：能否得到可行解的约束</p>
<p>限界函数：能否得到最优解的约束</p>
<h3 id="include"><a href="#include" class="headerlink" title="#include&lt;bits&#x2F;stdc++.h&gt;"></a>#include&lt;bits&#x2F;stdc++.h&gt;</h3><p>包含c++目前所有的头文件</p>
<h2 id="2-10"><a href="#2-10" class="headerlink" title="2&#x2F;10"></a>2&#x2F;10</h2><p>dfs求解组合问题时，每一次递归是树枝上加深深度，而for循环是遍历这一个树层，注意去重的逻辑，是在同一树层中去重。组合总和2，不排序好像没办法写。</p>
<h2 id="2-12"><a href="#2-12" class="headerlink" title="2&#x2F;12"></a>2&#x2F;12</h2><p>解数独，dfs返回值是boolean类型的原因</p>
<p>找到一个正确的答案就可以直接返回，而不用再回溯去搜索了，也就是不用搜索完全部的情况。</p>
<p>java中char与int相互转换</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// &#x27;1&#x27; -&gt; 1</span><br><span class="hljs-type">char</span> <span class="hljs-variable">c9</span> <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;1&#x27;</span>;<br><span class="hljs-type">int</span> <span class="hljs-variable">num9</span> <span class="hljs-operator">=</span> c9 - <span class="hljs-string">&#x27;0&#x27;</span>;<br><br><span class="hljs-comment">// 1 -&gt; &#x27;1&#x27;</span><br><span class="hljs-type">int</span> <span class="hljs-variable">num10</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br><span class="hljs-type">char</span> <span class="hljs-variable">c10</span> <span class="hljs-operator">=</span> (<span class="hljs-type">char</span>)(num10 + <span class="hljs-string">&#x27;0&#x27;</span>);<br></code></pre></td></tr></table></figure>





<p>在c++中若是想输入字符，一定要格外小心，输入数字之后再输入字符，就一定要记得getchar()，输入字符前一定要记得getchar()，输入字符后若想换行，也要记得getchar()</p>
<h3 id="memset"><a href="#memset" class="headerlink" title="memset()"></a>memset()</h3><p>memset()函数非常好用</p>
<p>第一个参数是一个指针，第二个参数是要初始化填入的值，第三个参数是要初始化的大小</p>
<p>比如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> row[<span class="hljs-number">9</span>][<span class="hljs-number">10</span>];<br><span class="hljs-type">int</span> col[<span class="hljs-number">9</span>][<span class="hljs-number">10</span>];<br><span class="hljs-type">int</span> grid[<span class="hljs-number">9</span>][<span class="hljs-number">10</span>];<br><span class="hljs-built_in">memset</span>(row,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(row));<br><span class="hljs-built_in">memset</span>(col,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(col));<br><span class="hljs-built_in">memset</span>(grid,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(grid));<br></code></pre></td></tr></table></figure>

<p>这就是表示把三个二维数组的初始值都填入0</p>
<h3 id="输入二维字符数组的两种方式"><a href="#输入二维字符数组的两种方式" class="headerlink" title="输入二维字符数组的两种方式"></a>输入二维字符数组的两种方式</h3><p>方法一</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">char</span> Map[<span class="hljs-number">5</span>][<span class="hljs-number">5</span>];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;n);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>,Map[i]);<br>    &#125;<br></code></pre></td></tr></table></figure>

<p>方法二</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">char</span> Map[<span class="hljs-number">5</span>][<span class="hljs-number">5</span>];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;n);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        cin&gt;&gt;Map[i];<br>    &#125;<br></code></pre></td></tr></table></figure>



<p>cin 输入默认情况下是忽略 回车，空格，tab等空白符</p>
<p>注意方格图中xy和ij的对应关系，如下</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> m = grid.<span class="hljs-built_in">size</span>();<br><span class="hljs-type">int</span> n = grid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br></code></pre></td></tr></table></figure>

<p>此时，m表示有几行，对应y轴</p>
<p>n表示有几列，对应x轴</p>
<p>遍历的时候若i与m对应，j与n对应，则</p>
<figure class="highlight x++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs x++"><span class="hljs-built_in">int</span> x = j + d[k][<span class="hljs-number">0</span>];<br><span class="hljs-built_in">int</span> y = i + d[k][<span class="hljs-number">1</span>];<br>dfs(y,x);<br></code></pre></td></tr></table></figure>

<p>注意终止条件中i，j与m，n的对应关系，这个是最重要的，自己定义的xy怎么都可以。</p>
<h2 id="2-16"><a href="#2-16" class="headerlink" title="2&#x2F;16"></a>2&#x2F;16</h2><h3 id="记忆化容器的选择"><a href="#记忆化容器的选择" class="headerlink" title="记忆化容器的选择"></a>记忆化容器的选择</h3><p>但使用布尔数组作为记忆化容器往往无法区分「状态尚未计算」和「状态已经计算，并且结果为 false」两种情况。</p>
<p>因此我们需要转为使用 int[石子列表下标][跳跃步数]，默认值 0 代表状态尚未计算，−1 代表计算状态为 false，1 代表计算状态为 true。</p>
<p>存哈希表的技巧：可以把数组中的数值存为x，数组下标存为y，这样便于查找</p>
<p>记忆化容器可以使用哈希表</p>
<p>若哈希表中需要存储的辨识关键字有多个，则可以采用字符串形式。比如青蛙过河中，可以采用<code>k+&quot;-&quot;+i</code>  的string形式存储，y值存储搜索成功或失败（没有搜索到则不在哈希表中）</p>
<h2 id="2-27"><a href="#2-27" class="headerlink" title="2&#x2F;27"></a>2&#x2F;27</h2><p>二分法查找符合条件的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">while</span>(l&lt;r)&#123;<br>    <span class="hljs-comment">//....</span><br>    <span class="hljs-keyword">if</span>(check())&#123;<br>    	l = mid + <span class="hljs-number">1</span>;<br>	&#125;<br>	<span class="hljs-keyword">else</span>&#123;<br>    	r = mid;<br>	&#125;<br>&#125;<br><br><br><span class="hljs-keyword">return</span> r;<br><span class="hljs-comment">// return l;也对,因为此时l==r，才会退出循环</span><br></code></pre></td></tr></table></figure>

<p>排序后，要找第一个符合条件的，这样分析</p>
<p><img src="https://cdn.jsdelivr.net/gh/dutsc/cloud-image/blog-img/202312052038491.png" srcset="/img/loading.gif" lazyload alt="威哥讲解二分法"></p>
<p>nnnyyy  （n表示不满足条件，y表示满足条件）</p>
<p>满足条件了，就保持不变，即r &#x3D; mid</p>
<p>不满足条件说明mid指向的是n，那么就l&#x3D;mid＋1</p>
<p>找到一个符合条件的也不要急于返回，因为还可能有更优的，本题中对应，还有更小的符合条件的y</p>
<p>二分法的题目一定要注意取值范围，不行就把int变为long</p>
<h4 id="位运算的优先级"><a href="#位运算的优先级" class="headerlink" title="位运算的优先级"></a>位运算的优先级</h4><p><strong>非常低，运算时必须加括号</strong>，否则就会出错</p>
<p>111222333</p>
<p>找最小的2，就是（最左边的，符合条件的）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">while</span>(l&lt;r)&#123;<br>    <span class="hljs-type">int</span> mid = ((r-l)&gt;&gt;<span class="hljs-number">1</span>)+l;<br>    <span class="hljs-keyword">if</span>(nums[mid]&lt;target)&#123;<br>        l = mid + <span class="hljs-number">1</span>;<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        r = mid;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">return</span> r;<br></code></pre></td></tr></table></figure>

<p>找最大的2，就是（最右边的，符合条件的）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">while</span>(l&lt;r)&#123;<br>    <span class="hljs-type">int</span> mid = ((r-l+<span class="hljs-number">1</span>)&gt;&gt;<span class="hljs-number">1</span>)+l;<br>    <span class="hljs-keyword">if</span>(nums[mid]&gt;target)&#123;<br>        r = mid - <span class="hljs-number">1</span>;<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        l = mid;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">return</span> l;<br></code></pre></td></tr></table></figure>

<p>符合条件，就保持不变，等于mid，而且if中的条件包含等于号的那一部分，也是等于mid，两者是相互对应的。(这个不适用全部的，还是要用check的思想来考虑问题)</p>
<p>找最左边的符合条件的，则r   right遇到了就保持不变</p>
<p>找最右边的符合条件的，则l  left遇到了就保持不变</p>
<h4 id="二分法的本质"><a href="#二分法的本质" class="headerlink" title="二分法的本质"></a>二分法的本质</h4><p>二分法的本质是<strong>二段性</strong>，并不是从一个有序数组中找出一个数（这只是二分法的一个应用）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">search</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-comment">//通过二分找到分割点   整个数组中最小的元素</span><br>        <span class="hljs-keyword">if</span>(n==<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">if</span>(n==<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> target==nums[<span class="hljs-number">0</span>]?<span class="hljs-number">0</span>:<span class="hljs-number">-1</span>;<br>        <span class="hljs-type">int</span> l = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> r = n<span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">while</span>(l&lt;r)&#123;<br>            <span class="hljs-type">int</span> mid = ((r-l+<span class="hljs-number">1</span>)&gt;&gt;<span class="hljs-number">1</span>)+l;<br>            <span class="hljs-keyword">if</span>(nums[mid]&gt;=nums[<span class="hljs-number">0</span>])&#123;<br>                l = mid;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                r = mid - <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(target&lt;nums[<span class="hljs-number">0</span>])&#123;<br>            <span class="hljs-comment">//后半段二分</span><br>            l = l+<span class="hljs-number">1</span>;<br>            r = n<span class="hljs-number">-1</span>;<br>            <span class="hljs-keyword">while</span>(l&lt;r)&#123;<br>                <span class="hljs-type">int</span> mid = ((r-l)&gt;&gt;<span class="hljs-number">1</span>)+l;<br>                <span class="hljs-keyword">if</span>(nums[mid]&lt;target)&#123;<br>                    l = mid + <span class="hljs-number">1</span>;<br>                &#125;<span class="hljs-keyword">else</span>&#123;<br>                    r = mid;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">return</span> target==nums[r]?r:<span class="hljs-number">-1</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-comment">//前半段二分</span><br>            l = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">while</span>(l&lt;r)&#123;<br>                <span class="hljs-type">int</span> mid = ((r-l)&gt;&gt;<span class="hljs-number">1</span>)+l;<br>                <span class="hljs-keyword">if</span>(nums[mid]&lt;target)&#123;<br>                    l = mid + <span class="hljs-number">1</span>;<br>                &#125;<span class="hljs-keyword">else</span>&#123;<br>                    r = mid;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">return</span> target==nums[r]?r:<span class="hljs-number">-1</span>;<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>



<h2 id="2-28"><a href="#2-28" class="headerlink" title="2&#x2F;28"></a>2&#x2F;28</h2><h3 id="旋转数组"><a href="#旋转数组" class="headerlink" title="旋转数组"></a>旋转数组</h3><p>有序数组通过旋转转变为部分有序，要找出其中最小（最大）的元素，要使用二分法。</p>
<p>找到最大的元素比较方便，使用向上取整，l &#x3D; mid，因为此时可以避免nums[mid]与nums[0]是同一个元素，避免了极端情况的错误。</p>
<p>找到最大元素的下标后，判断是不是最后一个元素，若是最后一个元素，则若找最小的元素要返回nums[0]；若不是最后一个元素，则返回nums[l+1]即可。</p>
<p>有重复元素的代码模板</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findMin</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> l = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> r = n<span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">while</span>(r&gt;<span class="hljs-number">0</span> &amp;&amp; nums[<span class="hljs-number">0</span>]==nums[r]) r--;<br>        <span class="hljs-keyword">if</span>(r==l) <span class="hljs-keyword">return</span> nums[l];<br>        <span class="hljs-keyword">while</span>(l&lt;r)&#123;<br>            <span class="hljs-type">int</span> mid = ((r-l+<span class="hljs-number">1</span>)&gt;&gt;<span class="hljs-number">1</span>)+l;<br>            <span class="hljs-keyword">if</span>(nums[mid]&gt;=nums[<span class="hljs-number">0</span>]) l = mid;<br>            <span class="hljs-keyword">else</span> r = mid - <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(l==n<span class="hljs-number">-1</span>)&#123;<br>            <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>];<br>        &#125;<br>        <span class="hljs-keyword">return</span> nums[l+<span class="hljs-number">1</span>];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>



<h2 id="3-1"><a href="#3-1" class="headerlink" title="3&#x2F;1"></a>3&#x2F;1</h2><p>向上取整的方法</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">(n<span class="hljs-number">-1</span>)/m+<span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure>



<h2 id="3-7"><a href="#3-7" class="headerlink" title="3&#x2F;7"></a>3&#x2F;7</h2><h3 id="快速将数字转成n进制表示的字符串"><a href="#快速将数字转成n进制表示的字符串" class="headerlink" title="快速将数字转成n进制表示的字符串"></a>快速将数字转成n进制表示的字符串</h3><p>Integer.toString(int par1,int par2),par1表示要转成字符串的数字，par2表示要转成的进制表示，如：</p>
<p>Integer.toString(22,2),表示把22转成2进制表示的字符串，</p>
<p>Integer.toString(22,10),表示把22转成10进制表示的字符串，</p>
<p>Integer.toString(22,16),表示把22转成16进制表示的字符串，</p>
<p>Integer.toString(22,36),表示把22转成36进制表示的字符串，即10到36之间的数字表示为a到z的表示</p>
<h3 id="二维前缀和模板"><a href="#二维前缀和模板" class="headerlink" title="二维前缀和模板"></a>二维前缀和模板</h3><p>「二维前缀和」解决的是二维矩阵中的矩形区域求和问题。</p>
<p>二维前缀和数组中的每一个格子记录的是「以当前位置为区域的右下角（区域左上角恒定为原数组的左上角）的区域和」</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 预处理前缀和数组</span><br>&#123;<br>    sum = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">1</span>][m + <span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt;= m; j++) &#123;<br>            <span class="hljs-comment">// 当前格子(和) = 上方的格子(和) + 左边的格子(和) - 左上角的格子(和) + 当前格子(值)【和是指对应的前缀和，值是指原数组中的值】</span><br>            sum[i][j] = sum[i - <span class="hljs-number">1</span>][j] + sum[i][j - <span class="hljs-number">1</span>] - sum[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] + matrix[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>];<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 首先我们要令左上角为 (x1, y1) 右下角为 (x2, y2)</span><br><span class="hljs-comment">// 计算 (x1, y1, x2, y2) 的结果</span><br>&#123;<br>    <span class="hljs-comment">// 前缀和是从 1 开始，原数组是从 0 开始，上来先将原数组坐标全部 +1，转换为前缀和坐标</span><br>    x1++; y1++; x2++; y2++;<br>    <span class="hljs-comment">// 记作 22 - 12 - 21 + 11，然后 不减，减第一位，减第二位，减两位</span><br>    <span class="hljs-comment">// 也可以记作 22 - 12(x - 1) - 21(y - 1) + 11(x y 都 - 1)</span><br>    ans = sum[x2][y2] - sum[x1 - <span class="hljs-number">1</span>][y2] - sum[x2][y1 - <span class="hljs-number">1</span>] + sum[x1 - <span class="hljs-number">1</span>][y1 - <span class="hljs-number">1</span>];<br>&#125;<br><br><br></code></pre></td></tr></table></figure>



<h3 id="前缀和、树状数组、线段树选择"><a href="#前缀和、树状数组、线段树选择" class="headerlink" title="前缀和、树状数组、线段树选择"></a>前缀和、树状数组、线段树选择</h3><p>针对不同的题目，我们有不同的方案可以选择（假设我们有一个数组）：</p>
<p>数组不变，求区间和：「前缀和」、「树状数组」、「线段树」</p>
<p>多次修改某个数，求区间和：「树状数组」、「线段树」</p>
<p>多次整体修改某个区间，求区间和：「线段树」、「树状数组」（看修改区间的数据范围）</p>
<p>多次将某个区间变成同一个数，求区间和：「线段树」、「树状数组」（看修改区间的数据范围）</p>
<p>这样看来，「线段树」能解决的问题是最多的，那我们是不是无论什么情况都写「线段树」呢？</p>
<p>答案并不是，而且恰好相反，只有在我们遇到第 4 类问题，不得不写「线段树」的时候，我们才考虑线段树。</p>
<p>因为「线段树」代码很长，而且常数很大，实际表现不算很好。我们只有在不得不用的时候才考虑「线段树」。</p>
<p>总结一下，我们应该按这样的优先级进行考虑：</p>
<p>简单求区间和，用「前缀和」<br>多次将某个区间变成同一个数，用「线段树」<br>其他情况，用「树状数组」</p>
<h4 id="树状数组模板"><a href="#树状数组模板" class="headerlink" title="树状数组模板"></a>树状数组模板</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 上来先把三个方法写出来</span><br>&#123;<br>    <span class="hljs-type">int</span>[] tree;<br>    <span class="hljs-type">int</span> <span class="hljs-title function_">lowbit</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> &#123;<br>        <span class="hljs-keyword">return</span> x &amp; -x;<br>    &#125;<br>    <span class="hljs-comment">// 查询前缀和的方法</span><br>    <span class="hljs-type">int</span> <span class="hljs-title function_">query</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> x; i &gt; <span class="hljs-number">0</span>; i -= lowbit(i)) ans += tree[i];<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>    <span class="hljs-comment">// 在树状数组 x 位置中增加值 u</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> u)</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> x; i &lt;= n; i += lowbit(i)) tree[i] += u;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 初始化「树状数组」，要默认数组是从 1 开始</span><br>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) add(i + <span class="hljs-number">1</span>, nums[i]);<br>&#125;<br><br><span class="hljs-comment">// 使用「树状数组」：</span><br>&#123;   <br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">update</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> val)</span> &#123;<br>        <span class="hljs-comment">// 原有的值是 nums[i]，要使得修改为 val，需要增加 val - nums[i]</span><br>        add(i + <span class="hljs-number">1</span>, val - nums[i]); <br>        nums[i] = val;<br>    &#125;<br>    <br>    <span class="hljs-type">int</span> <span class="hljs-title function_">sumRange</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> &#123;<br>        <span class="hljs-keyword">return</span> query(r + <span class="hljs-number">1</span>) - query(l);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>



<p>求两个数组（一个数组也可以）中相加等于target的数对的个数</p>
<p>O(nlogn)</p>
<ol>
<li><p>先对两个数组排序</p>
</li>
<li><p>用双指针法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//一个从头开始遍历，一个从尾开始遍历,和小于sum则左边++，和大于sum则右边--</span><br>Arrays.sort(nums1);<br>Arrays.sort(nums2);<br><span class="hljs-keyword">while</span>(i&lt;n &amp;&amp; j&gt;=<span class="hljs-number">0</span>)&#123;<br>    <span class="hljs-keyword">if</span>(nums1[i]+nums[j]&lt;target)&#123;<br>        i++;<br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nums1[i]+nums[j]&gt;target)&#123;<br>        j--;<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        i++;<br>        j--;<br>        res++;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ol>
<h2 id="3-8"><a href="#3-8" class="headerlink" title="3&#x2F;8"></a>3&#x2F;8</h2><p>前缀和数组的下标数量通常比数组的下标数量多1.</p>
<p>树状数组需要结合差分数组才能完成区间修改+单点查询</p>
<h3 id="差分数组"><a href="#差分数组" class="headerlink" title="差分数组"></a>差分数组</h3><p>区间修改，单点查询</p>
<p>差分数组比原数组多一位，且最后一位什么也不表示，求前缀和的时候也不用管他。</p>
<p>可以看到，如果需要对L<del>R 范围内所有数都进行相同的操作，我们不需要从L</del>R遍历arr然后在每个值上进行相同操作，只需要在差分数组d中改变L和R+1的值即可。但是在查询arr数组中某个位置的数时，却要根据差分数组从前往后递推求值。（求前缀和）</p>
<h2 id="3-10"><a href="#3-10" class="headerlink" title="3&#x2F;10"></a>3&#x2F;10</h2><p>连续异或运算也可以使用前缀异或，但是要利用一个特性：相同的值异或结果为0</p>
<p>本质上还是利用集合（区间结果）的容斥原理。只不过前缀和需要利用「减法（逆运算）」做容斥，而前缀异或是利用「相同数值进行异或结果为 00（偶数次的异或结果为 00）」的特性实现容斥.</p>
<h3 id="归并排序求逆序对的数目"><a href="#归并排序求逆序对的数目" class="headerlink" title="归并排序求逆序对的数目"></a>归并排序求逆序对的数目</h3><p>思想：每一次合并时，统计右边的数组对逆序对的贡献。若左边数组还没合并完成，右边的数先合并到总数组中，那么右边合并的数就会对逆序对产生贡献，产生的贡献为<strong>左边数组剩余的数字的数目</strong></p>
<p>注意，归并排序中有一个优化，即在递归的过程中，若两个小数组分别排序后，合并之前，首先判断一下$nums[mid]$ 与$nums[mid+1]$ 的大小关系。若$$nums[mid] \leq nums[mid+1]$$ </p>
<p>则可以直接返回左边数组的逆序对的数目+右边数组的逆序对的数目，而不必计算合并时产生的逆序对的数目$crossNum$ .但是注意，只有在合并函数merge中才有逆序对计数操作。</p>
<h2 id="3-11"><a href="#3-11" class="headerlink" title="3&#x2F;11"></a>3&#x2F;11</h2><h3 id="建图"><a href="#建图" class="headerlink" title="建图"></a>建图</h3><p>建图，使用邻接表</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;Integer&gt;[] children = <span class="hljs-keyword">new</span> <span class="hljs-title class_">List</span>[n];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i&lt;n;++i)&#123;<br>            children[i] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i&lt;n;++i)&#123;<br>            <span class="hljs-keyword">if</span>(parents[i]!=-<span class="hljs-number">1</span>) <br>            &#123;<br>                children[parents[i]].add(i);<br>                <span class="hljs-comment">// children[i].add(parents[i]);</span><br>            &#125;<br>        &#125;<br></code></pre></td></tr></table></figure>

<p>建一个List数组，然后对每一个List元素，进行new ArrayList&lt;&gt;()</p>
<p>dfs返回以参数root为根的树的节点个数，但同时利用全局变量计算分数。若两次统计，会超时（先计算最大分数，再统计个数会超时）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(List&lt;Integer&gt;[] children,<span class="hljs-type">int</span> n,<span class="hljs-type">int</span> id)</span>&#123;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">score</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i&lt;children[id].size();++i)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> dfs(children,n,children[id].get(i));<br>            sum += t;<br>            score *= t;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(id!=<span class="hljs-number">0</span>) score*=(n-sum);<br>        <span class="hljs-keyword">if</span>(maxScore==score)&#123;<br>            count++;<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(maxScore&lt;score)&#123;<br>            maxScore = score;<br>            count=<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> sum;<br>    &#125;<br></code></pre></td></tr></table></figure>



<p>那种深度优先遍历的题目，List里面嵌套List，记得res.add(path) 这样写是<strong>不对</strong>的，因为path后续修改时，也会修改res中的值，因为add的是引用。所以应当这样写：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">res.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(path));<br></code></pre></td></tr></table></figure>



<h2 id="3-12"><a href="#3-12" class="headerlink" title="3&#x2F;12"></a>3&#x2F;12</h2><h3 id="注意-1"><a href="#注意-1" class="headerlink" title="注意"></a>注意</h3><p>在写dfs的时候，要在一开始就写used[i]&#x3D;true。一开始访问到就要把used数组置为true</p>
<h3 id="使用dfs求连通分量的个数"><a href="#使用dfs求连通分量的个数" class="headerlink" title="使用dfs求连通分量的个数"></a>使用dfs求连通分量的个数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">makeConnected</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span>[][] connections)</span> &#123;<br>        <span class="hljs-comment">//1.求边的条数m，m&lt;n-1   -1</span><br>        <span class="hljs-comment">//2.求连通分量的个数 mnum  然后-1</span><br>        <span class="hljs-keyword">if</span>(connections.length&lt;n-<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        List&lt;Integer&gt;[] link = <span class="hljs-keyword">new</span> <span class="hljs-title class_">List</span>[n];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i&lt;n;++i)&#123;<br>            link[i] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span>[] con:connections)&#123;<br>            link[con[<span class="hljs-number">0</span>]].add(con[<span class="hljs-number">1</span>]);<br>            link[con[<span class="hljs-number">1</span>]].add(con[<span class="hljs-number">0</span>]);<br>        &#125;<span class="hljs-comment">//建图完成</span><br>        <span class="hljs-type">boolean</span>[] used = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[n];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i&lt;n;++i)&#123;<br>            <span class="hljs-keyword">if</span>(!used[i])&#123;<br>                dfs(i,used,link);<br>                ans++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans-<span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> i,<span class="hljs-type">boolean</span>[] used,List&lt;Integer&gt;[] link)</span>&#123;<br>        used[i] = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">for</span>(Integer j:link[i])&#123;<br>            <span class="hljs-keyword">if</span>(!used[j])&#123;<br>                dfs(j,used,link);<br>            &#125;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure>



<h3 id="求最大连通分量"><a href="#求最大连通分量" class="headerlink" title="求最大连通分量"></a>求最大连通分量</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">makeConnected</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span>[][] connections)</span> &#123;<br>    <span class="hljs-comment">//1.求边的条数m，m&lt;n-1   -1</span><br>    <span class="hljs-keyword">if</span>(connections.length&lt;n-<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    List&lt;Integer&gt;[] link = <span class="hljs-keyword">new</span> <span class="hljs-title class_">List</span>[n];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i&lt;n;++i)&#123;<br>        link[i] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span>[] con:connections)&#123;<br>        link[con[<span class="hljs-number">0</span>]].add(con[<span class="hljs-number">1</span>]);<br>        link[con[<span class="hljs-number">1</span>]].add(con[<span class="hljs-number">0</span>]);<br>    &#125;<span class="hljs-comment">//建图完成</span><br>    <span class="hljs-type">boolean</span>[] used = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[n];<br>    <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i&lt;n;++i)&#123;<br>        <span class="hljs-keyword">if</span>(!used[i])&#123;<br>            ans = Math.max(dfs(i,used,link),ans);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br><span class="hljs-type">int</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> i,<span class="hljs-type">boolean</span>[] used,List&lt;Integer&gt;[] link)</span>&#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>    used[i] = <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">for</span>(Integer j:link[i])&#123;<br>        <span class="hljs-keyword">if</span>(!used[j])&#123;<br>            t+=dfs(j,used,link);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> t;<br>&#125;<br></code></pre></td></tr></table></figure>



<p>判断从start到target有没有通路，注意注意</p>
<p>dfs中不能直接返回</p>
<h3 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h3><p>使用并查集统计有多少个连通分量：统计有多少个<strong>祖先</strong> $fa[i]&#x3D;&#x3D;i$</p>
<p>并查集实现注意点：为了避免出现二叉搜索树中的退化问题，要做到下面两点：</p>
<ol>
<li>对于每棵树，记录这棵树的高度rank。</li>
<li>合并时如果两棵树的rank不同，则从rank小的向rank大的连边。</li>
</ol>
<h4 id="路径压缩"><a href="#路径压缩" class="headerlink" title="路径压缩"></a>路径压缩</h4><p>对于每个节点，一旦向上走到了一次根节点，就把这个点到父亲的边改为直接连向根。</p>
<p>在此之上，不仅仅是所查询的节点，在查询过程中向上经过的所有的节点，都改为直接连到根上。这样再次查询这些节点时，就可以很快知道是谁了。</p>
<p>在使用这种简化方法时，为了简单起见，即使树的高度发生了变化，我们也不修改rank的值。</p>
<h3 id="并查集的实现"><a href="#并查集的实现" class="headerlink" title="并查集的实现"></a>并查集的实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> par[MAX_N]; <span class="hljs-comment">// 父亲</span><br><span class="hljs-type">int</span> rank[MAX_N]; <span class="hljs-comment">// 树的高度</span><br><span class="hljs-comment">//初始化n个元素</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i&lt;n;++i)&#123;<br>        par[i] = i;<br>        rank[i] = <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 查询树的根</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(par[x]==x) <span class="hljs-keyword">return</span> x;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> par[x]=<span class="hljs-built_in">find</span>(par[x]);<br>&#125;<br><br><span class="hljs-comment">// 合并x和y所属的集合</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">unite</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span></span>&#123;<br>    x = <span class="hljs-built_in">find</span>(x);<br>    y = <span class="hljs-built_in">find</span>(y);<br>    <span class="hljs-keyword">if</span>(x==y) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-keyword">if</span>(rank[x]&lt;rank[y])&#123;<br>        par[x] = y;<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        par[y] = x;<br>        <span class="hljs-keyword">if</span>(rank[x]==rank[y]) rank[x]++;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 判断x和y是否属于同一个集合</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">same</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">find</span>(x)==<span class="hljs-built_in">find</span>(y);<br>&#125;<br></code></pre></td></tr></table></figure>







<h2 id="3-13"><a href="#3-13" class="headerlink" title="3&#x2F;13"></a>3&#x2F;13</h2><h3 id="迪杰斯特拉算法-最短路"><a href="#迪杰斯特拉算法-最短路" class="headerlink" title="迪杰斯特拉算法 最短路"></a>迪杰斯特拉算法 最短路</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">networkDelayTime</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] times, <span class="hljs-type">int</span> n, <span class="hljs-type">int</span> k)</span> &#123;<br>        List&lt;<span class="hljs-type">int</span>[]&gt;[] link = <span class="hljs-keyword">new</span> <span class="hljs-title class_">List</span>[n+<span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;i&lt;=n;++i)&#123;<br>            link[i] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        &#125;<br>        <span class="hljs-type">int</span>[] dist = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n+<span class="hljs-number">1</span>];<br>        Arrays.fill(dist,Integer.MAX_VALUE);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span>[] time:times)&#123;<br>            link[time[<span class="hljs-number">0</span>]].add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;time[<span class="hljs-number">1</span>],time[<span class="hljs-number">2</span>]&#125;);<br>        &#125;<br>        <span class="hljs-type">boolean</span>[] used = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[n+<span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i&lt;link[k].size();++i)&#123;<br>            dist[link[k].get(i)[<span class="hljs-number">0</span>]] = link[k].get(i)[<span class="hljs-number">1</span>];<br>        &#125;<br>        used[k] = <span class="hljs-literal">true</span>;<br>        dist[<span class="hljs-number">0</span>] = -<span class="hljs-number">1</span>;<br>        dist[k] = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i&lt;n-<span class="hljs-number">1</span>;++i)&#123;<span class="hljs-comment">//在S-V集合中进行n-1次搜索</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> Integer.MAX_VALUE;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> k;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;j&lt;=n;++j)<span class="hljs-comment">//寻找本轮循环中dist数组中的最小值</span><br>                <span class="hljs-keyword">if</span>(!used[j] &amp;&amp; dist[j]&lt;temp)&#123;<br>                    temp = dist[j];<span class="hljs-comment">//最小值是多少</span><br>                    t = j;<span class="hljs-comment">//第几个节点</span><br>                &#125;<br>            <span class="hljs-keyword">if</span>(t==k) <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>            used[t] = <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;j&lt;link[t].size();++j)&#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">to</span> <span class="hljs-operator">=</span> link[t].get(j)[<span class="hljs-number">0</span>];<br>                <span class="hljs-type">int</span> <span class="hljs-variable">w</span> <span class="hljs-operator">=</span> link[t].get(j)[<span class="hljs-number">1</span>];<br>                <span class="hljs-keyword">if</span>(!used[to] &amp;&amp; dist[to]&gt;dist[t]+w)&#123;<br>                    dist[to] = dist[t]+w;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> Arrays.stream(dist).max().getAsInt();<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>堆优化的dijkstra</p>
<p>注意要有used数组来标识，否则会无限入堆，会超时</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java">    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span>[] Dijkstra(List&lt;Integer&gt;[] list,<span class="hljs-type">int</span> n)&#123;<br>        <span class="hljs-type">boolean</span>[] used = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[n];<br>        <span class="hljs-type">int</span>[] dist = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        Arrays.fill(dist,INF);<br>        dist[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>        Queue&lt;<span class="hljs-type">int</span>[]&gt; que = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;&gt;((o1,o2)-&gt;o1[<span class="hljs-number">0</span>]-o2[<span class="hljs-number">0</span>]);<br>        que.offer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;dist[<span class="hljs-number">0</span>],<span class="hljs-number">0</span>&#125;);<br>        <span class="hljs-keyword">while</span>(!que.isEmpty())&#123;<br>            <span class="hljs-type">int</span>[] info = que.poll();<br>            <span class="hljs-type">int</span> <span class="hljs-variable">from</span> <span class="hljs-operator">=</span> info[<span class="hljs-number">1</span>];<br>            <span class="hljs-type">int</span> <span class="hljs-variable">cost</span> <span class="hljs-operator">=</span> info[<span class="hljs-number">0</span>];<br>            <span class="hljs-keyword">if</span>(used[from]) <span class="hljs-keyword">continue</span>;<br>            used[from] = <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">for</span>(Integer l:list[from])&#123;<br>                dist[l] = Math.min(dist[l],dist[from]+<span class="hljs-number">1</span>);<span class="hljs-comment">// 这里不推荐这样写 最好写cost+1，因为在求第二短的路径中这样写是错误的，而cost那样写就是对的</span><br>                que.offer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;dist[l],l&#125;);<span class="hljs-comment">// 可以写一个if，只有更新时才入队，这样就可以不必使用used数组   </span><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dist;<br>    &#125;<br>		<br><br><span class="hljs-comment">// 创建一个数组存储最短路径上，每一个节点的前一个节点的编号。可利用此数组求出源点到任意一个节点的具体最短路径</span><br><span class="hljs-comment">// k是源点</span><br>        <span class="hljs-type">int</span>[] p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n+<span class="hljs-number">1</span>];<br>        Arrays.fill(p,-<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i&lt;list[k].size();++i)&#123;<br>            <span class="hljs-type">int</span>[] info = list[k].get(i);<br>            p[info[<span class="hljs-number">0</span>]] = k;<br>        &#125;<br><br><span class="hljs-comment">// 下面就是求源点与某一个节点具体最短路径的步骤。注意k是源点，pre是终点</span><br>        <span class="hljs-type">int</span>[] stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n+<span class="hljs-number">1</span>];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">top</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">pre</span> <span class="hljs-operator">=</span> target;<br>        <span class="hljs-keyword">if</span>(pre!=k) stack[top++]=pre;<br>        <span class="hljs-keyword">while</span>(p[pre]!=-<span class="hljs-number">1</span> &amp;&amp; p[pre]!=k)&#123;<br>            stack[top++] = p[pre];<br>            pre = p[pre];<br>        &#125;<br>        stack[top++]=k;<br>        <span class="hljs-keyword">while</span>(top&gt;<span class="hljs-number">0</span>)&#123;<br>            System.out.println(stack[--top]);<br>        &#125;<br></code></pre></td></tr></table></figure>



<h2 id="3-18"><a href="#3-18" class="headerlink" title="3&#x2F;18"></a>3&#x2F;18</h2><h3 id="存图方式"><a href="#存图方式" class="headerlink" title="存图方式"></a>存图方式</h3><h4 id="邻接矩阵"><a href="#邻接矩阵" class="headerlink" title="邻接矩阵"></a>邻接矩阵</h4><p>适用于边数较多的<strong>稠密图</strong>使用，当边数量接近点的数量的平方，即 m \approx n^2<em>m</em>≈<em>n</em>2 时，可定义为<strong>稠密图</strong>。</p>
<h3 id="邻接表"><a href="#邻接表" class="headerlink" title="邻接表"></a>邻接表</h3><p><strong>链式前向星存图</strong></p>
<p>适用于边数较少的<strong>稀疏图</strong>使用，当边数量接近点的数量，即 m \approx n<em>m</em>≈<em>n</em> 时，可定义为<strong>稀疏图</strong>。</p>
<h3 id="类（边集数组）"><a href="#类（边集数组）" class="headerlink" title="类（边集数组）"></a>类（边集数组）</h3><p>Bellman-Ford算法使用，当然，该算法也可以使用邻接矩阵</p>
<h3 id="0x3f3f3f3f"><a href="#0x3f3f3f3f" class="headerlink" title="0x3f3f3f3f"></a>0x3f3f3f3f</h3><p>当作无穷大，很好用，无穷大加无穷大还是无穷大，并不会溢出</p>
<p>最后，0x3f3f3f3f还能给我们带来一个意想不到的额外好处：<br>如果我们想要将某个数组清零，我们通常会使用memset(a,0,sizeof(a))，方便又高效，但是当我们想将某个数组全部赋值为无穷大时，就不能使用memset函数而得自己写循环了，因为memset是按字节操作的，它能够对数组清零是因为0的每个字节都是0（一般我们只有赋值为-1和0的时候才使用它）。现在好了，如果我们将无穷大设为0x3f3f3f3f，那么奇迹就发生了，0x3f3f3f3f的每个字节都是0x3f！所以要把一段内存全部置为无穷大，我们只需要memset(a,0x3f,sizeof(a))。</p>
<h2 id="3-19"><a href="#3-19" class="headerlink" title="3&#x2F;19"></a>3&#x2F;19</h2><h3 id="链式前向星"><a href="#链式前向星" class="headerlink" title="链式前向星"></a>链式前向星</h3><p>有向图</p>
<p><img src="E:/Download/qq/mpFile/1020018707/Image/Group2/@2/KR/@2KRSGV6HC2%5BZ61RPPI5%7DY5.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>无向图</p>
<p><img src="E:/Download/qq/mpFile/1020018707/Image/Group2/KK/7J/KK7J737S%5DT%7D7_XFOJSBOS3I.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">read</span><span class="hljs-params">()</span>&#123;<br>        n = s.nextInt();<span class="hljs-comment">//节点数</span><br>        m = s.nextInt();<span class="hljs-comment">//边数</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= m; i++) &#123;<span class="hljs-comment">//边的编号从1开始</span><br>            <span class="hljs-comment">//head[node]是以node为起点的第一条边的编号</span><br>            <span class="hljs-comment">//next[edge]是和edge同起点的下一条边的编号</span><br>            <span class="hljs-comment">//to[edge]是编号为edge的这条边的终点</span><br>            <span class="hljs-comment">//还可以加一个weighe[edge]表示边权</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">f</span> <span class="hljs-operator">=</span> s.nextInt();<br>            <span class="hljs-type">int</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> s.nextInt();<br>            next[<span class="hljs-number">2</span> * i] = head[f];<br>            to[<span class="hljs-number">2</span> * i] = t;<br>            head[f] = <span class="hljs-number">2</span> * i;<br><br>            next[<span class="hljs-number">2</span> * i + <span class="hljs-number">1</span>] = head[t];<br>            to[<span class="hljs-number">2</span> * i + <span class="hljs-number">1</span>] = f;<br>            head[t] = <span class="hljs-number">2</span> * i + <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br><br><br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">read</span><span class="hljs-params">()</span>&#123;<br>        n = s.nextInt();<span class="hljs-comment">//节点数</span><br>        m = s.nextInt();<span class="hljs-comment">//边数</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= m; i++) &#123;<span class="hljs-comment">//边的编号从1开始</span><br>            <span class="hljs-comment">//head[node]是以node为起点的第一条边的编号</span><br>            <span class="hljs-comment">//next[edge]是和edge同起点的下一条边的编号</span><br>            <span class="hljs-comment">//to[edge]是编号为edge的这条边的终点</span><br>            <span class="hljs-comment">//还可以加一个weighe[edge]表示边权</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">f</span> <span class="hljs-operator">=</span> s.nextInt();<br>            <span class="hljs-type">int</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> s.nextInt();<br>            next[<span class="hljs-number">2</span> * i] = head[f];<br>            to[<span class="hljs-number">2</span> * i] = t;<br>            head[f] = <span class="hljs-number">2</span> * i;<br><br>            next[<span class="hljs-number">2</span> * i + <span class="hljs-number">1</span>] = head[t];<br>            to[<span class="hljs-number">2</span> * i + <span class="hljs-number">1</span>] = f;<br>            head[t] = <span class="hljs-number">2</span> * i + <span class="hljs-number">1</span>;<br>        &#125;<br>        <br>        <span class="hljs-comment">//用的话就是</span><br>        <span class="hljs-comment">//for(int p = head[x]; p != 0; p = next[p])&#123;</span><br>        <span class="hljs-comment">//    dfs(to[p]);</span><br>        <span class="hljs-comment">//&#125;</span><br>    &#125;<br><br></code></pre></td></tr></table></figure>



<h2 id="3-20"><a href="#3-20" class="headerlink" title="3&#x2F;20"></a>3&#x2F;20</h2><h3 id="pair"><a href="#pair" class="headerlink" title="pair"></a>pair</h3><p>因为pair重写了equals方法，往堆里放的话还要重写compareTo</p>
<p><img src="https://cdn.jsdelivr.net/gh/dutsc/cloud-image/blog-img/202312052037784.png" srcset="/img/loading.gif" lazyload alt="https://gitee.com/dutsc/cloud-images/raw/master/images/202212041129879.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/dutsc/cloud-image/blog-img/202312052038427.png" srcset="/img/loading.gif" lazyload></p>
<p>这样写得到的是小顶堆</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">E</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Comparable</span>&lt;E&gt;&#123;<br>    <span class="hljs-type">int</span> x, y, z;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">E</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b, <span class="hljs-type">int</span> c)</span>&#123;<br>        x = a; y = b; z = c;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compareTo</span><span class="hljs-params">(E e)</span>&#123;<br>        <span class="hljs-keyword">if</span>(x &lt; e.x) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(x &gt; e.x) <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">if</span>(y == e.y) <span class="hljs-keyword">return</span> z - e.z;<br>            <span class="hljs-keyword">return</span> y - e.y;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hashCode</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> y*<span class="hljs-number">1000000</span> + z;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hashCode</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> Objects.hash(y,z);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">equals</span><span class="hljs-params">(Object obj)</span>&#123;<br>        <span class="hljs-keyword">if</span>(obj == <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-type">E</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> (E)obj;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">this</span>.y == e.y &amp;&amp; <span class="hljs-built_in">this</span>.z == e.z)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;E(&quot;</span>+x+<span class="hljs-string">&quot;,&quot;</span>+y+<span class="hljs-string">&quot;,&quot;</span>+z+<span class="hljs-string">&quot;)&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/dutsc/cloud-image/blog-img/202312052038456.png" srcset="/img/loading.gif" lazyload></p>
<p>学习一下Idea中hashCode的写法</p>
<h3 id="扁平化"><a href="#扁平化" class="headerlink" title="扁平化"></a>扁平化</h3><p>一般三个的数据可以把它变成两个，如a,b,w    坐标(a,b) 和权重w</p>
<p><strong>结合数据范围，进行扁平化   把a,b变成1000*a+b这样的</strong>     也可以考虑变成字符串，然后再split</p>
<h4 id="二维矩阵编号"><a href="#二维矩阵编号" class="headerlink" title="二维矩阵编号"></a>二维矩阵编号</h4><p>二维矩阵中，将矩阵中的每一个单元格按顺序进行编号的方法：</p>
<p>这是一个通用的二维矩阵使用转为顺序编号的做法 </p>
<p>记住对于 row * col 的矩阵，任意的点 (i,j) 可以使用 i * col + j 转化为顺序编码 idx （等价于从上往下 从左到右编号）</p>
<p>反过来将 idx 恢复成 (i,j) 表示只需要 (idx &#x2F; col, idx % col) 即可</p>
<h3 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h3><p>放到HashMap  key部分的元素，和放到HashSet部分的元素，需要同时重写hashCode()和equals()方法</p>
<h2 id="3-22"><a href="#3-22" class="headerlink" title="3&#x2F;22"></a>3&#x2F;22</h2><h3 id="dp与图论"><a href="#dp与图论" class="headerlink" title="dp与图论"></a>dp与图论</h3><p>只有拓扑图的图论问题，才能使用dp求解，若不是拓扑图，则只能使用图论的方法求解。</p>
<h3 id="bfs超时问题"><a href="#bfs超时问题" class="headerlink" title="bfs超时问题"></a>bfs超时问题</h3><p>使用bfs时，注意used数组何时置为true很重要。</p>
<p>入队时把节点置为true  而不要出队时（也不一定）</p>
<h3 id="dfs回溯问题"><a href="#dfs回溯问题" class="headerlink" title="dfs回溯问题"></a>dfs回溯问题</h3><p>如果是纯粹的回溯问题，一定要确保每一步都要回溯，容易忘记回溯的几个地方</p>
<ol>
<li><p>sb.deleteCharAt(sb,length()-1);</p>
</li>
<li><p>used[x] [y] &#x3D; true<br>…….</p>
<p>used[x] [y] &#x3D; false</p>
</li>
</ol>
<p>如果是字符二维数组，则要确定是否访问过，并不需要多开一个used数组，直接把该位置的字符置成一个没有出现过的字符即可。</p>
<h2 id="3-23"><a href="#3-23" class="headerlink" title="3&#x2F;23"></a>3&#x2F;23</h2><h3 id="回溯时最容易忘记的部分"><a href="#回溯时最容易忘记的部分" class="headerlink" title="回溯时最容易忘记的部分"></a>回溯时最容易忘记的部分</h3><p>used数组是最容易忘记回溯的部分</p>
<h3 id="矩阵快速幂-1"><a href="#矩阵快速幂-1" class="headerlink" title="矩阵快速幂"></a>矩阵快速幂</h3><h4 id="可以用于求解数列递推问题"><a href="#可以用于求解数列递推问题" class="headerlink" title="可以用于求解数列递推问题"></a>可以用于求解数列递推问题</h4><p>矩阵快速幂用于求解一般性问题：给定大小为 n * n 的矩阵 M，求答案矩阵 M^k<br> ，并对答案矩阵中的每位元素对 PP取模。</p>
<p>在上述两种解法中，当我们要求解 f[i] 时，需要将 f[0] 到 f[n−1] 都算一遍，因此需要线性的复杂度。</p>
<p>对于此类的「数列递推」问题，我们可以使用「矩阵快速幂」来进行加速（比如要递归一个长度为 1e9 的数列，线性复杂度会被卡）。</p>
<p>使用矩阵快速幂，我们只需要 O(\log{n}) 的复杂度。</p>
<h4 id="矩阵乘法"><a href="#矩阵乘法" class="headerlink" title="矩阵乘法"></a>矩阵乘法</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">100</span>;<br> <br><span class="hljs-type">int</span> c[N][N];<br> <br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">multi</span><span class="hljs-params">(<span class="hljs-type">int</span> a[][N],<span class="hljs-type">int</span> b[][N],<span class="hljs-type">int</span> n)</span><span class="hljs-comment">//n是矩阵大小，n&lt;N</span></span><br><span class="hljs-function"> </span><br><span class="hljs-function"></span>&#123;<br> <br><span class="hljs-built_in">memset</span>(c,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span> c);<br> <br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br> <br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;j++)<br> <br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">1</span>;k&lt;=n;k++)<br> <br>c[i][j]+=a[i][k]*b[k][j];<br> <br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="字节常考"><a href="#字节常考" class="headerlink" title="字节常考"></a>字节常考</h3><ol start="25">
<li><p>K 个一组翻转链表</p>
</li>
<li><p>接雨水 </p>
</li>
<li><p>合并K个排序链表 </p>
</li>
<li><p>缺失的第一个正数 124. 二叉树中的最大路径和 76. 最小覆盖子串 32. 最长有效括号 72. 编辑距离 4. 寻找两个正序数组的中位数 239. 滑动窗口最大值 字节hard top10欢迎你</p>
</li>
</ol>
<h2 id="3-24"><a href="#3-24" class="headerlink" title="3&#x2F;24"></a>3&#x2F;24</h2><h3 id="难以处理的边界问题"><a href="#难以处理的边界问题" class="headerlink" title="难以处理的边界问题"></a>难以处理的边界问题</h3><p>遇到难以处理的边界问题时，要灵活运用max(i-1,0)  和 min(i+1,m-1)  进行处理，而不是无谓地写很多if语句判断</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[][] imageSmoother(<span class="hljs-type">int</span>[][] img) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> img.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> img[<span class="hljs-number">0</span>].length;<br>        <span class="hljs-type">int</span>[][] temp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[m][n];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i&lt;m;++i)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;j&lt;n;++j)&#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> Math.max(i-<span class="hljs-number">1</span>,<span class="hljs-number">0</span>);<br>                <span class="hljs-type">int</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> Math.min(m-<span class="hljs-number">1</span>,i+<span class="hljs-number">1</span>);<br>                <span class="hljs-type">int</span> <span class="hljs-variable">up</span> <span class="hljs-operator">=</span> Math.max(j-<span class="hljs-number">1</span>,<span class="hljs-number">0</span>);<br>                <span class="hljs-type">int</span> <span class="hljs-variable">down</span> <span class="hljs-operator">=</span> Math.min(j+<span class="hljs-number">1</span>,n-<span class="hljs-number">1</span>);<br>                <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> l;x&lt;=r;++x)&#123;<br>                    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">y</span> <span class="hljs-operator">=</span> up;y&lt;=down;++y)&#123;<br>                        num++;<br>                        ans+=img[x][y];<br>                    &#125;<br>                &#125;<br>                temp[i][j] = ans/num;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> temp;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>周赛那个k近邻也是一样</p>
<h3 id="字典序"><a href="#字典序" class="headerlink" title="字典序"></a>字典序</h3><p>数字的字典序，就是根据数字的前缀进行排序</p>
<h2 id="3-25"><a href="#3-25" class="headerlink" title="3&#x2F;25"></a>3&#x2F;25</h2><h3 id="字符串去重"><a href="#字符串去重" class="headerlink" title="字符串去重"></a>字符串去重</h3><p>遇到字符串去重问题时，考虑统计以每一个字符结尾的长度最长的符合要求的字符串的数量，最后再加起来</p>
<h2 id="3-30"><a href="#3-30" class="headerlink" title="3&#x2F;30"></a>3&#x2F;30</h2><h3 id="乘积最大子数组"><a href="#乘积最大子数组" class="headerlink" title="乘积最大子数组"></a>乘积最大子数组</h3><p><img src="https://cdn.jsdelivr.net/gh/dutsc/cloud-image/blog-img/202312052038901.png" srcset="/img/loading.gif" lazyload></p>
<h3 id="数据范围问题"><a href="#数据范围问题" class="headerlink" title="数据范围问题"></a>数据范围问题</h3><p><img src="https://cdn.jsdelivr.net/gh/dutsc/cloud-image/blog-img/202312052038019.png" srcset="/img/loading.gif" lazyload alt="https://gitee.com/dutsc/cloud-images/raw/master/images/202212041130517.png"> </p>
<p>注意这样的条件，若开静态数组，则要开10^6 范围的，因为可能会有99999的测试用例</p>
<h2 id="4-1"><a href="#4-1" class="headerlink" title="4&#x2F;1"></a>4&#x2F;1</h2><p>若一个数组中的元素全都出现两次，只有一个元素出现一次，那么用异或运算即可求出单独的那一个.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> &amp;x:nums)&#123;<br>    res^=x;<br>&#125;<br><span class="hljs-keyword">return</span> res;<br></code></pre></td></tr></table></figure>

<p>注意，这里使用&amp;效率提升很大。</p>
<h2 id="4-3"><a href="#4-3" class="headerlink" title="4&#x2F;3"></a>4&#x2F;3</h2><h3 id="卡特兰数"><a href="#卡特兰数" class="headerlink" title="卡特兰数"></a>卡特兰数</h3><p>$C_0 &#x3D; 1$        $C_{n+1} &#x3D; \frac{2(2n+1)}{n+2} C_n$</p>
 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">long</span> <span class="hljs-type">long</span> C = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i&lt;n;++i)&#123;<br>    C = C*<span class="hljs-number">2</span>*(<span class="hljs-number">2</span>*i+<span class="hljs-number">1</span>)/(i+<span class="hljs-number">2</span>);<br>&#125;<br><span class="hljs-keyword">return</span> C;<br></code></pre></td></tr></table></figure>

<p>例子1：凸n+2边形用其n-1条对角线把此凸n+2边形分割为互不重叠的三角形，有多少种方法？</p>
<p>例子2：圆周上共有2n个点，这2n个点配对可连成n条弦，且这些弦两两不相交的方式数有多少种？</p>
<p>例子3：在2n个顺序摆放的盒子中填充n个白球和n个黑球，要求任取前m个盒子，其中黑球数目不少于白球？</p>
<p>​	变形：找钱问题：所有商品都是五角，但又n个人手里拿1块钱，n个人手里拿5角钱，如何给这n个人排序，使得不会出现找不开钱的情况（店家一开始钱为0）</p>
<p><img src="https://cdn.jsdelivr.net/gh/dutsc/cloud-image/blog-img/202312052038868.png" srcset="/img/loading.gif" lazyload alt="https://gitee.com/dutsc/cloud-images/raw/master/images/202212041130362.png"></p>
<p>例子4：给定n个实数x1,x2,…,xn的一个排列，在不改变数字顺序的前提下，只通过添加括号改变运算顺序，共有多少种方法？</p>
<p><img src="https://cdn.jsdelivr.net/gh/dutsc/cloud-image/blog-img/202312052039704.png" srcset="/img/loading.gif" lazyload alt="https://gitee.com/dutsc/cloud-images/raw/master/images/202212041131287.png"></p>
<h2 id="4-5"><a href="#4-5" class="headerlink" title="4&#x2F;5"></a>4&#x2F;5</h2><h3 id="线段树板子2"><a href="#线段树板子2" class="headerlink" title="线段树板子2"></a>线段树板子2</h3><p>给区间内的每个数都乘以K，使用两个懒标记</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//</span><br><span class="hljs-comment">// Created by s&#x27;c on 2022/4/5.</span><br><span class="hljs-comment">//</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;iostream&quot;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MAX = <span class="hljs-number">1000010</span>;<br><span class="hljs-type">int</span> mod;<br>ll nums[MAX];<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span>&#123;<br>    <span class="hljs-type">int</span> l;<br>    <span class="hljs-type">int</span> r;<br>    ll add;<br>    ll mul;<br>    ll sum;<br>&#125;;<br>node tree[MAX&lt;&lt;<span class="hljs-number">2</span>];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pushup</span><span class="hljs-params">(<span class="hljs-type">int</span> node)</span></span>&#123;<br>    tree[node].sum = (tree[node&lt;&lt;<span class="hljs-number">1</span>].sum + tree[node&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>].sum)%mod;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">build</span><span class="hljs-params">(<span class="hljs-type">int</span> node, <span class="hljs-type">int</span> L,<span class="hljs-type">int</span> R)</span></span>&#123;<br>    tree[node].l = L;<br>    tree[node].r = R;<br>    tree[node].mul = <span class="hljs-number">1</span>;<br>    tree[node].add = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span>(L==R)&#123;<br>        tree[node].sum = nums[L]%mod;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-type">int</span> mid = ((R-L)&gt;&gt;<span class="hljs-number">1</span>)+L;<br>    <span class="hljs-built_in">build</span>(node&lt;&lt;<span class="hljs-number">1</span>,L,mid);<br>    <span class="hljs-built_in">build</span>(node&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>,mid+<span class="hljs-number">1</span>,R);<br>    <span class="hljs-built_in">pushup</span>(node);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pushdown</span><span class="hljs-params">(<span class="hljs-type">int</span> node)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(tree[node].mul!=<span class="hljs-number">1</span>)&#123;<br>        tree[node&lt;&lt;<span class="hljs-number">1</span>].mul = (tree[node&lt;&lt;<span class="hljs-number">1</span>].mul * tree[node].mul)%mod;<br>        tree[node&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>].mul = (tree[node&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>].mul * tree[node].mul)%mod;<br>        tree[node&lt;&lt;<span class="hljs-number">1</span>].add = (tree[node&lt;&lt;<span class="hljs-number">1</span>].add * tree[node].mul)%mod;<br>        tree[node&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>].add = (tree[node&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>].add * tree[node].mul)%mod;<br>        tree[node&lt;&lt;<span class="hljs-number">1</span>].sum = (tree[node&lt;&lt;<span class="hljs-number">1</span>].sum * tree[node].mul)%mod;<br>        tree[node&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>].sum = (tree[node&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>].sum * tree[node].mul)%mod;<br>        tree[node].mul = <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(tree[node].add)&#123;<br>        tree[node&lt;&lt;<span class="hljs-number">1</span>].add = (tree[node&lt;&lt;<span class="hljs-number">1</span>].add + tree[node].add)%mod;<br>        tree[node&lt;&lt;<span class="hljs-number">1</span>].sum = (tree[node&lt;&lt;<span class="hljs-number">1</span>].sum + tree[node].add*(tree[node&lt;&lt;<span class="hljs-number">1</span>].r-tree[node&lt;&lt;<span class="hljs-number">1</span>].l+<span class="hljs-number">1</span>)%mod)%mod;<br>        tree[node&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>].add = (tree[node&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>].add + tree[node].add)%mod;<br>        tree[node&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>].sum = (tree[node&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>].sum + tree[node].add*(tree[node&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>].r-tree[node&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>].l+<span class="hljs-number">1</span>)%mod)%mod;<br>        tree[node].add = <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">update</span><span class="hljs-params">(<span class="hljs-type">int</span> node,<span class="hljs-type">int</span> L,<span class="hljs-type">int</span> R,ll v1,ll v2)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(L&lt;=tree[node].l &amp;&amp; R&gt;=tree[node].r)&#123;<br>        <span class="hljs-comment">// v1产生的影响</span><br>        tree[node].mul = (tree[node].mul * v1)%mod;<br>        tree[node].add = (tree[node].add * v1)%mod;<br>        tree[node].sum = (tree[node].sum * v1)%mod;<br><br>        <span class="hljs-comment">//v2产生的影响</span><br>        tree[node].add = (tree[node].add + v2)%mod;<br>        tree[node].sum = (tree[node].sum + v2*(tree[node].r-tree[node].l+<span class="hljs-number">1</span>)%mod)%mod;<br>        <span class="hljs-keyword">return</span> ;<br>    &#125;<br>    <span class="hljs-type">int</span> mid = ((tree[node].r-tree[node].l)&gt;&gt;<span class="hljs-number">1</span>)+tree[node].l;<br>    <span class="hljs-built_in">pushdown</span>(node);<br>    <span class="hljs-keyword">if</span>(L&lt;=mid) <span class="hljs-built_in">update</span>(node&lt;&lt;<span class="hljs-number">1</span>,L,R,v1,v2);<br>    <span class="hljs-keyword">if</span>(R&gt;mid) <span class="hljs-built_in">update</span>(node&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>,L,R,v1,v2);<br>    <span class="hljs-built_in">pushup</span>(node);<br>&#125;<br><br><span class="hljs-function">ll <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> node,<span class="hljs-type">int</span> L,<span class="hljs-type">int</span> R)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(R&lt;tree[node].l || L&gt;tree[node].r) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span>(L&lt;=tree[node].l &amp;&amp; R&gt;=tree[node].r) <span class="hljs-keyword">return</span> tree[node].sum;<br>    <span class="hljs-type">int</span> mid = ((tree[node].r-tree[node].l)&gt;&gt;<span class="hljs-number">1</span>)+tree[node].l;<br>    <span class="hljs-built_in">pushdown</span>(node);<br>    ll res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span>(L&lt;=mid) res = (res + <span class="hljs-built_in">query</span>(node&lt;&lt;<span class="hljs-number">1</span>,L,R))%mod;<br>    <span class="hljs-keyword">if</span>(R&gt;mid) res = (res + <span class="hljs-built_in">query</span>(node&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>,L,R))%mod;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> n,m,p;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>,&amp;n,&amp;m,&amp;p);<br>    mod = p;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i&lt;n;++i)&#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%ld&quot;</span>,&amp;nums[i]);<br>    &#125;<br>    <span class="hljs-built_in">build</span>(<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,n<span class="hljs-number">-1</span>);<br>    <span class="hljs-keyword">while</span>(m--&gt;<span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-type">int</span> tt;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;tt);<br>        <span class="hljs-keyword">if</span>(tt==<span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-comment">// mul</span><br>            <span class="hljs-type">int</span> x,y;<br>            ll k;<br>            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%ld&quot;</span>,&amp;x,&amp;y,&amp;k);<br>            <span class="hljs-built_in">update</span>(<span class="hljs-number">1</span>,x<span class="hljs-number">-1</span>,y<span class="hljs-number">-1</span>,k,<span class="hljs-number">0</span>);<span class="hljs-comment">// 先乘后加</span><br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(tt==<span class="hljs-number">2</span>)&#123;<br>            <span class="hljs-comment">// add</span><br>            <span class="hljs-type">int</span> x,y;<br>            ll k;<br>            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%ld&quot;</span>,&amp;x,&amp;y,&amp;k);<br>            <span class="hljs-built_in">update</span>(<span class="hljs-number">1</span>,x<span class="hljs-number">-1</span>,y<span class="hljs-number">-1</span>,<span class="hljs-number">1</span>,k);<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(tt==<span class="hljs-number">3</span>)&#123;<br>            <span class="hljs-comment">// sum</span><br>            <span class="hljs-type">int</span> x,y;<br>            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;x,&amp;y);<br>            <span class="hljs-type">long</span> t = <span class="hljs-built_in">query</span>(<span class="hljs-number">1</span>,x<span class="hljs-number">-1</span>,y<span class="hljs-number">-1</span>);<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%ld\n&quot;</span>,t);<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>



<h3 id="注意-2"><a href="#注意-2" class="headerlink" title="注意"></a>注意</h3><p>这个代码第一次写有两个地方出现错误</p>
<ol>
<li>tree[node].mul 要在build时进行初始化，不然编译器会自动初始化为0.这不是我们想要的。<strong>要手动初始化为1</strong>.</li>
<li>每一个步骤都要检查  node &lt;&lt; 1    还是  node &lt;&lt; 1|1，还是  node   想好了再去写，写完要检查一遍。</li>
<li>在build中对结构体数组中的变量进行初始化是一个好习惯。包括java中对对象数组的初始化，一定要进行。</li>
</ol>
<h3 id="埃氏筛法求质数"><a href="#埃氏筛法求质数" class="headerlink" title="埃氏筛法求质数"></a>埃氏筛法求质数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">countPrimes</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span>[] isSu = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        Arrays.fill(isSu,<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;i&lt;n;++i)&#123;<br>            <span class="hljs-keyword">if</span>(isSu[i]==<span class="hljs-number">1</span>)&#123;<br>                res++;<br>                <span class="hljs-keyword">if</span>((<span class="hljs-type">long</span>)i*i&lt;n)&#123;<br>                    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i*i;j&lt;n;j+=i)&#123;<br>                        isSu[j] = <span class="hljs-number">0</span>;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h2 id="4-6"><a href="#4-6" class="headerlink" title="4&#x2F;6"></a>4&#x2F;6</h2><h3 id="两次扫描与换根法"><a href="#两次扫描与换根法" class="headerlink" title="两次扫描与换根法"></a>两次扫描与换根法</h3><blockquote>
<p>树形dp的应用</p>
</blockquote>
<p>对于某种需要以每个节点为根进行一次DFS的题目，可以使用两次DFS扫描与换根法解决，实际上是利用递推式来一次求解的。</p>
<h3 id="parseInt与valueOf的区别"><a href="#parseInt与valueOf的区别" class="headerlink" title="parseInt与valueOf的区别"></a>parseInt与valueOf的区别</h3><ol>
<li><p>返回值不同<br>parseInt 返回值是int型<br>valueof  返回值是Integer型</p>
</li>
<li><p>valueof就是调用了parseInt方法的</p>
</li>
<li><p>parseInt效率比valueof效率高</p>
</li>
</ol>
<h3 id="ACM模式的Java输入"><a href="#ACM模式的Java输入" class="headerlink" title="ACM模式的Java输入"></a>ACM模式的Java输入</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">import</span> java.io.*;<br><span class="hljs-keyword">import</span> java.util.*;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Main&#123;<br>    <span class="hljs-keyword">public</span> statci <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException&#123;<br>        <span class="hljs-type">BufferedReader</span> <span class="hljs-variable">br</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InputStreamReader</span>(System.in));<br>        String[] tt = br.readLine().split(<span class="hljs-string">&quot; +&quot;</span>);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> tt.length;<br>        <span class="hljs-type">int</span>[] ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i&lt;n;++i)&#123;<br>            ans[i] = Integer.parseInt(tt[i]);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h4 id="java输入二维数组，"><a href="#java输入二维数组，" class="headerlink" title="java输入二维数组，"></a>java输入二维数组，</h4><p>记得抛出IOException异常</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// java输入二维数组</span><br>		<span class="hljs-type">BufferedReader</span> <span class="hljs-variable">br</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InputStreamReader</span>(System.in));<br>		<span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> Integer.parseInt(br.readLine());<br>		<span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i&lt;m;++i) &#123;<br>			String[] tt = br.readLine().split(<span class="hljs-string">&quot; +&quot;</span>);<br>			n = tt.length;<br>			<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;j&lt;n;++j) &#123;<br>				ans[i][j] = Integer.parseInt(tt[j]);<br>			&#125;<br>		&#125;<br>		br.close();<br></code></pre></td></tr></table></figure>





<h3 id="java之ACM注意点"><a href="#java之ACM注意点" class="headerlink" title="java之ACM注意点"></a>java之ACM注意点</h3><h2 id="Java输入输出基本操作"><a href="#Java输入输出基本操作" class="headerlink" title="Java输入输出基本操作"></a>Java输入输出基本操作</h2><h3 id="Java之ACM注意点"><a href="#Java之ACM注意点" class="headerlink" title="Java之ACM注意点"></a>Java之ACM注意点</h3><p>\1. 类名称必须采用public class Main方式命名</p>
<p>\2. 在有多行数据输入的情况下，一般这样处理：</p>
<p>static Scanner in &#x3D; new Scanner(System.in);</p>
<p>while(in.hasNextInt())</p>
<p>或者是</p>
<p>while(in.hasNext())</p>
<p>\3. 有关System.nanoTime()函数的使用，该函数用来返回最准确的可用系统计时器的当前值，以毫微秒为单位。</p>
<p>  long startTime &#x3D; System.nanoTime();</p>
<p>  &#x2F;&#x2F; … the code being measured …</p>
<p>  long estimatedTime &#x3D; System.nanoTime() - startTime;</p>
<h3 id="Java之输入输出处理"><a href="#Java之输入输出处理" class="headerlink" title="Java之输入输出处理"></a>Java之输入输出处理</h3><h5 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h5><p>格式1：Scanner sc &#x3D; new Scanner (new BufferedInputStream(System.in));</p>
<p>格式2：Scanner sc &#x3D; new Scanner (System.in);</p>
<p>在读入数据量大的情况下，格式1的速度会快些。</p>
<p>读一个整数： int n &#x3D; sc.nextInt(); 相当于 scanf(“%d”, &amp;n); 或 cin &gt;&gt; n; </p>
<p>读一个字符串：String s &#x3D; sc.next(); 相当于 scanf(“%s”, s); 或 cin &gt;&gt; s; </p>
<p>读一个浮点数：double t &#x3D; sc.nextDouble(); 相当于 scanf(“%lf”, &amp;t); 或 cin &gt;&gt; t; </p>
<p>读一整行： String s &#x3D; sc.nextLine(); 相当于 gets(s); 或 cin.getline(…); </p>
<p>判断是否有下一个输入可以用sc.hasNext()或sc.hasNextInt()或sc.hasNextDouble()或sc.hasNextLine()</p>
<p>例1：读入整数</p>
<p>Input 输入数据有多组，每组占一行，由一个整数组成。</p>
<p>Sample Input</p>
<p>56</p>
<p>67</p>
<p>100</p>
<p>123</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Scanner;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">Scanner</span> <span class="hljs-variable">sc</span> <span class="hljs-operator">=</span><span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>    <span class="hljs-keyword">while</span>(sc.hasNext())&#123; <span class="hljs-comment">//判断是否结束</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">score</span> <span class="hljs-operator">=</span> sc.nextInt();<span class="hljs-comment">//读入整数</span><br>    …………<br>   &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>例2：读入实数</p>
<p>输入数据有多组，每组占2行，第一行为一个整数N，指示第二行包含N个实数。</p>
<p>Sample Input</p>
<p>4</p>
<p>56.9 67.7 90.5 12.8</p>
<p>5</p>
<p>56.9 67.7 90.5 12.8</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Scanner;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">Scanner</span> <span class="hljs-variable">sc</span> <span class="hljs-operator">=</span><span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>    <span class="hljs-keyword">while</span>(sc.hasNext())&#123;<br>      <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> sc.nextInt();<br>      <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        <span class="hljs-type">double</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> sc.nextDouble();<br>        ……………<br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>例3：读入字符串【杭电2017 字符串统计】</p>
<p>输入数据有多行，第一行是一个整数n，表示测试实例的个数，后面跟着n行，每行包括一个由字母和数字组成的字符串。</p>
<p>Sample Input</p>
<p>2</p>
<p>asdfasdf123123asdfasdf</p>
<p>asdf111111111asdfasdfasdf</p>
<p>import java.util.Scanner;</p>
<p>public class Main {</p>
<p>public static void main(String[] args) {</p>
<p>​    Scanner sc &#x3D; new Scanner(System.in);</p>
<p>​    int n &#x3D; sc.nextInt();</p>
<p>​    for(int i&#x3D;0;i&lt;n;i++){</p>
<p>​      String str &#x3D; sc.next();</p>
<p>​      ……</p>
<p>​    }</p>
<p>  }</p>
<p>}</p>
<p>import java.util.Scanner;</p>
<p>public class Main {</p>
<p>public static void main(String[] args) {</p>
<p>​    Scanner sc &#x3D; new Scanner(System.in);</p>
<p>​    int n &#x3D; Integer.parseInt(sc.nextLine());</p>
<p>​    for(int i&#x3D;0;i&lt;n;i++){</p>
<p>​      String str &#x3D; sc.nextLine();</p>
<p>​      ……</p>
<p>​    }</p>
<p>  }</p>
<p>}</p>
<h5 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h5><p>函数：</p>
<p>System.out.print(); </p>
<p>System.out.println(); </p>
<p>System.out.format();</p>
<p>System.out.printf(); </p>
<p>例4 杭电1170Balloon Comes!</p>
<p>Give you an operator (+,-,*, &#x2F; –denoting addition, subtraction, multiplication, division respectively) and two positive integers, your task is to output the result. </p>
<p>Input</p>
<p>Input contains multiple test cases. The first line of the input is a single integer T (0&lt;T&lt;1000) which is the number of test cases. T test cases follow. Each test case contains a char C (+,-,*, &#x2F;) and two integers A and B(0&lt;A,B&lt;10000).Of course, we all know that A and B are operands and C is an operator. </p>
<p>Output</p>
<p>For each case, print the operation result. The result should be rounded to 2 decimal places If and only if it is not an integer.</p>
<p>Sample Input</p>
<p>4</p>
<p>+ 1 2</p>
<p>- 1 2</p>
<p>* 1 2</p>
<p>&#x2F; 1 2</p>
<p>Sample Output</p>
<p>3</p>
<p>-1</p>
<p>2</p>
<p>0.50</p>
<p>import java.util.Scanner;</p>
<p>public class Main {</p>
<p>public static void main(String[] args) {</p>
<p>​    Scanner sc &#x3D;new Scanner(System.in);</p>
<p>​    int n &#x3D; sc.nextInt();</p>
<p>​    for(int i&#x3D;0;i&lt;n;i++){</p>
<p>​      String op &#x3D; sc.next();</p>
<p>​      int a &#x3D; sc.nextInt();</p>
<p>​      int b &#x3D; sc.nextInt();</p>
<p>​      if(op.charAt(0)&#x3D;&#x3D;’+’){</p>
<p>​        System.out.println(a+b);</p>
<p>​      }else if(op.charAt(0)&#x3D;&#x3D;’-‘){</p>
<p>​        System.out.println(a-b);</p>
<p>​      }else if(op.charAt(0)&#x3D;&#x3D;’*’){</p>
<p>​        System.out.println(a*b);</p>
<p>​      }else if(op.charAt(0)&#x3D;&#x3D;’&#x2F;‘){</p>
<p>​      if(a % b &#x3D;&#x3D; 0) System.out.println(a &#x2F; b);</p>
<p>​      else System.out.format(“%.2f”, (a &#x2F; (1.0*b))). Println();</p>
<p>​      }</p>
<p>​    }</p>
<p>   }</p>
<p>}</p>
<h5 id="格式化的输出"><a href="#格式化的输出" class="headerlink" title="格式化的输出"></a>格式化的输出</h5><p>函数：</p>
<p>&#x2F;&#x2F; 这里0指一位数字，#指除0以外的数字(如果是0，则不显示),四舍五入.</p>
<p>  DecimalFormat fd &#x3D; new DecimalFormat(“#.00#”);</p>
<p>  DecimalFormat gd &#x3D; new DecimalFormat(“0.000”);</p>
<p>  System.out.println(“x &#x3D;” + fd.format(x));</p>
<p>  System.out.println(“x &#x3D;” + gd.format(x));</p>
<p>public static void main(String[] args) {</p>
<p>NumberFormat formatter &#x3D; new DecimalFormat( “000000”);</p>
<p>String s &#x3D; formatter.format(-1234.567); &#x2F;&#x2F; -001235</p>
<p>System.out.println(s);</p>
<p>formatter &#x3D; new DecimalFormat( “##”);</p>
<p>s &#x3D; formatter.format(-1234.567); &#x2F;&#x2F; -1235</p>
<p>System.out.println(s);</p>
<p>s &#x3D; formatter.format(0); &#x2F;&#x2F; 0</p>
<p>System.out.println(s);</p>
<p>formatter &#x3D; new DecimalFormat( “##00”);</p>
<p>s &#x3D; formatter.format(0); &#x2F;&#x2F; 00</p>
<p>System.out.println(s);</p>
<p>formatter &#x3D; new DecimalFormat( “.00”);</p>
<p>s &#x3D; formatter.format(-.567); &#x2F;&#x2F; -.57</p>
<p>System.out.println(s);</p>
<p>formatter &#x3D; new DecimalFormat( “0.00”);</p>
<p>s &#x3D; formatter.format(-.567); &#x2F;&#x2F; -0.57</p>
<p>System.out.println(s);</p>
<p>formatter &#x3D; new DecimalFormat( “#.#”);</p>
<p>s &#x3D; formatter.format(-1234.567); &#x2F;&#x2F; -1234.6</p>
<p>System.out.println(s);</p>
<p>formatter &#x3D; new DecimalFormat( “#.######”);</p>
<p>s &#x3D; formatter.format(-1234.567); &#x2F;&#x2F; -1234.567</p>
<p>System.out.println(s);</p>
<p>formatter &#x3D; new DecimalFormat( “.######”);</p>
<p>s &#x3D; formatter.format(-1234.567); &#x2F;&#x2F; -1234.567</p>
<p>System.out.println(s);</p>
<p>formatter &#x3D; new DecimalFormat( “#.000000”);</p>
<p>s &#x3D; formatter.format(-1234.567); &#x2F;&#x2F; -1234.567000</p>
<p>System.out.println(s);</p>
<p>formatter &#x3D; new DecimalFormat( “#,###,###”);</p>
<p>s &#x3D; formatter.format(-1234.567); &#x2F;&#x2F; -1,235</p>
<p>System.out.println(s);</p>
<p>s &#x3D; formatter.format(-1234567.890); &#x2F;&#x2F; -1,234,568</p>
<p>System.out.println(s);</p>
<p>&#x2F;&#x2F; The ; symbol is used to specify an alternate pattern for negative values</p>
<p>formatter &#x3D; new DecimalFormat( “#;(#) “);</p>
<p>s &#x3D; formatter.format(-1234.567); &#x2F;&#x2F; (1235)</p>
<p>System.out.println(s);</p>
<p>&#x2F;&#x2F; The ‘ symbol is used to quote literal symbols</p>
<p>formatter &#x3D; new DecimalFormat( “ ‘# ‘# “);</p>
<p>s &#x3D; formatter.format(-1234.567); &#x2F;&#x2F; -#1235</p>
<p>System.out.println(s);</p>
<p>formatter &#x3D; new DecimalFormat( “ ‘abc ‘# “);</p>
<p>s &#x3D; formatter.format(-1234.567); &#x2F;&#x2F; - abc 1235</p>
<p>System.out.println(s);</p>
<p>formatter &#x3D; new DecimalFormat( “#.##%”);</p>
<p>s &#x3D; formatter.format(-12.5678987);</p>
<p>System.out.println(s);</p>
<p>}</p>
<h5 id="字符串处理String"><a href="#字符串处理String" class="headerlink" title="字符串处理String"></a>字符串处理String</h5><p>String 类用来存储字符串，可以用charAt方法来取出其中某一字节，计数从0开始： </p>
<p>String a &#x3D; “Hello”; &#x2F;&#x2F; a.charAt(1) &#x3D; ‘e’ </p>
<p>用substring方法可得到子串，如上例 </p>
<p>System.out.println(a.substring(0, 4)) &#x2F;&#x2F; output “Hell” </p>
<p>注意第2个参数位置上的字符不包括进来。这样做使得 s.substring(a, b) 总是有 b-a个字符。 </p>
<p>字符串连接可以直接用 + 号，如 </p>
<p>String a &#x3D; “Hello”; </p>
<p>String b &#x3D; “world”; </p>
<p>System.out.println(a + “, “ + b + “!”); &#x2F;&#x2F; output “Hello, world!” </p>
<p>如想直接将字符串中的某字节改变，可以使用另外的StringBuffer类。 </p>
<h5 id="高精度"><a href="#高精度" class="headerlink" title="高精度"></a>高精度</h5><p>BigInteger和BigDecimal可以说是acmer选择java的首要原因。</p>
<p>函数：add, subtract, divide, mod, compareTo等，其中加减乘除模都要求是BigInteger(BigDecimal)和BigInteger(BigDecimal)之间的运算，所以需要把int(double)类型转换为BigInteger(BigDecimal)，用函数BigInteger.valueOf().</p>
<p>import java.io.BufferedInputStream;</p>
<p>import java.math.BigInteger;</p>
<p>import java.util.Scanner;</p>
<p>public class Main {</p>
<p>public static void main(String[] args) {</p>
<p>Scanner cin &#x3D; new Scanner (new BufferedInputStream(System.in));</p>
<p>int a &#x3D; 123, b &#x3D; 456, c &#x3D; 7890;</p>
<p>BigInteger x, y, z, ans;</p>
<p>x &#x3D; BigInteger.valueOf(a);</p>
<p>y &#x3D; BigInteger.valueOf(b);</p>
<p>z &#x3D; BigInteger.valueOf(c);</p>
<p>ans &#x3D; x.add(y); System.out.println(ans);</p>
<p>ans &#x3D; z.divide(y); System.out.println(ans);</p>
<p>ans &#x3D; x.mod(z); System.out.println(ans);</p>
<p>if (ans.compareTo(x) &#x3D;&#x3D; 0) System.out.println(“1”);</p>
<p>}</p>
<p>}</p>
<h5 id="进制转化"><a href="#进制转化" class="headerlink" title="进制转化"></a>进制转化</h5><p>String st &#x3D; Integer.toString(num, base); &#x2F;&#x2F; 把num当做10进制的数转成base进制的st(base &lt;&#x3D; 35).</p>
<p>int num &#x3D; Integer.parseInt(st, base); &#x2F;&#x2F; 把st当做base进制，转成10进制的int(parseInt有两个参数,第一个为要转的字符串,第二个为说明是什么进制). </p>
<p>BigInter m &#x3D; new BigInteger(st, base); &#x2F;&#x2F; st是字符串，base是st的进制.</p>
<h3 id="进制转换"><a href="#进制转换" class="headerlink" title="进制转换"></a>进制转换</h3><p>使用Integer.toString(ta,base)函数将int类型的ta转换成base进制的String</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">BufferedReader</span> <span class="hljs-variable">br</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InputStreamReader</span>(System.in));<br><span class="hljs-type">String</span> <span class="hljs-variable">tt</span> <span class="hljs-operator">=</span> br.readLine();<br><span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> Integer.parseInt(tt);<br><span class="hljs-type">String</span> <span class="hljs-variable">ta</span> <span class="hljs-operator">=</span> Integer.toString(a,<span class="hljs-number">2</span>);<br>System.out.println(ta);<br></code></pre></td></tr></table></figure>

<p>使用Integer.parseInt(ta,base) 将String类型，base进制的ta转换成10进制的int</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">BufferedReader</span> <span class="hljs-variable">br</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InputStreamReader</span>(System.in));<br><span class="hljs-type">String</span> <span class="hljs-variable">tt</span> <span class="hljs-operator">=</span> br.readLine();<br><span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> Integer.parseInt(tt,<span class="hljs-number">2</span>);<br>System.out.println(a);<br></code></pre></td></tr></table></figure>



<h2 id="4-7"><a href="#4-7" class="headerlink" title="4&#x2F;7"></a>4&#x2F;7</h2><h3 id="求一个数的所有不重复的因子"><a href="#求一个数的所有不重复的因子" class="headerlink" title="求一个数的所有不重复的因子"></a>求一个数的所有不重复的因子</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Scanner</span> <span class="hljs-variable">sc</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br><span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> sc.nextInt();<br>List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>Set&lt;Integer&gt; set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedHashSet</span>&lt;&gt;();<br><span class="hljs-type">double</span> <span class="hljs-variable">sq</span> <span class="hljs-operator">=</span> Math.sqrt(n);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;i&lt;=sq;++i)&#123;<br>    <span class="hljs-keyword">if</span>(n%i==<span class="hljs-number">0</span>)&#123;<br>        set.add(i);<br>        set.add(n/i);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">for</span>(Integer i:set)&#123;<br>    System.out.print(i+<span class="hljs-string">&quot; &quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>



<h2 id="4-8"><a href="#4-8" class="headerlink" title="4&#x2F;8"></a>4&#x2F;8</h2><h3 id="多数去重的思路"><a href="#多数去重的思路" class="headerlink" title="多数去重的思路"></a>多数去重的思路</h3><p>多个数字组成的整体（如int[2]，最简分数去重等等），常规的去重思路</p>
<p>找一个基数，这个基数比最大的数据范围还要大，使用如下形式将其放入数组中存储（若数据量大就放入哈希表存储）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-comment">// 假设a，b数据的最大范围是[0-25]</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">getIndex</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">30</span>*a+b;<br>&#125;<br><span class="hljs-type">int</span>[] ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">30</span>*<span class="hljs-number">30</span>+<span class="hljs-number">30</span>];<br></code></pre></td></tr></table></figure>

<p>这样，只要a不变，任凭b怎么变化，getIndex得到的值都会不一样，就达到了去重的目的。</p>
<p>同理，若是有abc三个数，则去重的基数就要再加一个</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-type">int</span> <span class="hljs-title function_">getIndex</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b,<span class="hljs-type">int</span> c)</span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">30</span> * <span class="hljs-number">30</span> * a + <span class="hljs-number">30</span> * b + c;<br>&#125;<br><span class="hljs-type">int</span>[] ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">30</span>*<span class="hljs-number">30</span>*<span class="hljs-number">30</span>+<span class="hljs-number">30</span>*<span class="hljs-number">30</span>+<span class="hljs-number">30</span>];<br></code></pre></td></tr></table></figure>





<h2 id="4-11"><a href="#4-11" class="headerlink" title="4&#x2F;11"></a>4&#x2F;11</h2><h3 id="查找相邻元素"><a href="#查找相邻元素" class="headerlink" title="查找相邻元素"></a>查找相邻元素</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">adjacent_find</span>(iterator beg, iterator end);<br><span class="hljs-comment">// 查找相邻重复元素,返回相邻元素的第一个位置的迭代器</span><br>    vector&lt;<span class="hljs-type">int</span>&gt; a;<br>    a.<span class="hljs-built_in">emplace_back</span>(<span class="hljs-number">1</span>);<br>    a.<span class="hljs-built_in">emplace_back</span>(<span class="hljs-number">5</span>);<br>    a.<span class="hljs-built_in">emplace_back</span>(<span class="hljs-number">6</span>);<br>    a.<span class="hljs-built_in">emplace_back</span>(<span class="hljs-number">2</span>);<br>    a.<span class="hljs-built_in">emplace_back</span>(<span class="hljs-number">9</span>);<br>    a.<span class="hljs-built_in">emplace_back</span>(<span class="hljs-number">3</span>);<br>    vector&lt;<span class="hljs-type">int</span>&gt;::iterator it = <span class="hljs-built_in">adjacent_find</span>(a.<span class="hljs-built_in">begin</span>(),a.<span class="hljs-built_in">end</span>());<br>    <span class="hljs-keyword">if</span>(it!=a.<span class="hljs-built_in">end</span>())&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;找到了&quot;</span> &lt;&lt; endl;<br>    &#125;<span class="hljs-keyword">else</span> &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;没找到&quot;</span> &lt;&lt; endl;<br>    &#125;<br>    cout &lt;&lt; *it &lt;&lt; endl;<br></code></pre></td></tr></table></figure>





<h2 id="4-12"><a href="#4-12" class="headerlink" title="4&#x2F;12"></a>4&#x2F;12</h2><h3 id="寻找第k个缺失的数"><a href="#寻找第k个缺失的数" class="headerlink" title="寻找第k个缺失的数"></a>寻找第k个缺失的数</h3><p>找到一个严格升序排列的正整数组中第k个缺失的正整数。</p>
<p>我们发现截至到每一个位置，缺失的正整数的数量  是非递减的，于是可以考虑使用二分法，但要注意边界情况的处理。</p>
<h3 id="二分法找某一个值"><a href="#二分法找某一个值" class="headerlink" title="二分法找某一个值"></a>二分法找某一个值</h3><p>使用二分法找某一个符合条件的值时，要先求，然后再验证是否符合条件。因为求的是yyynnn   或者 nnnyyy类型的，可能边界值不符合题目条件。</p>
<h3 id="c-字符串越界"><a href="#c-字符串越界" class="headerlink" title="c++字符串越界"></a>c++字符串越界</h3><p>越界之后不会报错，而是取到一个’&#x2F;0’字符</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++">    string s = <span class="hljs-string">&quot;123&quot;</span>;<br>    cout &lt;&lt; (<span class="hljs-type">int</span>)s[<span class="hljs-number">6</span>] &lt;&lt; endl;<br>    <span class="hljs-type">int</span> a = <span class="hljs-string">&#x27; &#x27;</span>;<br>    cout &lt;&lt;  a &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><span class="hljs-comment">//0  </span><br><span class="hljs-comment">// 32</span><br></code></pre></td></tr></table></figure>



<h3 id="拆分正整数为几个数的和，使其乘积最大"><a href="#拆分正整数为几个数的和，使其乘积最大" class="headerlink" title="拆分正整数为几个数的和，使其乘积最大"></a>拆分正整数为几个数的和，使其乘积最大</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">if</span>(n&lt;=<span class="hljs-number">3</span>) <span class="hljs-keyword">return</span> n<span class="hljs-number">-1</span>;<br><span class="hljs-type">int</span> x = n/<span class="hljs-number">3</span>,y = n%<span class="hljs-number">3</span>;<br><span class="hljs-keyword">if</span>(y==<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-built_in">pow</span>(<span class="hljs-number">3</span>,x);<br><span class="hljs-keyword">if</span>(y==<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-built_in">pow</span>(<span class="hljs-number">3</span>,x<span class="hljs-number">-1</span>)*<span class="hljs-number">4</span>;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">pow</span>(<span class="hljs-number">3</span>,x)*<span class="hljs-number">2</span>;<br></code></pre></td></tr></table></figure>





<h2 id="4-13"><a href="#4-13" class="headerlink" title="4&#x2F;13"></a>4&#x2F;13</h2><h3 id="线段树暴力求解"><a href="#线段树暴力求解" class="headerlink" title="线段树暴力求解"></a>线段树暴力求解</h3><p>线段树中的暴力问题，如对$a_i$ 连续取模，可以在$loga_i$复杂度之内实现，故可以暴力求解</p>
<p>$x % p &lt; \frac{x}{2}$   $p&lt;x$  </p>
<p>第一次写，问题：</p>
<ol>
<li>build中当l&#x3D;&#x3D;r 时没有写return ;</li>
<li>区间暴力取模，要到了单点的时候再取模，即tr[node].r&#x3D;&#x3D;tr[node].l时</li>
<li>所有update  modify的最后一步一定是pushup，而不是return。一定要向上回溯</li>
<li>update单点更新到叶子节点时，不论该节点的lr是不是k，都要return了，注意要把return写在k if的外面。</li>
</ol>
<h2 id="4-14"><a href="#4-14" class="headerlink" title="4&#x2F;14"></a>4&#x2F;14</h2><p><a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E6%AC%A7%E6%8B%89%E5%87%BD%E6%95%B0&spm=1001.2101.3001.7020">欧拉函数</a>就是指:<strong>给定一个n，求得1到n中与n互质的数的个数</strong></p>
<p>1.如果n,m互质，那么 : φ(n*m) &#x3D; φ(n)*φ(m)</p>
<p>2.如果n为质数，那么 : φ(n) &#x3D; n-1，可推出1中φ(n * m) &#x3D; (n-1)*(m-1)</p>
<p>3.如果n % m &#x3D;&#x3D; 0，那么 : φ(n * m) &#x3D; m * φ(n)</p>
<p>4.在3的基础上 : if(n % m &#x3D;&#x3D; 0 &amp;&amp; φ(n &#x2F; m)%m &#x3D;&#x3D; 0) φ(n) &#x3D; φ(n&#x2F;m)*m</p>
<p>5.在3的基础上 : if(n % m &#x3D;&#x3D; 0 &amp;&amp; φ(n &#x2F; m)%m !&#x3D; 0) φ(n) &#x3D; φ(n&#x2F;m)*(m-1)</p>
<p>6.当n为奇数时，φ(n) &#x3D; φ(2*n)</p>
<p>7.与小于等于n中，与n互质的数之和为:φ(n)*n&#x2F;2</p>
<h3 id="dfs"><a href="#dfs" class="headerlink" title="dfs"></a>dfs</h3><h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><p>给定一个序列，一个数k，问是否能从序列中找到若干个数，使得其和为k，序列中的数只能使用一次</p>
<p><a target="_blank" rel="noopener" href="https://www.papamelon.com/problem/201">https://www.papamelon.com/problem/201</a></p>
<h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><p>本题是一个子集树问题（选或不选2^n），与之类似的还有排列树问题（每次少一个，n!），n叉树问题（n^n），代码结构如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">dfs</span>(<span class="hljs-type">int</span> i)&#123;<br>  <span class="hljs-comment">//1 输出结果</span><br>  <span class="hljs-keyword">if</span>(i==n) <span class="hljs-built_in">printf</span>();<br>  <br>  <span class="hljs-comment">//2 剪枝</span><br>  <br>  <span class="hljs-comment">//3 遍历下一层</span><br>  <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;j&lt;k;++j)&#123; <span class="hljs-comment">// 子集树</span><br>  <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = i;j&lt;=n;++j&#123; <span class="hljs-comment">// 排列树</span><br>  <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;j&lt;n;++j&#123;  <span class="hljs-comment">// n叉树</span><br>    <span class="hljs-built_in">dfs</span>(i+<span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>第一份超时代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 超时</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;iostream&quot;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span>  <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br>ll arr[<span class="hljs-number">21</span>]=&#123;<span class="hljs-number">0</span>&#125;;<br><span class="hljs-type">bool</span> used[<span class="hljs-number">21</span>]=&#123;<span class="hljs-number">0</span>&#125;;<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">dfs</span><span class="hljs-params">(ll* arr,<span class="hljs-type">int</span> k,<span class="hljs-type">int</span> now,<span class="hljs-type">int</span> n)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(now==k) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i&lt;=n;++i)&#123;<br>        <span class="hljs-keyword">if</span>(!used[i])&#123;<br>            used[i] = <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">dfs</span>(arr,k,now+arr[i],n)) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            used[i] = <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;n)!=EOF)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i&lt;=n;++i)&#123;<br>            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld&quot;</span>,&amp;arr[i]);<br>        &#125;<br>        ll k;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld&quot;</span>,&amp;k);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i&lt;<span class="hljs-number">21</span>;++i)&#123;<br>            used[i] = <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">dfs</span>(arr,k,<span class="hljs-number">0</span>,n)) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Yes\n&quot;</span>);<br>        <span class="hljs-keyword">else</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;No\n&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>


<p>很容易写出本题代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;iostream&quot;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br>ll a[<span class="hljs-number">21</span>]=&#123;<span class="hljs-number">0</span>&#125;;<br><span class="hljs-type">int</span> n;<br>ll k;<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> i,<span class="hljs-type">int</span> sum)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(i==n) <span class="hljs-keyword">return</span> sum==k;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">dfs</span>(i+<span class="hljs-number">1</span>,sum))&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;没取%lld &quot;</span>,a[i]);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">dfs</span>(i+<span class="hljs-number">1</span>,sum+a[i]))&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;取了%lld &quot;</span>,a[i]);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;n)!=EOF)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i&lt;n;++i)&#123;<br>            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld&quot;</span>,&amp;a[i]);<br>        &#125;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld&quot;</span>,&amp;k);<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">dfs</span>(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>)) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Yes\n&quot;</span>);<br>        <span class="hljs-keyword">else</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;No\n&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p>这里我也给出输出全排列的代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;iostream&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;vector&quot;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br>vector&lt;<span class="hljs-type">int</span>&gt; b;<br><span class="hljs-type">int</span> id = <span class="hljs-number">0</span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; arr,<span class="hljs-type">int</span> i,<span class="hljs-type">int</span> n,vector&lt;<span class="hljs-type">bool</span>&gt;&amp; used)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(i==n)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;j&lt;n;++j)&#123;<br>            cout &lt;&lt; b[j] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>        &#125;<br>        id++;<br>        cout &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;j&lt;n;++j)&#123;<br>        <span class="hljs-keyword">if</span>(!used[j])&#123;<br>            used[j] = <span class="hljs-literal">true</span>;<br>            b.<span class="hljs-built_in">emplace_back</span>(arr[j]);<br>            <span class="hljs-built_in">dfs</span>(arr,i+<span class="hljs-number">1</span>,n,used);<br>            b.<span class="hljs-built_in">pop_back</span>();<br>            used[j] = <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">arr</span><span class="hljs-params">(<span class="hljs-number">6</span>,<span class="hljs-number">0</span>)</span></span>;<br>    <span class="hljs-type">int</span> n = arr.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i&lt;n;++i)&#123;<br>        arr[i] = i+<span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">used</span><span class="hljs-params">(n,<span class="hljs-number">0</span>)</span></span>;<br>    <span class="hljs-built_in">dfs</span>(arr,<span class="hljs-number">0</span>,n,used);<br>    cout &lt;&lt; <span class="hljs-string">&quot;id=&quot;</span> &lt;&lt; id &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>





<h3 id="贪心"><a href="#贪心" class="headerlink" title="贪心"></a>贪心</h3><p>n项工作，每项工作si开始，ti结束，每次只能同时参与一项工作，问最多参与多少个工作？</p>
<h4 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h4><p>在可选的工作中，每次都选取结束时间最早的工作，可以实现参与最多的工作。、</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//</span><br><span class="hljs-comment">// Created by s&#x27;c on 2022/4/14.</span><br><span class="hljs-comment">//</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;iostream&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;algorithm&quot;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MAX = <span class="hljs-number">100010</span>;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br>ll s[MAX];<br>ll t[MAX];<br><br><span class="hljs-type">int</span> n;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    pair&lt;ll,ll&gt; pp[MAX];<br>    <span class="hljs-keyword">while</span>(<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;n)!=EOF)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i&lt;n;++i)&#123;<br>            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld&quot;</span>,&amp;s[i]);<br>            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld&quot;</span>,&amp;t[i]);<br>            pp[i].first = t[i];<br>            pp[i].second = s[i];<br>        &#125;<br>        <span class="hljs-built_in">sort</span>(pp,pp+n);<br>        <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>        ll last = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i&lt;n;++i)&#123;<br>            <span class="hljs-keyword">if</span>(last&lt;pp[i].second)&#123;<br>                res++;<br>                last = pp[i].first;<br>            &#125;<br>        &#125;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,res);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>





<h3 id="priority-queue的pair自定义排序"><a href="#priority-queue的pair自定义排序" class="headerlink" title="priority_queue的pair自定义排序"></a>priority_queue的pair自定义排序</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">cmp</span>&#123;<br>        <span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> U&gt;</span><br><span class="hljs-function">        <span class="hljs-type">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(T <span class="hljs-type">const</span>&amp; left, U <span class="hljs-type">const</span> &amp;right)</span> </span>&#123;<br>            <span class="hljs-keyword">if</span> (left.second &lt; right.second) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;;<br>...<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; mp;<br>    mp[<span class="hljs-number">3</span>]=<span class="hljs-number">4</span>;<br>    mp[<span class="hljs-number">2</span>]=<span class="hljs-number">44</span>;<br>    mp[<span class="hljs-number">12</span>]=<span class="hljs-number">432</span>;<br>    priority_queue&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;, vector&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt;, cmp&gt;  <span class="hljs-built_in">pq</span>(mp.<span class="hljs-built_in">begin</span>(), mp.<span class="hljs-built_in">end</span>());<span class="hljs-comment">//完成pq的初始化</span><br>&#125;<br></code></pre></td></tr></table></figure>



<p>cmp中，&gt;表示降序</p>
<h4 id="另外几种常用的"><a href="#另外几种常用的" class="headerlink" title="另外几种常用的"></a>另外几种常用的</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++">priority_queue&lt; <span class="hljs-type">int</span> &gt; q;<span class="hljs-comment">// 默认是 从大到小。 </span><br>priority_queue &lt; <span class="hljs-type">int</span> , vector&lt;<span class="hljs-type">int</span>&gt; ,less&lt;<span class="hljs-type">int</span>&gt; &gt; q;<span class="hljs-comment">//从大到小 </span><br>priority_queue &lt; <span class="hljs-type">int</span> , vector&lt;<span class="hljs-type">int</span>&gt;, greater&lt;<span class="hljs-type">int</span>&gt; &gt; q; <span class="hljs-comment">//从小到大，需要vector</span><br>priority_queue &lt; <span class="hljs-type">int</span> , vector&lt;<span class="hljs-type">int</span>&gt; , cmp1  &gt; q;<span class="hljs-comment">//从大到小，需要vector</span><br>priority_queue &lt; <span class="hljs-type">int</span> , vector&lt;<span class="hljs-type">int</span>&gt; , cmp  &gt; q;<span class="hljs-comment">//从小到大，需要vector</span><br></code></pre></td></tr></table></figure>





<h3 id="离散化"><a href="#离散化" class="headerlink" title="离散化"></a>离散化</h3><p>1 2 5000 900000 </p>
<p>变成 0 1 2 3 </p>
<p>只表示相对大小，而不用来表示数值大小</p>
<p>函数lower_bound()在first和last中的<strong>前闭后开</strong>区间进行二分查找，返回大于或等于val的<strong>第一个元素</strong>位置。如果所有元素都小于val，则返回<strong>last</strong>的位置</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//</span><br><span class="hljs-comment">// Created by s&#x27;c on 2022/4/13.</span><br><span class="hljs-comment">//</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;iostream&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;cstring&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;algorithm&quot;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> A[<span class="hljs-number">10010</span>]=&#123;<span class="hljs-number">0</span>&#125;;<br><span class="hljs-type">int</span> B[<span class="hljs-number">10010</span>]=&#123;<span class="hljs-number">0</span>&#125;;<br><span class="hljs-type">int</span> f[<span class="hljs-number">2</span>][<span class="hljs-number">10010</span>]=&#123;<span class="hljs-number">0</span>&#125;;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> INF = <span class="hljs-number">0x3f3f3f3f</span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> n = <span class="hljs-number">6</span>;<br>    <span class="hljs-type">int</span> a[]=&#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">900</span>,<span class="hljs-number">50000</span>,<span class="hljs-number">6000000</span>,<span class="hljs-number">90000000</span>&#125;;<br>    <span class="hljs-type">int</span> te[<span class="hljs-number">7</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br>    <span class="hljs-type">int</span> ls[<span class="hljs-number">7</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;a[i]);<br>        te[i]=a[i];<br>    &#125;<br>    <span class="hljs-built_in">sort</span>(te+<span class="hljs-number">1</span>,te+n+<span class="hljs-number">1</span>);<br>    <span class="hljs-type">int</span> size=<span class="hljs-built_in">unique</span>(te+<span class="hljs-number">1</span>,te+n+<span class="hljs-number">1</span>)-te<span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        ls[i]=<span class="hljs-built_in">lower_bound</span>(te+<span class="hljs-number">1</span>,te+size+<span class="hljs-number">1</span>,a[i])-te<span class="hljs-number">-1</span>;<br>        cout &lt;&lt; ls[i] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="包含unique函数的用法"><a href="#包含unique函数的用法" class="headerlink" title="包含unique函数的用法"></a>包含unique函数的用法</h4><p>使用之前必须先排序，unique返回一个迭代器，它指向不重复的最后一个数据的下标。</p>
<p>一般不常用，只在离散化中用到，但是离散化也可以用哈希表代替。</p>
<h3 id="c-中的unordered-map"><a href="#c-中的unordered-map" class="headerlink" title="c++中的unordered_map"></a>c++中的unordered_map</h3><p><code>unordered_map</code>的用法和<code>map</code>是一样的，提供了 <code>insert</code>，<code>size</code>，<code>count</code>等操作，并且里面的元素也是以<strong>pair</strong>类型来存贮的。其底层实现是完全不同的，但是就外部使用来说却是一致的。</p>
<h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//</span><br><span class="hljs-comment">// Created by s&#x27;c on 2022/4/15.</span><br><span class="hljs-comment">//</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;iostream&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;map&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;unordered_map&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;string&quot;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    unordered_map&lt;<span class="hljs-type">int</span>, string&gt; myMap=&#123;&#123; <span class="hljs-number">5</span>, <span class="hljs-string">&quot;张大&quot;</span> &#125;,&#123; <span class="hljs-number">6</span>, <span class="hljs-string">&quot;李五&quot;</span> &#125;&#125;;<span class="hljs-comment">//使用&#123;&#125;赋值</span><br>    myMap[<span class="hljs-number">2</span>] = <span class="hljs-string">&quot;李四&quot;</span>;  <span class="hljs-comment">//使用[ ]进行单个插入，若已存在键值2，则赋值修改，若无则插入。</span><br>    myMap.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">pair</span>&lt;<span class="hljs-type">int</span>, string&gt;(<span class="hljs-number">3</span>, <span class="hljs-string">&quot;陈二&quot;</span>));<span class="hljs-comment">//使用insert和pair插入</span><br>    <span class="hljs-comment">//遍历输出+迭代器的使用</span><br>    <span class="hljs-keyword">auto</span> iter = myMap.<span class="hljs-built_in">begin</span>();<span class="hljs-comment">//auto自动识别为迭代器类型unordered_map&lt;int,string&gt;::iterator</span><br>    <span class="hljs-keyword">while</span> (iter!= myMap.<span class="hljs-built_in">end</span>())<br>    &#123;<br>        cout &lt;&lt; iter-&gt;first &lt;&lt; <span class="hljs-string">&quot;,&quot;</span> &lt;&lt; iter-&gt;second &lt;&lt; endl;<br>        ++iter;<br>    &#125;<br><br>    <span class="hljs-comment">//查找元素并输出+迭代器的使用</span><br>    <span class="hljs-keyword">auto</span> iterator = myMap.<span class="hljs-built_in">find</span>(<span class="hljs-number">2</span>);<span class="hljs-comment">//find()返回一个指向2的迭代器</span><br>    <span class="hljs-keyword">if</span> (iterator != myMap.<span class="hljs-built_in">end</span>())<br>        cout &lt;&lt; endl&lt;&lt; iterator-&gt;first &lt;&lt; <span class="hljs-string">&quot;,&quot;</span> &lt;&lt; iterator-&gt;second &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p>注意：</p>
<ol>
<li><p>myMap[2]&#x3D;”李四”  若没有pair&lt;2,”李四”&gt; ，则直接插入；若key  2已经存在，则修改key  2对应的value为”李四”。</p>
</li>
<li><p>myMap.insert(make_pair(2,”王五”))，若myMap中没有pair&lt;int,string&gt;(2,”王五”)，则直接插入；若已经存在，则不再插入，也就是不修改，直接丢弃。</p>
</li>
<li><p>pair的构造函数<br>pair&lt;int,string&gt;(1,”李四”)<br>make_pair(1,”李四”)</p>
</li>
<li><p>在使用unordered_map统计字符、数字出现频率时，可直接使用++myMap[i]; 若出现频率减为0，则要手动删除这个pair，即  myMap.erase(key)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">if</span>(myMap[i]==<span class="hljs-number">0</span>)&#123;<br>    myMap.<span class="hljs-built_in">erase</span>(i);<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ol>
<h4 id="遍历unordered-map的方法"><a href="#遍历unordered-map的方法" class="headerlink" title="遍历unordered_map的方法"></a>遍历unordered_map的方法</h4><p><strong>需要使用迭代器</strong></p>
<p>不是key和value，也不是.first 和.second   而是iter-&gt;first  和 iter-&gt;second</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">auto</span> iter = myMap.<span class="hljs-built_in">begin</span>();<span class="hljs-comment">//auto自动识别为迭代器类型unordered_map&lt;int,string&gt;::iterator</span><br><span class="hljs-keyword">while</span> (iter!= myMap.<span class="hljs-built_in">end</span>())<br>&#123;<br>    cout &lt;&lt; iter-&gt;first &lt;&lt; <span class="hljs-string">&quot;,&quot;</span> &lt;&lt; iter-&gt;second &lt;&lt; endl;<br>    ++iter;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="查找某一个元素并输出"><a href="#查找某一个元素并输出" class="headerlink" title="查找某一个元素并输出"></a>查找某一个元素并输出</h4><p>不要使用这种方式！！！！！！！！！！！</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">cout &lt;&lt; myMap[<span class="hljs-number">2</span>] &lt;&lt; endl;<br></code></pre></td></tr></table></figure>

<p>因为这样如果unordered_map中不存在key  2的话，就会手动插入一个空的字符串，会改变原来的map的</p>
<p>而如果是&lt;int,int&gt; 则会插入默认value0</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">unordered_map&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; map;<br>cout &lt;&lt; map[<span class="hljs-number">0</span>] &lt;&lt; endl;<span class="hljs-comment">// 0</span><br></code></pre></td></tr></table></figure>



<p>推荐使用迭代器</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//查找元素并输出+迭代器的使用</span><br><span class="hljs-keyword">auto</span> iterator = myMap.<span class="hljs-built_in">find</span>(<span class="hljs-number">2</span>);<span class="hljs-comment">//find()返回一个指向2的迭代器</span><br><span class="hljs-keyword">if</span> (iterator != myMap.<span class="hljs-built_in">end</span>())<br>    cout &lt;&lt; endl&lt;&lt; iterator-&gt;first &lt;&lt; <span class="hljs-string">&quot;,&quot;</span> &lt;&lt; iterator-&gt;second &lt;&lt; endl;<br></code></pre></td></tr></table></figure>

<h5 id=""><a href="#" class="headerlink" title=""></a></h5><h2 id="4-17"><a href="#4-17" class="headerlink" title="4&#x2F;17"></a>4&#x2F;17</h2><h3 id="尾随0的个数"><a href="#尾随0的个数" class="headerlink" title="尾随0的个数"></a>尾随0的个数</h3><p>重要结论：乘积尾随0的数量是所有乘数中因子2数量之和与因子5数量之和中的较小值。</p>
<p>在做乘法的过程中，尾随0的数量只会增加不会减少，因此我们应该让尽量多的数参与乘积运算。也就是说最优路径一定是从某个边界出发，拐个弯，再走到另一个边界，不会中途不走了或者不拐弯（这样参与运算的数不是尽量多的）。</p>
<p>因此先用前缀和维护每一行和每一列因子 2 与因子 5 的数量，再枚举拐点计算答案即可。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxTrailingZeros</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = grid.<span class="hljs-built_in">size</span>(), m = grid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">f2</span>(n + <span class="hljs-number">1</span>), <span class="hljs-built_in">g2</span>(n + <span class="hljs-number">1</span>), <span class="hljs-built_in">f5</span>(n + <span class="hljs-number">1</span>), <span class="hljs-built_in">g5</span>(n + <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= n; i++) f2[i] = g2[i] = f5[i] = g5[i] = <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(m + <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; j++) &#123;<br>            <span class="hljs-type">int</span> x = grid[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>];<br>            <span class="hljs-type">int</span> two = <span class="hljs-number">0</span>, five = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">while</span> (x % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>) two++, x /= <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">while</span> (x % <span class="hljs-number">5</span> == <span class="hljs-number">0</span>) five++, x /= <span class="hljs-number">5</span>;<br>            f2[i][j] = f2[i][j - <span class="hljs-number">1</span>] + two;<br>            g2[i][j] = g2[i - <span class="hljs-number">1</span>][j] + two;<br>            f5[i][j] = f5[i][j - <span class="hljs-number">1</span>] + five;<br>            g5[i][j] = g5[i - <span class="hljs-number">1</span>][j] + five;<br>        &#125;<br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; j++) &#123;<br>            <span class="hljs-comment">// 从左边出发，到上边结束</span><br>            ans = <span class="hljs-built_in">max</span>(ans, <span class="hljs-built_in">min</span>(f2[i][j] + g2[i - <span class="hljs-number">1</span>][j], f5[i][j] + g5[i - <span class="hljs-number">1</span>][j]));<br>            <span class="hljs-comment">// 从左边出发，到下边结束</span><br>            ans = <span class="hljs-built_in">max</span>(ans, <span class="hljs-built_in">min</span>(f2[i][j] + g2[n][j] - g2[i][j], f5[i][j] + g5[n][j] - g5[i][j]));<br>            <span class="hljs-comment">// 从右边出发，到上边结束</span><br>            ans = <span class="hljs-built_in">max</span>(ans, <span class="hljs-built_in">min</span>(f2[i][m] - f2[i][j] + g2[i][j], f5[i][m] - f5[i][j] + g5[i][j]));<br>            <span class="hljs-comment">// 从右边出发，到下边结束</span><br>            ans = <span class="hljs-built_in">max</span>(ans, <span class="hljs-built_in">min</span>(f2[i][m] - f2[i][j] + g2[n][j] - g2[i - <span class="hljs-number">1</span>][j], f5[i][m] - f5[i][j] + g5[n][j] - g5[i - <span class="hljs-number">1</span>][j]));<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>



<h2 id="4-19"><a href="#4-19" class="headerlink" title="4&#x2F;19"></a>4&#x2F;19</h2><p>给一个字符串s和一个字符c，返回一个和字符串等长的数组，其中每一个数都表示该数与最近的字符c之间的距离。</p>
<p>问题可以转换成，对 s 的每个下标 i，求</p>
<p>s[i] 到其左侧最近的字符 c 的距离<br>s[i] 到其右侧最近的字符 c 的距离<br>这两者的最小值。</p>
<h2 id="4-24"><a href="#4-24" class="headerlink" title="4&#x2F;24"></a>4&#x2F;24</h2><h3 id="求一个点被几个区间覆盖"><a href="#求一个点被几个区间覆盖" class="headerlink" title="求一个点被几个区间覆盖"></a>求一个点被几个区间覆盖</h3><p>差分+离散化+排序</p>
<p>转化为区间修改，单点查询的题目，使用差分来解决；由于数据量很大，使用哈希表离散化。</p>
<p>对per进行排序，相当于一个预处理，这样就可以让时间复杂度从n^2降低到nlogn</p>
<p>灵佬 灵神代码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">fullBloomFlowers</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; f, vector&lt;<span class="hljs-type">int</span>&gt;&amp; per)</span> </span>&#123;<br>        map&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; m;<br>        <span class="hljs-type">int</span> n = per.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">res</span><span class="hljs-params">(n,<span class="hljs-number">0</span>)</span></span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span>&amp; ff:f)&#123;<br>            <span class="hljs-type">int</span> start = ff[<span class="hljs-number">0</span>],end = ff[<span class="hljs-number">1</span>];<br>            m[start]++;<br>            m[end+<span class="hljs-number">1</span>]--;<br>        &#125; <br>        <span class="hljs-comment">// 对person的下标按照person值进行排序</span><br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">id</span><span class="hljs-params">(n)</span></span>;<br>        <span class="hljs-built_in">iota</span>(id.<span class="hljs-built_in">begin</span>(),id.<span class="hljs-built_in">end</span>(),<span class="hljs-number">0</span>);<br>        <span class="hljs-built_in">sort</span>(id.<span class="hljs-built_in">begin</span>(),id.<span class="hljs-built_in">end</span>(),[&amp;](<span class="hljs-type">int</span> i,<span class="hljs-type">int</span> j)&#123;<span class="hljs-keyword">return</span> per[i]&lt;per[j];&#125;);<br>        map&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;::iterator it = m.<span class="hljs-built_in">begin</span>();<br>        <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i:id)&#123;<br>            <span class="hljs-type">int</span> t = per[i];<br>            <span class="hljs-keyword">for</span>(;it!=m.<span class="hljs-built_in">end</span>() &amp;&amp; it-&gt;first&lt;=t;++it)&#123;<br>                sum+=it-&gt;second;<br>            &#125;<br>            res[i] = sum;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>



<p>注意骚操作：对person数组按照值进行排序，并返回排好序的person数组的下标，这些下标对应的值已经按照person的值排好序。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">id</span><span class="hljs-params">(n)</span></span>;<br><span class="hljs-built_in">iota</span>(id.<span class="hljs-built_in">begin</span>(), id.<span class="hljs-built_in">end</span>(), <span class="hljs-number">0</span>);<br><span class="hljs-built_in">sort</span>(id.<span class="hljs-built_in">begin</span>(), id.<span class="hljs-built_in">end</span>(), [&amp;](<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j) &#123; <span class="hljs-keyword">return</span> persons[i] &lt; persons[j]; &#125;);<br></code></pre></td></tr></table></figure>





<h3 id="sort排序的原理"><a href="#sort排序的原理" class="headerlink" title="sort排序的原理"></a>sort排序的原理</h3><p>原理是 cmp返回值为真时，第一个数字放前面</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(<span class="hljs-type">int</span> &amp;a,<span class="hljs-type">int</span> &amp;b)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> a&gt;b;<br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="lambda表达式"><a href="#lambda表达式" class="headerlink" title="lambda表达式"></a>lambda表达式</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">[ 捕获 ] ( 形参 ) -&gt; ret &#123; 函数体 &#125;;<br></code></pre></td></tr></table></figure>

<p>lambda表达式一般都是以方括号[]开头，有参数就使用()，无参就直接省略()即可，最后结束于{}，其中的ret表示返回类型。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">auto</span> atLambda = [] &#123;std::cout &lt;&lt; <span class="hljs-string">&quot;hello world&quot;</span> &lt;&lt; std::endl;&#125;;<br>    <span class="hljs-built_in">atLambda</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>上面定义了一个最简单的lambda表达式，没有参数。如果需要参数，那么就要像函数那样，放在圆括号里面，如果有返回值，返回类型则要放在-&gt;后面，也就是尾随返回类型，当然你也可以忽略返回类型，lambda会帮你自动推导出返回类型，下面看一个较为复杂的例子：</p>
<h3 id="assign-成员函数"><a href="#assign-成员函数" class="headerlink" title="assign()成员函数"></a>assign()成员函数</h3><p>优于for循环，好得多</p>
<p>区间成员函数优于与之对应的单元素成员函数。</p>
<p>erase()和insert()区间插入</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">a</span><span class="hljs-params">(<span class="hljs-number">1</span>,<span class="hljs-number">0</span>)</span></span>;<br>    vector&lt;<span class="hljs-type">int</span>&gt; b&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>&#125;;<br>    a.<span class="hljs-built_in">assign</span>(b.<span class="hljs-built_in">begin</span>(),b.<span class="hljs-built_in">end</span>());<span class="hljs-comment">//1 2 3 4 5</span><br><span class="hljs-comment">//    a.insert(a.end(),b.begin(),b.end());//0 1 2 3 4 5</span><br><span class="hljs-comment">//    a.insert(a.begin(),b.begin(),b.end());// 1 2 3 4 5 0</span><br>    a.<span class="hljs-built_in">erase</span>(a.<span class="hljs-built_in">begin</span>(),a.<span class="hljs-built_in">begin</span>()+<span class="hljs-number">2</span>);<span class="hljs-comment">//3 4 5</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i&lt;a.<span class="hljs-built_in">size</span>();++i)&#123;<br>        cout &lt;&lt; a[i] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h2 id="4-25"><a href="#4-25" class="headerlink" title="4&#x2F;25"></a>4&#x2F;25</h2><p>a是已经排好序的序列，利用二分查找找出a中$a_i\leq k$ 的$a_i$ 的最小指针</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">lower_bound</span>(a,a+n,k);<br></code></pre></td></tr></table></figure>

<p>利用二分查找找出a中满足$a_i &gt; k$ 的$a_i$ 的最小指针</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">upper_bound</span>(a,a+n,k);<br></code></pre></td></tr></table></figure>

<p>于是，我们可以求出，在有序序列a中k的个数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">upper_bound</span>(a,a+n,k)-<span class="hljs-built_in">lower_bound</span>(a,a+n,k);<br></code></pre></td></tr></table></figure>



<h3 id="求划分数"><a href="#求划分数" class="headerlink" title="求划分数"></a>求划分数</h3><p>n个无区别的物品，将他们划分成<strong>不超过</strong>m组，求有多少种划分方法（对M取模）</p>
<p>这样想，考虑n的m划分$a_i(\sum_{i&#x3D;1}^m a_i&#x3D;n)$ 如果对于每个$i$ 都有$a_i&gt;0$ ，则$a_{i}-1$ 就对应了n-m的n划分。另外，如果存在$a_i&#x3D;0$，那么就对应了n的m-1划分。综上可以得出递推关系如下所示。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//</span><br><span class="hljs-comment">// Created by s&#x27;c on 2022/4/25.</span><br><span class="hljs-comment">//</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;bits/stdc++.h&quot;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> n,m,M;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MAX = <span class="hljs-number">1010</span>;<br><span class="hljs-type">int</span> dp[MAX][MAX];<span class="hljs-comment">//dp[i][j]表示j的i划分，把j划分成i份，有多少种划分方法</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>,&amp;n,&amp;m,&amp;M);<br>    dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i&lt;=m;++i)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;j&lt;=n;++j)&#123;<br>            <span class="hljs-keyword">if</span>(j&lt;i) dp[i][j] = dp[i<span class="hljs-number">-1</span>][j];<br>            <span class="hljs-keyword">else</span> dp[i][j] = (dp[i<span class="hljs-number">-1</span>][j] + dp[i][j-i])%M;<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,dp[m][n]);<br>&#125;<br></code></pre></td></tr></table></figure>



<p>若223 232 不算一组，则可以这样想    将j划分成i个，可以先取出k个，然后将剩下的j-k个分成i-1份，递推式如下</p>
<p>$dp[i][j] &#x3D; \sum_{k&#x3D;0}^j dp[i-1][j-k]$ </p>
<h2 id="4-28"><a href="#4-28" class="headerlink" title="4&#x2F;28"></a>4&#x2F;28</h2><h2 id="题目连接"><a href="#题目连接" class="headerlink" title="题目连接"></a>题目连接</h2><p><a target="_blank" rel="noopener" href="https://www.papamelon.com/problem/225">https://www.papamelon.com/problem/225</a></p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>用dp[i][j]表示从前i中物品中取出j个，一共有多少种取法<br>dp[i][j]: 考虑前 i 种物品中选出 j 个物品的方案数<br>将物品的种类从 1∼n 编号，答案则是：dp[n][m]</p>
<p>根据状态定义我们发现，每种物品可能取1，2，…a_i种可能。<br>接下来进行分类讨论：</p>
<ol>
<li>当$j&lt;&#x3D;a_i$时，$dp[i][j] &#x3D; dp[i-1][j]+dp[i-1][j-1]+…+dp[i-1][1]+dp[i-1][0]$</li>
<li>当$j&gt;a_i$时，$dp[i][j] &#x3D; dp[i-1][j]+dp[i-1][j-1]+…+dp[i-1][j-a_i]$</li>
</ol>
<p>设$b &#x3D; min(ai,j)$，则<br>$dp[i][j] &#x3D; dp[i-1][j]+dp[i-1][j-1]+…dp[i-1][j-b]$</p>
<p>但此时时间复杂度过高，每次求dp[i][j]都要遍历ai，这样复杂度为n*m*ai，一定会超时。考虑使用动态规划的递推思想优化。</p>
<h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><p>如何利用动态规划的递推思想呢？考虑对于$dp[i][j]$，若我们已知$dp[i][j-1]，$即$dp[i][j-1] &#x3D; dp[i-1][j-1]+dp[i-1][j-2]+…+dp[i-1][j-1-b]，b &#x3D; min(j-1,ai)$<br>此时还是要根据$j-1$与$a_i$的大小情况进行分类讨论</p>
<ol>
<li><p>$j-1&lt;&#x3D;a_i$时，$dp[i][j-1] &#x3D; dp[i-1][j-1]+dp[i-1][j-2]+…+dp[i-1][0]$，有$dp[i][j] &#x3D; dp[i][j-1]+dp[i-1][j]$</p>
</li>
<li><p>$j-1&gt;a_i$时，$dp[i][j-1] &#x3D; dp[i-1][j-1]+dp[i-1][j-2]+…+dp[i-1][j-ai]+dp[i-1][j-1-a_i]$，有$dp[i][j] &#x3D; dp[i][j-1]+dp[i-1][j]-dp[i-1][j-1-a_i]$</p>
<p>于是就得出了递推公式。</p>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//</span><br><span class="hljs-comment">// Created by s&#x27;c on 2022/4/28.</span><br><span class="hljs-comment">//</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;bits/stdc++.h&quot;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MAX = <span class="hljs-number">1010</span>;	q` <br><span class="hljs-type">int</span> dp[MAX][MAX]=&#123;<span class="hljs-number">0</span>&#125;;<br><span class="hljs-type">int</span> a[MAX]=&#123;<span class="hljs-number">0</span>&#125;;<br><span class="hljs-type">int</span> M=<span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> n,m;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">tt</span><span class="hljs-params">()</span></span>&#123;<br>    cin&gt;&gt;n&gt;&gt;m&gt;&gt;M;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i&lt;=n;++i)&#123;<br>        cin&gt;&gt;a[i];<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i&lt;=n;++i)&#123;<br>        dp[i][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i&lt;=n;++i)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>;j&lt;=m;++j)&#123;<br>            <span class="hljs-keyword">if</span>(j<span class="hljs-number">-1</span>&lt;a[i])&#123;<br>                dp[i][j] = (dp[i][j<span class="hljs-number">-1</span>]+dp[i<span class="hljs-number">-1</span>][j])%M;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                dp[i][j] = (dp[i][j<span class="hljs-number">-1</span>]+dp[i<span class="hljs-number">-1</span>][j]-dp[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>-a[i]]+M)%M;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i&lt;=n;++i)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>;j&lt;=m;++j)&#123;<br>            cout &lt;&lt; dp[i][j] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>        &#125;<br>        cout &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,dp[n][m]);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">tt</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="注意-3"><a href="#注意-3" class="headerlink" title="注意"></a>注意</h3><ol>
<li>第一次写时，ai与dp[i][j]的对应关系没找好，注意ai是从0开始还是从1开始，dp[i][j]也要做相应的变化</li>
</ol>
<h2 id="题目连接226远征"><a href="#题目连接226远征" class="headerlink" title="题目连接226远征"></a>题目连接226远征</h2><p><a target="_blank" rel="noopener" href="https://www.papamelon.com/problem/226">https://www.papamelon.com/problem/226</a></p>
<h4 id="思路讲解"><a href="#思路讲解" class="headerlink" title="思路讲解"></a>思路讲解</h4><p>本题也可采用贪心的思想去求解，只是为了求解方便，使用了优先队列数据结构。每次到加油站时，都要把加油站的油加光，这是贪心1；<br>另外，汽车不会加油，除非邮箱内的油不能支撑汽车到下一个加油站，这是贪心2.</p>
<p>另外，我们可以使用小技巧：每到一个加油站时，我们都默认获得了加油的资格，只是不把油加上，而是放到一个优先队列中（大顶堆）。<br>当需要加油的时候，就默认从优先队列中取出最大的，意思是在我到那个加油站的时候，已经加过油了。</p>
<p>失败条件：若当前邮箱里的油不能支撑汽车到下一个加油站了，但是优先队列已经空了，那么汽车不能到达终点，输出-1.</p>
<p>还有坑：</p>
<ol>
<li>第一遍做时，没有注意到给出的Ai是该加油站到终点的距离。</li>
<li>给出的加油站的距离可能没有排好序，需要重新排序。</li>
</ol>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//</span><br><span class="hljs-comment">// Created by s&#x27;c on 2022/4/28.</span><br><span class="hljs-comment">//</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;bits/stdc++.h&quot;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> N,L,P;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MAX = <span class="hljs-number">20010</span>;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span>&#123;<br>    vector&lt;pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;&gt; a;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;N);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i&lt;N;++i)&#123;<br>        <span class="hljs-type">int</span> t1,t2;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;t1,&amp;t2);<br>        a.<span class="hljs-built_in">emplace_back</span>(t1,t2);<br>    &#125;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;L,&amp;P);<br>    <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>,pos = <span class="hljs-number">0</span>,tank = P;<br><span class="hljs-comment">//    a[N] = L;</span><br><span class="hljs-comment">//    b[N] = 0;</span><br>    a.<span class="hljs-built_in">emplace_back</span>(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);<br>    <span class="hljs-built_in">sort</span>(a.<span class="hljs-built_in">begin</span>(),a.<span class="hljs-built_in">end</span>(),[&amp;](pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;&amp; a,pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;&amp; b)-&gt;<span class="hljs-type">bool</span> &#123;<span class="hljs-keyword">return</span> a.first&gt;b.first;&#125;);<br><span class="hljs-comment">//    for(int i = 0;i&lt;=N;++i)&#123;</span><br><span class="hljs-comment">//        cout &lt;&lt; &quot;loc=&quot; &lt;&lt; a[i].first &lt;&lt; &quot; &quot; &lt;&lt; &quot;you=&quot; &lt;&lt; a[i].second &lt;&lt; endl;</span><br><span class="hljs-comment">//    &#125;</span><br>    priority_queue&lt;<span class="hljs-type">int</span>&gt; maxHeap;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i&lt;=N;++i)&#123;<br>        <span class="hljs-type">int</span> loc = a[i].first;<br>        <span class="hljs-type">int</span> ll = a[i].second;<br>        <span class="hljs-type">int</span> d = L-loc-pos;<br>        <span class="hljs-keyword">while</span>(tank&lt;d)&#123;<br>            <span class="hljs-keyword">if</span>(maxHeap.<span class="hljs-built_in">empty</span>())&#123;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;-1\n&quot;</span>);<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>            <span class="hljs-type">int</span> add = maxHeap.<span class="hljs-built_in">top</span>();<br>            maxHeap.<span class="hljs-built_in">pop</span>();<br>            tank+=add;<br>            res++;<span class="hljs-comment">//加了一次油</span><br>        &#125;<br>        pos = L-loc;<br>        tank-=d;<br>        maxHeap.<span class="hljs-built_in">push</span>(ll);<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,res);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">solve</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="set查找集合中元素的方法"><a href="#set查找集合中元素的方法" class="headerlink" title="set查找集合中元素的方法"></a>set查找集合中元素的方法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//方法一：使用迭代器</span><br>set&lt;<span class="hljs-type">int</span>&gt;::iterator it = set.<span class="hljs-built_in">begin</span>();<br><span class="hljs-keyword">for</span>(;it!=set.<span class="hljs-built_in">end</span>();++it);<br><br><span class="hljs-comment">//方法二 使用count方法</span><br>set.<span class="hljs-built_in">count</span>(<span class="hljs-number">2</span>)&gt;<span class="hljs-number">0</span>  表明set中有元素<span class="hljs-number">2</span><br></code></pre></td></tr></table></figure>

<p>set是有序哈希表，相当于TreeSet，不能存放重复元素。</p>
<h3 id="map删除元素"><a href="#map删除元素" class="headerlink" title="map删除元素"></a>map删除元素</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">map&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; m;<br>m.<span class="hljs-built_in">erase</span>(key);<br></code></pre></td></tr></table></figure>



<h3 id="能存放重复值的multiset，重复键值的multimap"><a href="#能存放重复值的multiset，重复键值的multimap" class="headerlink" title="能存放重复值的multiset，重复键值的multimap"></a>能存放重复值的multiset，重复键值的multimap</h3><p>multiset还是有序的，multimap也还是有序的</p>
<h2 id="5-1"><a href="#5-1" class="headerlink" title="5&#x2F;1"></a>5&#x2F;1</h2><p>快速排序不稳定，想要稳定，就要用下面的代码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// ca数组已经给出</span><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">id</span><span class="hljs-params">(n)</span></span>;<br><span class="hljs-built_in">iota</span>(id.<span class="hljs-built_in">begin</span>(),id.<span class="hljs-built_in">end</span>(),<span class="hljs-number">0</span>);<br><span class="hljs-built_in">sort</span>(id.<span class="hljs-built_in">begin</span>(),id.<span class="hljs-built_in">end</span>(),[&amp;](<span class="hljs-type">int</span> i,<span class="hljs-type">int</span> j)&#123;<span class="hljs-keyword">return</span> ca[i]==ca[j]?i&lt;j:ca[i]&lt;ca[j];&#125;);<br></code></pre></td></tr></table></figure>



<h3 id="周赛第四题"><a href="#周赛第四题" class="headerlink" title="周赛第四题"></a>周赛第四题</h3><p>字符串   计算贡献    dp   字符串的总引力</p>
<p><img src="https://cdn.jsdelivr.net/gh/dutsc/cloud-image/blog-img/202312052037678.png" srcset="/img/loading.gif" lazyload></p>
<p><img src="https://cdn.jsdelivr.net/gh/dutsc/cloud-image/blog-img/202312052034202.png" srcset="/img/loading.gif" lazyload></p>
<p>在字符串结尾添加一个新的字符，实时维护该字符上一次出现的下标；新字符对总引力值的贡献就是当前下标减去上一次出现的下标；若该字符还没有出现，则当前字符的贡献就是当前下标+1，+1的原因是考虑当前字符单独一个，也会贡献一个引力值。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-title">appealSum</span><span class="hljs-params">(string s)</span> </span>&#123;<br>    <span class="hljs-type">int</span> n = s.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">loc</span><span class="hljs-params">(<span class="hljs-number">26</span>,<span class="hljs-number">-1</span>)</span></span>;<br>    ll sum = <span class="hljs-number">0</span>,res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i&lt;n;++i)&#123;<br>      <span class="hljs-type">int</span> c = s[i]-<span class="hljs-string">&#x27;a&#x27;</span>;<br>      <span class="hljs-keyword">if</span>(loc[c]==<span class="hljs-number">-1</span>)&#123;<br>        sum+=i+<span class="hljs-number">1</span>; <br>      &#125;<span class="hljs-keyword">else</span>&#123;<br>        sum+=i-loc[c];<br>      &#125;<br>      loc[c] = i;<br>      res+=sum;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>



<h3 id="241并查集经典题"><a href="#241并查集经典题" class="headerlink" title="241并查集经典题"></a>241并查集经典题</h3><p>a吃b，b吃c，c吃a</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//</span><br><span class="hljs-comment">// Created by s&#x27;c on 2022/5/1.</span><br><span class="hljs-comment">//</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;bits/stdc++.h&quot;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MAXN = <span class="hljs-number">200000</span>;<br><span class="hljs-type">int</span> par[MAXN];<br><span class="hljs-type">int</span> ran[MAXN];<br><span class="hljs-type">int</span> N,K,a,b,c;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i&lt;=n;++i)&#123;<br>        par[i] = i;<br>        ran[i] = <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(x==par[x]) <span class="hljs-keyword">return</span> x;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> par[x]=<span class="hljs-built_in">find</span>(par[x]); <span class="hljs-comment">// 返回时更改节点的父节点为祖宗节点，就是路径压缩操作</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">unite</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span></span>&#123;<br>    <span class="hljs-type">int</span> fx = <span class="hljs-built_in">find</span>(x);<br>    <span class="hljs-type">int</span> fy = <span class="hljs-built_in">find</span>(y);<br>    <span class="hljs-keyword">if</span>(fx==fy) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-keyword">if</span>(ran[fx]&lt;ran[fy])&#123;<br>        par[fx] = fy;<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        par[fy] = fx;<br>        <span class="hljs-keyword">if</span>(ran[fx]==ran[fy]) ran[fx]++;  <span class="hljs-comment">// 这个优化有的题目会卡</span><br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin&gt;&gt;N&gt;&gt;K;<br>    <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">init</span>(<span class="hljs-number">3</span>*N);<br>    <span class="hljs-keyword">while</span>(K--&gt;<span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>,&amp;a,&amp;b,&amp;c);<br>        <span class="hljs-keyword">if</span>(b&gt;N||c&gt;N)&#123;<br>            res++;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(a==<span class="hljs-number">2</span> &amp;&amp; b==c)&#123;<br>            res++;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(a==<span class="hljs-number">1</span>)&#123; <span class="hljs-comment">// bc同一类</span><br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">find</span>(b)==<span class="hljs-built_in">find</span>(c+N) || <span class="hljs-built_in">find</span>(b)==<span class="hljs-built_in">find</span>(c+<span class="hljs-number">2</span>*N))&#123;<br>                res++;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-built_in">unite</span>(b,c);<br>            <span class="hljs-built_in">unite</span>(b+N,c+N);<br>            <span class="hljs-built_in">unite</span>(b+<span class="hljs-number">2</span>*N,c+<span class="hljs-number">2</span>*N);<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(a==<span class="hljs-number">2</span>)&#123;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">find</span>(b)==<span class="hljs-built_in">find</span>(c)||<span class="hljs-built_in">find</span>(b)==<span class="hljs-built_in">find</span>(c+N))&#123;<br>                res++;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-built_in">unite</span>(b+N,c);<br>            <span class="hljs-built_in">unite</span>(b+<span class="hljs-number">2</span>*N,c+N);<br>            <span class="hljs-built_in">unite</span>(b,c+<span class="hljs-number">2</span>*N);<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,res);<br>&#125;<br><br></code></pre></td></tr></table></figure>

<h4 id="注意-4"><a href="#注意-4" class="headerlink" title="注意"></a>注意</h4><ol>
<li>必须要路径压缩，差距会非常大，即 find(x) 中 return par[x] &#x3D; find(par[x]);</li>
<li>可以进行rank优化，会更快一些</li>
</ol>
<h2 id="5-2"><a href="#5-2" class="headerlink" title="5&#x2F;2"></a>5&#x2F;2</h2><p>c++不要使用<strong>字符加字符串</strong>   ‘a’+”asdfa”  超级慢</p>
<h2 id="5-3"><a href="#5-3" class="headerlink" title="5&#x2F;3"></a>5&#x2F;3</h2><h3 id="二分图判定c-二着色问题"><a href="#二分图判定c-二着色问题" class="headerlink" title="二分图判定c++   二着色问题"></a>二分图判定c++   二着色问题</h3><p>问题连接</p>
<p><a target="_blank" rel="noopener" href="https://www.papamelon.com/problem/242">https://www.papamelon.com/problem/242</a></p>
<p>学习的地方：</p>
<ol>
<li>以EOF结束输入的方法  <del>scanf();  因为</del>是按位取反，而EOF&#x3D;-1，补码表示是11111.</li>
<li>c++存图方式，虽然是最垃圾的，vector<int> G[MAX],若有权值或者其他信息，则</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">edge</span>&#123;<br>  <span class="hljs-type">int</span> to;<br>  <span class="hljs-type">int</span> cost;<br>  &#125;;<br>vector&lt;edge&gt; G[MAX];<br></code></pre></td></tr></table></figure>

<p>思路</p>
<p>创建一个邻接矩阵，一个color数组表示该节点被染成了什么颜色。由于只有两种颜色，故使用1与-1表示。</p>
<ol>
<li>dfs函数中，首先将节点染色，然后遍历该节点的邻接表，如果邻接节点染的颜色与本节点相同，则return false；如果邻接节点与本节点染色相反，则直接搜索下一个节点；如果邻接节点没有染色，<br>则将邻接节点染成相反的颜色。并且对dfs做判断，if(!dfs(下一个节点,-c)) return false;  之前也遇到过这个技巧，如果dfs返回true不要着急返回true，而是要判断所有的情况都return true才可以。</li>
<li>主函数中，由于给出的图可能不是联通图，故要使用for循环遍历一下，并判断color[i]有没有染色。</li>
</ol>
<p>代码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c++">  <span class="hljs-comment">//</span><br><span class="hljs-comment">// Created by s&#x27;c on 2022/5/3.</span><br><span class="hljs-comment">//</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;bits/stdc++.h&quot;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MAX = <span class="hljs-number">1010</span>;<br><span class="hljs-type">int</span> n,x,y;<br>vector&lt;<span class="hljs-type">int</span>&gt; G[MAX];<br><span class="hljs-type">int</span> color[MAX]=&#123;<span class="hljs-number">0</span>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> k,<span class="hljs-type">int</span> c)</span></span>&#123;<br>    color[k] = c;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i&lt;G[k].<span class="hljs-built_in">size</span>();++i)&#123;<br>        <span class="hljs-type">int</span> to = G[k][i];<br>        <span class="hljs-keyword">if</span>(color[to]==c) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">if</span>(color[to]==<span class="hljs-number">0</span>)&#123; <span class="hljs-comment">//还没染色</span><br>            <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">dfs</span>(to,-c)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin&gt;&gt;n;<br>    <span class="hljs-keyword">while</span>(~<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;x,&amp;y))&#123;<br>        G[x].<span class="hljs-built_in">push_back</span>(y);<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i&lt;n;++i)&#123;<br>        <span class="hljs-keyword">if</span>(color[i]==<span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">dfs</span>(i,<span class="hljs-number">1</span>))&#123;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;No\n&quot;</span>);<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Yes\n&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="二维差分"><a href="#二维差分" class="headerlink" title="二维差分"></a>二维差分</h3><p><img src="C:/Users/s%27c/AppData/Roaming/Typora/typora-user-images/image-20220503100257497.png" srcset="/img/loading.gif" lazyload alt="image-20220503100257497"></p>
<h2 id="5-8"><a href="#5-8" class="headerlink" title="5&#x2F;8"></a>5&#x2F;8</h2><p>带有剪枝的 <strong>状态dfs</strong></p>
<p>我的朴素代码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">bool</span> used[<span class="hljs-number">105</span>][<span class="hljs-number">105</span>][<span class="hljs-number">210</span>]=&#123;<span class="hljs-number">0</span>&#125;;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">hasValidPath</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">char</span>&gt;&gt;&amp; grid)</span> </span>&#123;<br>        <span class="hljs-type">int</span> m = grid.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> n = grid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">if</span>(grid[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]==<span class="hljs-string">&#x27;)&#x27;</span> || grid[m<span class="hljs-number">-1</span>][n<span class="hljs-number">-1</span>]==<span class="hljs-string">&#x27;(&#x27;</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">dfs</span>(grid,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">dfs</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">char</span>&gt;&gt;&amp; grid,<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y,<span class="hljs-type">int</span> score)</span></span>&#123;<br>        <span class="hljs-type">int</span> m = grid.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> n = grid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">if</span>(score&gt;m-x+n-y<span class="hljs-number">-1</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        score += grid[x][y]==<span class="hljs-string">&#x27;(&#x27;</span>?<span class="hljs-number">1</span>:<span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">if</span>(score&lt;<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">if</span>(x==m<span class="hljs-number">-1</span> &amp;&amp; y==n<span class="hljs-number">-1</span>)&#123;<br>            <span class="hljs-keyword">if</span>(score==<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(used[x][y][score]) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        used[x][y][score] = <span class="hljs-literal">true</span>;<span class="hljs-comment">//此点的这个状态已经访问过</span><br>        <span class="hljs-keyword">if</span>(x+<span class="hljs-number">1</span>&lt;m)&#123;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">dfs</span>(grid,x+<span class="hljs-number">1</span>,y,score))&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(y+<span class="hljs-number">1</span>&lt;n)&#123;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">dfs</span>(grid,x,y+<span class="hljs-number">1</span>,score))&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>



<p>灵佬的带c++11特性的function函数代码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">hasValidPath</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">char</span>&gt;&gt; &amp;grid)</span> </span>&#123;<br>        <span class="hljs-type">int</span> m = grid.<span class="hljs-built_in">size</span>(), n = grid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">if</span> ((m + n) % <span class="hljs-number">2</span> == <span class="hljs-number">0</span> || grid[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;)&#x27;</span> || grid[m - <span class="hljs-number">1</span>][n - <span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;(&#x27;</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">// 剪枝</span><br>        <span class="hljs-type">bool</span> vis[m][n][m + n]; <span class="hljs-built_in">memset</span>(vis, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(vis));<br>        function&lt;<span class="hljs-type">bool</span>(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>, <span class="hljs-type">int</span>)&gt; dfs = [&amp;](<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y, <span class="hljs-type">int</span> c) -&gt; <span class="hljs-type">bool</span> &#123;<br>            <span class="hljs-keyword">if</span> (c &gt; m - x + n - y - <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">// 剪枝：即使后面都是 &#x27;)&#x27; 也不能将 c 减为 0</span><br>            <span class="hljs-keyword">if</span> (x == m - <span class="hljs-number">1</span> &amp;&amp; y == n - <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> c == <span class="hljs-number">1</span>; <span class="hljs-comment">// 终点一定是 &#x27;)&#x27;</span><br>            <span class="hljs-keyword">if</span> (vis[x][y][c]) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">// 重复访问</span><br>            vis[x][y][c] = <span class="hljs-literal">true</span>;<br>            c += grid[x][y] == <span class="hljs-string">&#x27;(&#x27;</span> ? <span class="hljs-number">1</span> : <span class="hljs-number">-1</span>;<br>            <span class="hljs-keyword">return</span> c &gt;= <span class="hljs-number">0</span> &amp;&amp; (x &lt; m - <span class="hljs-number">1</span> &amp;&amp; <span class="hljs-built_in">dfs</span>(x + <span class="hljs-number">1</span>, y, c) || y &lt; n - <span class="hljs-number">1</span> &amp;&amp; <span class="hljs-built_in">dfs</span>(x, y + <span class="hljs-number">1</span>, c)); <span class="hljs-comment">// 往下或者往右</span><br>        &#125;;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">dfs</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>





<h2 id="5-9"><a href="#5-9" class="headerlink" title="5&#x2F;9"></a>5&#x2F;9</h2><h3 id="prim算法思想"><a href="#prim算法思想" class="headerlink" title="prim算法思想"></a>prim算法思想</h3><p>一般使用邻接矩阵？？   邻接表的话，转换成邻接矩阵？？   <strong>还是要分析时间复杂度</strong></p>
<p>与dijkstra算法很类似，都是从某个顶点出发，不断添加边的算法</p>
<p>首先假设有一课只包含一个顶点v的树T，然后贪心地选取T和其他顶点之间相连地最小权值的边，并把它加入到T中，不断进行这个操作，就可以得到一课最小生成树了。</p>
<h3 id="Kruskal算法-使用并查集"><a href="#Kruskal算法-使用并查集" class="headerlink" title="Kruskal算法 使用并查集"></a>Kruskal算法 使用并查集</h3><p>Kruskal算法按照边的权值的顺序从小到大查看一遍，如果不产生边（重边也算在内），就把当前这条边加入到生成树中。</p>
<p>第一步就是对边排序   </p>
<p>第二步是遍历所有的边</p>
<h3 id="求到某个顶点v的次短路"><a href="#求到某个顶点v的次短路" class="headerlink" title="求到某个顶点v的次短路"></a>求到某个顶点v的次短路</h3><p>其实就是二选一</p>
<ol>
<li>到某个顶点u的最短路+u v之间的距离</li>
<li>到某个顶点u的次短路+ u v之间的距离</li>
</ol>
<p>因此要求的就是源点到每个顶点的最短路和次短路，分别用两个数组dis和dis2来表示</p>
<p>思路</p>
<ol>
<li>首先考虑该边能不能更新最短路，如果可以更新最短路就更新，把老的最短路放到次短路上（因为被更新就说明，原来的老的最短路已经不是最短路了，所以把它放到次短路上）；</li>
<li>若该边不能更新最短路，则考虑用该边更新次短路；若该边不能更新次短路，则不使用该边更新。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//</span><br><span class="hljs-comment">// Created by s&#x27;c on 2022/5/9.</span><br><span class="hljs-comment">//</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;bits/stdc++.h&quot;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; P;<br><span class="hljs-type">int</span> N,R;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MAX = <span class="hljs-number">0x3f3f3f3f</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> LEN =(<span class="hljs-type">int</span>)<span class="hljs-number">1e5</span>+<span class="hljs-number">10</span>;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">edge</span>&#123;<br>    <span class="hljs-type">int</span> to;<br>    <span class="hljs-type">int</span> cost;<br>&#125;;<br>vector&lt;edge&gt; G[LEN];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dijsktra</span><span class="hljs-params">(<span class="hljs-type">int</span> tt)</span></span>&#123;<br>    <span class="hljs-type">int</span> dist[<span class="hljs-number">5010</span>];<br>    <span class="hljs-type">int</span> dist2[<span class="hljs-number">5010</span>];<br>    priority_queue&lt;P,vector&lt;P&gt;,greater&lt;P&gt;&gt; que;<span class="hljs-comment">//按照边的权值从小到大排序</span><br>    <span class="hljs-built_in">memset</span>(dist,<span class="hljs-number">0x3f</span>,<span class="hljs-built_in">sizeof</span>(dist));<br>    <span class="hljs-built_in">memset</span>(dist2,<span class="hljs-number">0x3f</span>,<span class="hljs-built_in">sizeof</span>(dist2));<br>    dist[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br><span class="hljs-comment">//    dist2[1] = 0;</span><br>    que.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">P</span>(<span class="hljs-number">0</span>,<span class="hljs-number">1</span>));<br>    <span class="hljs-keyword">while</span>(!que.<span class="hljs-built_in">empty</span>())&#123;<br>        P p = que.<span class="hljs-built_in">top</span>();<br>        que.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-type">int</span> to = p.second;<br><span class="hljs-comment">//        if(dist2[to]&lt;p.first) continue;</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i&lt;G[to].<span class="hljs-built_in">size</span>();++i)&#123;<br>            <span class="hljs-type">int</span> toto = G[to][i].to;<br>            <span class="hljs-type">int</span> ccost = G[to][i].cost;<br>            <span class="hljs-type">int</span> temp = p.first+ccost;<span class="hljs-comment">// 注意这里不能写dist[to] 而必须要写p.first，因为此时最短和第二短都会入队，p.first不一定是最短的</span><br><span class="hljs-comment">//            cout &lt;&lt; &quot;p.first=&quot; &lt;&lt; p.first &lt;&lt; &quot; dist[to]=&quot; &lt;&lt; dist[to] &lt;&lt; endl;</span><br>            <span class="hljs-keyword">if</span>(dist[toto]&gt;temp)&#123;<br>                <span class="hljs-built_in">swap</span>(dist[toto],temp);<br>                que.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">make_pair</span>(dist[toto],toto));<br>            &#125;<br>            <span class="hljs-keyword">if</span>(temp&lt;dist2[toto] &amp;&amp; temp&gt;dist[toto])&#123;<br>                dist2[toto] = temp;<br>                que.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">make_pair</span>(dist2[toto],toto));<br>            &#125;<br>        &#125;<br>    &#125;<br><span class="hljs-comment">//    for(int i = 1;i&lt;=N;++i)&#123;</span><br><span class="hljs-comment">//        cout &lt;&lt; dist2[i] &lt;&lt; endl;</span><br><span class="hljs-comment">//    &#125;</span><br><span class="hljs-comment">//    cout &lt;&lt; &quot;N=&quot; &lt;&lt; N &lt;&lt; &quot; tt=&quot; &lt;&lt; tt &lt;&lt; endl;</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,dist2[tt]);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin&gt;&gt;N&gt;&gt;R;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i =<span class="hljs-number">0</span>;i&lt;R;++i)&#123;<br>        <span class="hljs-type">int</span> x,y,D;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>,&amp;x,&amp;y,&amp;D);<br>        edge e;<br>        e.to=y;<br>        e.cost=D;<br>        G[x].<span class="hljs-built_in">push_back</span>(e);<br>        edge e2;<br>        e2.cost=D;<br>        e2.to=x;<br>        G[y].<span class="hljs-built_in">push_back</span>(e2);<br>    &#125;<br><span class="hljs-comment">//    cout &lt;&lt; &quot;完成输入&quot; &lt;&lt; endl;</span><br>    <span class="hljs-built_in">dijsktra</span>(N);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="征兵亲密度-最小生成树"><a href="#征兵亲密度-最小生成树" class="headerlink" title="征兵亲密度 最小生成树"></a>征兵亲密度 最小生成树</h3><p>题目链接</p>
<p><a target="_blank" rel="noopener" href="https://www.papamelon.com/problem/245">https://www.papamelon.com/problem/245</a></p>
<p>思路</p>
<p>可以将题目翻译成求最小生成树的问题</p>
<p>解释一下题意：招募每个人都要花钱，但是若女兵x和男兵y关系好，而且已经招募了其中一个，则招募另外一个的时候，就可以少花一些钱。可以想到的一种思路是，不考虑亲密度，招募所有人需要花费的钱为<br>10000*(N+M)，而考虑亲密度之后再减去相应的亲密度。为了使付的钱更少，也就是减去的亲密度更多，就需要找亲密度最大的情侣进行征兵。</p>
<p>若将亲密度转化为负数，则找最大亲密度，就相当于找最小的数，就可以利用最小生成树的克鲁斯卡尔算法解决这个问题。</p>
<p>注意，第一次写遇到的问题：</p>
<ol>
<li>使用边集数组存储所有的边，然后遍历所有的边，这样使用克鲁斯卡尔算法比窘方便。</li>
<li>一个关系不需要存储两遍。</li>
<li>由于男兵女兵都有编号为0，1，2…的人，而女兵有N个，所以不妨让男兵的编号为N+y，这样更方便用并查集解决问题。</li>
</ol>
<p>其实本质就是贪心的克鲁斯卡尔算法。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//</span><br><span class="hljs-comment">// Created by s&#x27;c on 2022/5/9.</span><br><span class="hljs-comment">//</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;bits/stdc++.h&quot;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-comment">//女N   男M</span><br><span class="hljs-type">int</span> T,N,M,R;<br><span class="hljs-type">int</span> x,y,d;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MAX = <span class="hljs-number">20010</span>;<br><span class="hljs-type">int</span> fa[MAX];<br><span class="hljs-type">int</span> rrank[MAX];<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">edge</span>&#123;<br>    <span class="hljs-type">int</span> from;<br>    <span class="hljs-type">int</span> to;<br>    <span class="hljs-type">int</span> cost;<br>&#125;;<br>vector&lt;edge&gt; relation;<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(<span class="hljs-type">const</span> edge&amp;e1,<span class="hljs-type">const</span> edge &amp;e2)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> e1.cost&lt;e2.cost;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i&lt;MAX;++i)&#123;<br>        fa[i] = i;<br>        rrank[i] = <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(x==fa[x]) <span class="hljs-keyword">return</span> x;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> fa[x]=<span class="hljs-built_in">find</span>(fa[x]);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span></span>&#123;<br>    <span class="hljs-type">int</span> fx = fa[x];<br>    <span class="hljs-type">int</span> fy = fa[y];<br>    <span class="hljs-keyword">if</span>(fx==fy) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-keyword">if</span>(rrank[fx]&lt;rrank[fy])&#123;<br>        fa[fx]=fy;<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        fa[fy]=fx;<br>        <span class="hljs-keyword">if</span>(rrank[fx]==rrank[fy])&#123;<br>            rrank[fx]++;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">same</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">find</span>(x)==<span class="hljs-built_in">find</span>(y);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin&gt;&gt;T;<br>    <span class="hljs-keyword">while</span>(T--&gt;<span class="hljs-number">0</span>)&#123;<br>        relation.<span class="hljs-built_in">clear</span>();<br>        <span class="hljs-built_in">init</span>();<span class="hljs-comment">//初始化并查集</span><br>        cin&gt;&gt;N&gt;&gt;M&gt;&gt;R;<br>        <span class="hljs-type">int</span> r = R;<br>        <span class="hljs-keyword">while</span>(R--&gt;<span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>,&amp;x,&amp;y,&amp;d);<br>            edge e1,e2;<br>            e1.from=x;<br>            e1.to=N+y;<br>            e1.cost=-d;<br>            relation.<span class="hljs-built_in">push_back</span>(e1);<br>        &#125;<br>        <span class="hljs-comment">//x   N+y</span><br>        <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// 把所有的边排序</span><br>        <span class="hljs-built_in">sort</span>(relation.<span class="hljs-built_in">begin</span>(),relation.<span class="hljs-built_in">end</span>(),cmp);<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i&lt;r;++i)&#123;<span class="hljs-comment">//遍历所有的边</span><br>            edge e = relation[i];<br>            <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">same</span>(e.from,e.to))&#123;<br>                <span class="hljs-built_in">merge</span>(e.from,e.to);<br>                res+=e.cost;<br>            &#125;<br>        &#125;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,<span class="hljs-number">10000</span>*(N+M)+res);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>



<h2 id="5-10"><a href="#5-10" class="headerlink" title="5&#x2F;10"></a>5&#x2F;10</h2><h3 id="差分约束系统"><a href="#差分约束系统" class="headerlink" title="差分约束系统"></a>差分约束系统</h3><blockquote>
<p>构造一个有向图，跑SPFA</p>
</blockquote>
<p>使用图的思想求解不等式的一组可行解</p>
<p>$x_1-x_2&lt;3$ <strong>则从2到1连一条权值为3的边   终极源点是0  d1-d2&lt;3 d1指从0到1的边的最短距离</strong></p>
<p>从源点0到别的所有点可以连边，也可以不连，连就要都连成一样的数  <strong>类似一种基准</strong>  求出一种可行解即可，因为通常都不是只有一种解。 可以都初始化成0，因为这样就不用初始化答案数组了，省时省力</p>
<p>最终求从0到所有点的最短距离即可？?？</p>
<p>注意：</p>
<ol>
<li>第一次做本题时出错的原因是，建立源点时，源点0到每一个其他点的cost是0没错，但是到其他点的dist不应该是0，而应该是无穷大。因为还是求最短路的思想。</li>
</ol>
<p>洛谷差分约束系统模板题代码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//</span><br><span class="hljs-comment">// Created by s&#x27;c on 2022/5/11.</span><br><span class="hljs-comment">//</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;bits/stdc++.h&quot;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> n,m;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">edge</span>&#123;<br>    <span class="hljs-type">int</span> to;<br>    <span class="hljs-type">int</span> cost;<br>&#125;;<br>vector&lt;edge&gt; G[<span class="hljs-number">5010</span>];<br>queue&lt;<span class="hljs-type">int</span>&gt; que;<br><span class="hljs-type">bool</span> used[<span class="hljs-number">5010</span>];<span class="hljs-comment">//是否在队中</span><br><span class="hljs-type">int</span> nums[<span class="hljs-number">5010</span>];<span class="hljs-comment">//入队次数</span><br><span class="hljs-type">int</span> dist[<span class="hljs-number">5010</span>]=&#123;<span class="hljs-number">0</span>&#125;;<span class="hljs-comment">// 到源点的最短距离</span><br><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">spfa</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) dist[i]=<span class="hljs-number">1e9</span>;<span class="hljs-comment">//最短路，初始值为inf</span><br>    dist[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i&lt;=n;++i)&#123;<br>        edge e;<br>        e.to = i;<br>        e.cost = <span class="hljs-number">0</span>;<br>        G[<span class="hljs-number">0</span>].<span class="hljs-built_in">push_back</span>(e);<br>    &#125;<br>    <span class="hljs-keyword">while</span>(m--&gt;<span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-type">int</span> a,b,y;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>,&amp;a,&amp;b,&amp;y);<br>        edge e;<br>        e.to = a;<br>        e.cost = y;<br>        G[b].<span class="hljs-built_in">push_back</span>(e);<br>    &#125;<br><br>    que.<span class="hljs-built_in">push</span>(<span class="hljs-number">0</span>);<br>    used[<span class="hljs-number">0</span>] = <span class="hljs-literal">true</span>;<br>    nums[<span class="hljs-number">0</span>]++;<br>    <span class="hljs-keyword">while</span>(!que.<span class="hljs-built_in">empty</span>())&#123;<br>        <span class="hljs-type">int</span> tt = que.<span class="hljs-built_in">front</span>();<br>        que.<span class="hljs-built_in">pop</span>();<br>        used[tt] = <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i&lt;G[tt].<span class="hljs-built_in">size</span>();++i)&#123;<br>            <span class="hljs-comment">//访问邻接表</span><br>            <span class="hljs-type">int</span> to = G[tt][i].to;<br>            <span class="hljs-type">int</span> cost = G[tt][i].cost;<br><span class="hljs-comment">//            cout &lt;&lt; &quot;访问邻接表了&quot; &lt;&lt; endl;</span><br><span class="hljs-comment">//            cout &lt;&lt; &quot;dist[to]=&quot; &lt;&lt; dist[to] &lt;&lt; &quot; cost=&quot; &lt;&lt; cost &lt;&lt; endl;</span><br>            <span class="hljs-keyword">if</span>(dist[to]&gt;dist[tt]+cost)&#123;<br>                dist[to] = dist[tt]+cost;<br><span class="hljs-comment">//                cout &lt;&lt; &quot;进行松弛操作了&quot; &lt;&lt; endl;</span><br>                <span class="hljs-keyword">if</span>(!used[to])&#123;<br>                    used[to] = <span class="hljs-literal">true</span>;<br>                    nums[to]++;<br>                    que.<span class="hljs-built_in">push</span>(to);<br>                    <span class="hljs-keyword">if</span>(nums[to]&gt;=n)&#123;<br>                        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;NO\n&quot;</span>);<br>                        <span class="hljs-keyword">return</span>;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br><br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i&lt;=n;++i)&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d%c&quot;</span>,dist[i],i==n?<span class="hljs-string">&#x27;\n&#x27;</span>:<span class="hljs-string">&#x27; &#x27;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin&gt;&gt;n&gt;&gt;m;<br>    <span class="hljs-built_in">spfa</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>



<h2 id="5-13"><a href="#5-13" class="headerlink" title="5&#x2F;13"></a>5&#x2F;13</h2><h3 id="线段上的格点个数"><a href="#线段上的格点个数" class="headerlink" title="线段上的格点个数"></a>线段上的格点个数</h3><p>其实就是求最大公约数</p>
<p>$gcd(|x_1-x_2|,|y_1-y_2|)-1$</p>
<h3 id="区间筛法求素数"><a href="#区间筛法求素数" class="headerlink" title="区间筛法求素数"></a>区间筛法求素数</h3><p>之前我们了解过筛法求素数，现在我们思考一下，当面对某个区间$[a,b)$内的数求素数的个数时，要怎么求。</p>
<p>性质1： b以内最小质因数一定不超过$\sqrt(b)$ 。因此筛得$[2,\sqrt(b))$ 中质数的同时，也将其倍数从$[a,b)$ 中抹去。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//</span><br><span class="hljs-comment">// Created by s&#x27;c on 2022/5/13.</span><br><span class="hljs-comment">//</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;bits/stdc++.h&quot;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br>ll a,b;<br><span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br><span class="hljs-type">bool</span> is_prime[<span class="hljs-number">1000010</span>]=&#123;<span class="hljs-number">0</span>&#125;;<br><span class="hljs-type">int</span> primee[<span class="hljs-number">1000010</span>]=&#123;<span class="hljs-number">0</span>&#125;; <span class="hljs-comment">// [a,b) 区间内的数 是否是素数  下标0代表</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld%lld&quot;</span>,&amp;a,&amp;b);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>;<span class="hljs-number">1LL</span>*i*i&lt;b;++i)&#123;<br>        <span class="hljs-keyword">if</span>(!is_prime[i])&#123; <span class="hljs-comment">// 找到质数</span><br>            ll first = (a+i<span class="hljs-number">-1</span>)/i*i;<br>            <span class="hljs-keyword">for</span>(ll j = <span class="hljs-built_in">max</span>(<span class="hljs-number">2</span>*i*<span class="hljs-number">1LL</span>,first);j&lt;b;j+=i)&#123; <span class="hljs-comment">// 标记质数的倍数为合数</span><br>                <span class="hljs-type">int</span> id = (<span class="hljs-type">int</span>)(j-a);<br>                primee[id] = <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i&lt;(<span class="hljs-type">int</span>)(b-a);++i)&#123;<br>        <span class="hljs-keyword">if</span>(!primee[i]) res++;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,res);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>



<h4 id="求大于a的第一个能被i整除的数"><a href="#求大于a的第一个能被i整除的数" class="headerlink" title="求大于a的第一个能被i整除的数"></a>求大于a的第一个能被i整除的数</h4><p>$\frac{a+i-1}{i} \times i$ </p>
<h2 id="5-14"><a href="#5-14" class="headerlink" title="5&#x2F;14"></a>5&#x2F;14</h2><h3 id="Carmichael-Numbers（卡迈克尔数）"><a href="#Carmichael-Numbers（卡迈克尔数）" class="headerlink" title="Carmichael Numbers（卡迈克尔数）"></a>Carmichael Numbers（卡迈克尔数）</h3><p>我们把对任意的$1&lt;x&lt;n$ 都有$x^n \equiv x(mod \quad n)$ 成立的<strong>合数</strong> n 称为Carmichael Numbers。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//</span><br><span class="hljs-comment">// Created by s&#x27;c on 2022/5/14.</span><br><span class="hljs-comment">//</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;bits/stdc++.h&quot;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> n;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br><span class="hljs-function">ll <span class="hljs-title">fastpow</span><span class="hljs-params">(ll a,ll b,ll mod)</span></span>&#123;<br>    ll res = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>(b&gt;<span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-keyword">if</span>(b%<span class="hljs-number">2</span>==<span class="hljs-number">1</span>)&#123;<br>            res = (res*a)%mod;<br>        &#125;<br>        a = (a*a)%mod;<br>        b = b&gt;&gt;<span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">is_prime</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>;i*i&lt;x;++i)&#123;<br>        <span class="hljs-keyword">if</span>(x%i==<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;n);<br>    <span class="hljs-keyword">while</span>(n!=<span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-type">bool</span> flag = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">is_prime</span>(n)) flag = <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> x = <span class="hljs-number">2</span>;flag &amp;&amp; x&lt;n;++x)&#123;<br>            ll t1 = <span class="hljs-built_in">fastpow</span>(x,n,n);<br>            <span class="hljs-keyword">if</span>(t1!=x*<span class="hljs-number">1LL</span>)&#123;<br>                flag = <span class="hljs-literal">false</span>;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(flag)&#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;The number %d is a Carmichael number.\n&quot;</span>,n);<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d is normal.\n&quot;</span>,n);<br>        &#125;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;n);<br>    &#125;<br><span class="hljs-comment">//cout &lt;&lt; fastpow(2,17,17) &lt;&lt; endl;</span><br><span class="hljs-comment">//cout &lt;&lt; fastpow(3,17,17) &lt;&lt; endl;</span><br><span class="hljs-comment">//cout &lt;&lt; fastpow(4,17,17) &lt;&lt; endl;</span><br><span class="hljs-comment">//cout &lt;&lt; fastpow(5,17,17) &lt;&lt; endl;</span><br><span class="hljs-comment">//cout &lt;&lt; fastpow(6,17,17) &lt;&lt; endl;</span><br><span class="hljs-comment">//cout &lt;&lt; fastpow(7,17,17) &lt;&lt; endl;</span><br><span class="hljs-comment">//cout &lt;&lt; fastpow(8,17,17) &lt;&lt; endl;</span><br><span class="hljs-comment">//cout &lt;&lt; fastpow(9,17,17) &lt;&lt; endl;</span><br><span class="hljs-comment">//cout &lt;&lt; fastpow(10,17,17) &lt;&lt; endl;</span><br><span class="hljs-comment">//cout &lt;&lt; fastpow(11,17,17) &lt;&lt; endl;</span><br><span class="hljs-comment">//cout &lt;&lt; fastpow(12,17,17) &lt;&lt; endl;</span><br><span class="hljs-comment">//cout &lt;&lt; fastpow(13,17,17) &lt;&lt; endl;</span><br><span class="hljs-comment">//cout &lt;&lt; fastpow(14,17,17) &lt;&lt; endl;</span><br>&#125;<br><br></code></pre></td></tr></table></figure>



<h3 id="往-ll-上加-int时，要格外注意"><a href="#往-ll-上加-int时，要格外注意" class="headerlink" title="往 ll 上加 int时，要格外注意"></a>往 ll 上加 int时，要格外注意</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++">ll res = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i&lt;n;++i)&#123;<br>    res+=<span class="hljs-number">1LL</span>*v1[i]*v2[n-i<span class="hljs-number">-1</span>];<br>&#125;<br></code></pre></td></tr></table></figure>

<ol>
<li><p><strong>必须$\times $ 1LL!!!!!!!!!!!!!</strong>      </p>
</li>
<li><p>在printf时，一定要  %lld   !!!!!!!!!!</p>
</li>
</ol>
<h3 id="疯狂矩阵"><a href="#疯狂矩阵" class="headerlink" title="疯狂矩阵"></a>疯狂矩阵</h3><p>题目连接</p>
<p><a target="_blank" rel="noopener" href="https://www.papamelon.com/problem/254">https://www.papamelon.com/problem/254</a></p>
<p>主对角线：从左上，到右下<br>暂且考虑一下最后应该把哪一行交换到第1行。最后的第一行应该具有00…00或者10…00的形式。可以交换到第一行的行当然也可以交换到第2及以后的行。当有多个满足条件的行时，选择离第1行近的行对应的<br>最终费用要小。这点可以证明。</p>
<p>注意</p>
<ol>
<li>需要先预处理出 <strong>每一行内最后一个1的位置，0 - n-1</strong></li>
<li><strong>在交换时，不要交换实际矩阵的值，而是要交换lasto数组的值。</strong>因为在交换的过程中用不到实际矩阵。如果要交换实际矩阵，则每次交换后还要重新预处理lasto数组，白白增加了复杂度。</li>
</ol>
<p>代码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//</span><br><span class="hljs-comment">// Created by s&#x27;c on 2022/5/14.</span><br><span class="hljs-comment">//</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;bits/stdc++.h&quot;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> T,n;<br><span class="hljs-type">int</span> g[<span class="hljs-number">45</span>][<span class="hljs-number">45</span>];<br><span class="hljs-type">int</span> lasto[<span class="hljs-number">45</span>];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;T);<br>    <span class="hljs-type">int</span> index = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>(index&lt;=T)&#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;n);<br>        <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i&lt;n;++i)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;j&lt;n;++j)&#123;<br>                <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;g[i][j]);<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 预处理每一行最后一个1的位置</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i&lt;n;++i)&#123;<br>            <span class="hljs-type">int</span> pos = <span class="hljs-number">-1</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;j&lt;n;++j)&#123;<br>                <span class="hljs-keyword">if</span>(g[i][j]==<span class="hljs-number">1</span>)&#123;<br>                    pos = j;<br>                &#125;<br>            &#125;<br>            lasto[i] = pos;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i&lt;n;++i)&#123;<br>            <span class="hljs-type">int</span> pos = <span class="hljs-number">-1</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = i;j&lt;n;++j)&#123;<br>                <span class="hljs-keyword">if</span>(lasto[j]&lt;=i)&#123;<br>                    pos = j;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>            <span class="hljs-comment">//交换</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = pos;j&gt;i;--j)&#123;<br>                <span class="hljs-built_in">swap</span>(lasto[j],lasto[j<span class="hljs-number">-1</span>]);<br>                res++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Case #%d: %d\n&quot;</span>,index,res);<br>        index++;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>



<h2 id="5-15"><a href="#5-15" class="headerlink" title="5&#x2F;15"></a>5&#x2F;15</h2><h3 id="已知三角形三个顶点，求面积"><a href="#已知三角形三个顶点，求面积" class="headerlink" title="已知三角形三个顶点，求面积"></a>已知三角形三个顶点，求面积</h3><p><img src="https://cdn.jsdelivr.net/gh/dutsc/cloud-image/blog-img/202312052037913.png" srcset="/img/loading.gif" lazyload></p>
<p>注意加绝对值 </p>
<h3 id="注意数量级"><a href="#注意数量级" class="headerlink" title="注意数量级"></a>注意数量级</h3><p>$2 \times 10^5$ 意思是 2后面有5个0</p>
<h2 id="5-27"><a href="#5-27" class="headerlink" title="5&#x2F;27"></a>5&#x2F;27</h2><h3 id="小数二分"><a href="#小数二分" class="headerlink" title="小数二分"></a>小数二分</h3><p>通常使用二分法，check函数O(n),二分O(logn) 总体O(nlog n)</p>
<p>问题连接</p>
<p><a target="_blank" rel="noopener" href="https://www.papamelon.com/problem/258">https://www.papamelon.com/problem/258</a></p>
<p>思路</p>
<p>常规二分法的思路，使用二分检查结果，check函数复杂度为O(n)。</p>
<p>注意</p>
<ol>
<li>选择左右边界时，左边界选取0.0（因为有可能k&gt;长度最大的L），右边界选取最长的绳子的长度。</li>
<li>double类型在二分的时候，不存在+1的概念，每次都是以mid为边界。</li>
<li>循环结束条件变为循环100次，1次循环可以把区间范围缩小一半，100次循环则可以达到10^(-30)的精度范围，精度范围基本上没有问题。</li>
</ol>
<p>另外，也可以设置终止条件为(r-l)&gt;EPS这样，指定一个区间的大小。这种情况下，如果EPS取的太小，就有可能因为浮点小数精度的原因导致陷入死循环，需要额外注意。 </p>
<p>代码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//</span><br><span class="hljs-comment">// Created by s&#x27;c on 2022/5/27.</span><br><span class="hljs-comment">//</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;bits/stdc++.h&quot;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> n,k;<br><span class="hljs-type">double</span> mmax = <span class="hljs-number">1.0</span>;<br><span class="hljs-type">double</span> a[<span class="hljs-number">100005</span>];<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(<span class="hljs-type">double</span> mid)</span></span>&#123;<br>    <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i&lt;n;++i)&#123;<br>        res+=(<span class="hljs-type">int</span>)(a[i]/mid);<br>    &#125;<br>    <span class="hljs-keyword">return</span> res&gt;=k;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;n,&amp;k);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i&lt;n;++i)&#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lf&quot;</span>,&amp;a[i]);<br>        mmax = <span class="hljs-built_in">max</span>(mmax,a[i]);<br>    &#125;<br>    <span class="hljs-type">double</span> l = <span class="hljs-number">0.0</span>,r = mmax;<br>    <span class="hljs-type">int</span> index = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(index++&lt;<span class="hljs-number">100</span>)&#123;<br>        <span class="hljs-type">double</span> mid = (r+l)/<span class="hljs-number">2.0</span>;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">check</span>(mid)) l = mid;<br>        <span class="hljs-keyword">else</span> r = mid;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%.2f&quot;</span>,<span class="hljs-built_in">floor</span>(r*<span class="hljs-number">100</span>)/<span class="hljs-number">100</span>);<br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="最大化最小值问题"><a href="#最大化最小值问题" class="headerlink" title="最大化最小值问题"></a>最大化最小值问题</h3><h3 id="最小化最大值问题（"><a href="#最小化最大值问题（" class="headerlink" title="最小化最大值问题（"></a>最小化最大值问题（</h3><h2 id="6-8"><a href="#6-8" class="headerlink" title="6&#x2F;8"></a>6&#x2F;8</h2><h3 id="最大化平均值问题"><a href="#最大化平均值问题" class="headerlink" title="最大化平均值问题"></a>最大化平均值问题</h3><p>每个物品的重量为$w_i$ 价值为$v_i$  从中选出k个物品使得单位重量的价值最大。   <strong>并不是选择单位重量价值最大的物品，从高到低</strong> </p>
<h3 id="c-自定义优先队列排序"><a href="#c-自定义优先队列排序" class="headerlink" title="c++自定义优先队列排序"></a>c++自定义优先队列排序</h3><ul>
<li><p>优先队列排序时，建议使用仿函数 在定义的时候使用struct  重载()函数执行符    而且在写仿函数的时候不加()</p>
</li>
<li><p>sort自定义排序时，可以使用仿函数（struct，重写()函数执行符），也可以使用普通函数（bool cmp()），使用仿函数必须加()，使用普通函数bool cmp不用加()</p>
</li>
</ul>
<p>&#x3D;&#x3D;推荐使用仿函数&#x3D;&#x3D;</p>
<p><strong>使用仿函数自定义优先队列实例</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//</span><br><span class="hljs-comment">// Created by s&#x27;c on 2022/6/8.</span><br><span class="hljs-comment">//</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;queue&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;iostream&quot;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;P;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">cmp</span>&#123;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">const</span> pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; &amp;p1,<span class="hljs-type">const</span> pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; &amp;p2)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(p1.second*<span class="hljs-number">1.0</span>/p1.first&lt;=p2.second*<span class="hljs-number">1.0</span>/p2.first) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">cmp_sort</span>&#123;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp; o1,<span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp; o2)</span></span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">abs</span>(o1)&lt;<span class="hljs-built_in">abs</span>(o2);<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">cmp_sort2</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span>&amp; o1,<span class="hljs-type">const</span> <span class="hljs-type">int</span>&amp; o2)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">abs</span>(o1)&lt;<span class="hljs-built_in">abs</span>(o2);<br>&#125;<br><br>priority_queue&lt;pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;,vector&lt;pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;&gt;, cmp&gt; que;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-function">P <span class="hljs-title">p1</span><span class="hljs-params">(<span class="hljs-number">2</span>,<span class="hljs-number">2</span>)</span>,<span class="hljs-title">p2</span><span class="hljs-params">(<span class="hljs-number">5</span>,<span class="hljs-number">3</span>)</span>,<span class="hljs-title">p3</span><span class="hljs-params">(<span class="hljs-number">2</span>,<span class="hljs-number">1</span>)</span></span>;<br>    que.<span class="hljs-built_in">push</span>(p1);<br>    que.<span class="hljs-built_in">push</span>(p2);<br>    que.<span class="hljs-built_in">push</span>(p3);<br>    <span class="hljs-keyword">while</span>(!que.<span class="hljs-built_in">empty</span>())<br>    &#123;<br>        P p = que.<span class="hljs-built_in">top</span>();<br>        cout &lt;&lt; p.first &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; p.second &lt;&lt; endl;<br>        que.<span class="hljs-built_in">pop</span>();<br>    &#125;<br>    vector&lt;<span class="hljs-type">int</span>&gt; a;<br>    a.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">-3</span>);<br>    a.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">3</span>);<br>    a.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">36</span>);<br>    a.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">53</span>);<br>    a.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">322</span>);<br>    a.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">-93</span>);<br>    a.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-built_in">sort</span>(a.<span class="hljs-built_in">begin</span>(),a.<span class="hljs-built_in">end</span>(),cmp_sort2);<br>    <span class="hljs-comment">// sort(a.begin(),a.end(),cmp_sort()); 与之等价</span><br>    <span class="hljs-comment">// sort(a.begin(),a.end(),[](int a,int b)-&gt; bool&#123;return abs(a)&lt;abs(b);&#125;); 也可以使用labmda表达式</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> i:a)&#123;<br>        cout &lt;&lt; i &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    <br>&#125; <br><span class="hljs-comment">/*</span><br><span class="hljs-comment">2 2</span><br><span class="hljs-comment">5 3</span><br><span class="hljs-comment">2 1</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure>





<h2 id="6-9"><a href="#6-9" class="headerlink" title="6&#x2F;9"></a>6&#x2F;9</h2><h3 id="尺取法"><a href="#尺取法" class="headerlink" title="尺取法"></a>尺取法</h3><p>使用尺取法时，while循环的判断条件不要是r&lt;n（右下标小于总数），这样会造成最右边的情况还没有处理，就跳出循环了。</p>
<p>较好的处理方式是：最外层是一个无限循环 break出循环的条件是：确保所有的情况已经处理完毕</p>
<h2 id="7-27"><a href="#7-27" class="headerlink" title="7&#x2F;27"></a>7&#x2F;27</h2><p>矩形之间的嵌套关系是一个典型的二元关系，二元关系可以用图来建模。</p>
<p>嵌套矩形：求DAG图中不固定起点的最长路径</p>
<h2 id="10-2"><a href="#10-2" class="headerlink" title="10&#x2F;2"></a>10&#x2F;2</h2><p>把一个数最低位的0变成1  <code>n|(n+1)</code></p>
<p>把一个数最低位的1变成0  <code>n&amp;(n-1)</code></p>
<h2 id="11-28-1"><a href="#11-28-1" class="headerlink" title="11&#x2F;28"></a>11&#x2F;28</h2><ol>
<li><p>反转链表  递归   双指针</p>
</li>
<li><p>topk 优先队列  快速排序</p>
</li>
<li><p>快速排序避免有序情况，可以首先花费o(N)将数组shuffle一下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Arrays;<br><span class="hljs-keyword">import</span> java.util.Random;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Created by 燃烧杯 on 2018/5/12.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ArrayUtils</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">Random</span> <span class="hljs-variable">rand</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Random</span>();<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-keyword">void</span> <span class="hljs-title function_">swap</span><span class="hljs-params">(T[] a, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span>&#123;<br>        <span class="hljs-type">T</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> a[i];<br>        a[i] = a[j];<br>        a[j] = temp;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-keyword">void</span> <span class="hljs-title function_">shuffle</span><span class="hljs-params">(T[] arr)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">length</span> <span class="hljs-operator">=</span> arr.length;<br>        <span class="hljs-keyword">for</span> ( <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> length; i &gt; <span class="hljs-number">0</span>; i-- )&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">randInd</span> <span class="hljs-operator">=</span> rand.nextInt(i);<br>            swap(arr, randInd, i - <span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        Integer[] arr = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>&#125;;<br>        shuffle(arr);<br>        System.out.println(Arrays.toString(arr));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ol>
<h2 id="11-29-1"><a href="#11-29-1" class="headerlink" title="11&#x2F;29"></a>11&#x2F;29</h2><ol>
<li><p>实现LRU   哈希表+双向链表，手写双向链表</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">LRUCache</span> &#123;<br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">LinkedNode</span>&#123;<br>        <span class="hljs-type">int</span> key;<br>        <span class="hljs-type">int</span> val;<br>        LinkedNode pre;<br>        LinkedNode next;<br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">LinkedNode</span><span class="hljs-params">(<span class="hljs-type">int</span> _key,<span class="hljs-type">int</span> _val)</span>&#123;<br>            <span class="hljs-built_in">this</span>.key = _key;<br>            <span class="hljs-built_in">this</span>.val = _val;<br>            <span class="hljs-built_in">this</span>.pre = <span class="hljs-literal">null</span>;<br>            <span class="hljs-built_in">this</span>.next = <span class="hljs-literal">null</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-type">int</span> size;<br>    <span class="hljs-type">int</span> capacity;<br>    Map&lt;Integer,LinkedNode&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>    LinkedNode head;<br>    LinkedNode tail;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">LRUCache</span><span class="hljs-params">(<span class="hljs-type">int</span> c)</span> &#123;<br>        capacity = c;<br>        size = <span class="hljs-number">0</span>;<br>        head = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedNode</span>(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);<br>        tail = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedNode</span>(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);<br>        head.next = tail;<br>        tail.pre = head;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">get</span><span class="hljs-params">(<span class="hljs-type">int</span> key)</span> &#123;<br>        <span class="hljs-keyword">if</span>(map.get(key)!=<span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-comment">//存在 返回关键字的值</span><br>            <span class="hljs-comment">// 将该节点移到双向链表头部</span><br>            <span class="hljs-type">LinkedNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> map.get(key);<br>            moveToHead(node);<br>            <span class="hljs-keyword">return</span> node.val;<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-comment">// 不存在 返回-1</span><br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">put</span><span class="hljs-params">(<span class="hljs-type">int</span> key, <span class="hljs-type">int</span> value)</span> &#123;<br>        <span class="hljs-keyword">if</span>(map.get(key)!=<span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-comment">// 存在 更新值 </span><br>            <span class="hljs-comment">// 将该节点移到双向链表头部</span><br>            <span class="hljs-type">LinkedNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> map.get(key);<br>            node.val = value;<br>            moveToHead(node);<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-comment">// 不存在 直接插入</span><br>            <span class="hljs-comment">// 移到头部</span><br>            <span class="hljs-comment">// 容量超过，则删除尾部节点</span><br>            <span class="hljs-type">LinkedNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedNode</span>(key,value);<br>            map.put(key,node);<br>            addToHead(node);<br>            size++;<br>            <span class="hljs-keyword">if</span>(size&gt;capacity)&#123;<br>                <span class="hljs-type">LinkedNode</span> <span class="hljs-variable">myTail</span> <span class="hljs-operator">=</span> removeTail();<br>                map.remove(myTail.key);<br>                size--;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">moveToHead</span><span class="hljs-params">(LinkedNode node)</span>&#123;<br>        <span class="hljs-comment">// 删除该节点</span><br>        removeNode(node);<br>        <span class="hljs-comment">// 在头部插入该节点</span><br>        addToHead(node);<br>    &#125;<br>    <span class="hljs-keyword">public</span> LinkedNode <span class="hljs-title function_">removeNode</span><span class="hljs-params">(LinkedNode node)</span>&#123;<br>        node.pre.next = node.next;<br>        node.next.pre = node.pre;<br>        <span class="hljs-keyword">return</span> node;<span class="hljs-comment">// ?????</span><br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addToHead</span><span class="hljs-params">(LinkedNode node)</span>&#123;<br>        node.next = head.next;<br>        node.pre = head;<br>        head.next = node;<br>        node.next.pre = node;<br>    &#125;<br>    <span class="hljs-keyword">public</span> LinkedNode <span class="hljs-title function_">removeTail</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-comment">// 要返回删除的节点，因为程序中要删除map中的键值对</span><br>        <span class="hljs-type">LinkedNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> tail.pre;<br>        node.pre.next = tail;<br>        tail.pre = node.pre;<br>        <span class="hljs-keyword">return</span> node;  <br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your LRUCache object will be instantiated and called as such:</span><br><span class="hljs-comment"> * LRUCache obj = new LRUCache(capacity);</span><br><span class="hljs-comment"> * int param_1 = obj.get(key);</span><br><span class="hljs-comment"> * obj.put(key,value);</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure></li>
</ol>
<h2 id="12-2"><a href="#12-2" class="headerlink" title="12&#x2F;2"></a>12&#x2F;2</h2><h3 id="红黑树原理"><a href="#红黑树原理" class="headerlink" title="红黑树原理"></a>红黑树原理</h3><ol>
<li>（根属性）红黑树根节点必须是黑色</li>
<li>红色节点的孩子必须是黑色的。也就是说，不能由连续的红色节点；两个黑色的节点可以连接一起，也就是说，黑色节点的孩子可以是黑色（红属性）</li>
<li>红黑树把null作为叶子节点，AVL树不算null节点。（黑属性），任意一个节点，到它的叶子节点的所有路径，包含相同数目的黑色节点。</li>
<li>整棵红黑树的高度不超过 $2 log_2(n+1)$，n为节点个数</li>
</ol>
<p>黑色高度（black height）：从一个节点到他的叶子，经过的黑色节点数目，就叫做它的黑色高度</p>
<h4 id="红黑树插入情景"><a href="#红黑树插入情景" class="headerlink" title="红黑树插入情景"></a>红黑树插入情景</h4><blockquote>
<p>插入节点必须是红色节点</p>
</blockquote>
<ol>
<li><p>所插入的红黑树为空节点，则直接插入，并将红色节点染黑。</p>
</li>
<li><p>所插入的节点key已经存在，则将插入节点的value赋值给存在的节点，进行节点值更新。</p>
</li>
<li><p>所插入的节点的父节点是黑色，则直接插入即可。</p>
</li>
<li><p>所插入的节点的父节点是红色，</p>
<ol>
<li><p>情景4.1 叔叔节点存在且为红节点</p>
<p>将所插入节点称为x，则x的爸爸是红色。根据红黑树的性质（根节点一定是黑色），x一定存在一个爷爷节点，且爷爷节点是黑色。</p>
<p>处理步骤：</p>
<ol>
<li>将x的爸爸和叔叔节点改为黑色</li>
<li>将x的爷爷节点改成红色</li>
<li>将x的爷爷节点设置为当前节点，进行后续处理</li>
</ol>
<p>可以看到，如果x的爷爷节点的父节点是黑色，那么无需再做任何处理；但是如果x的爷爷节点是红色，则需要将x的爷爷节点设为当前节点，继续尽心插入操作自平衡处理，直到平衡为止。</p>
</li>
<li><p>情景4.2 叔叔节点不存在 或者叔叔节点为黑色节点，并且插入节点的父节点（P）是祖父节点（PP）的左子节点</p>
<ol>
<li>情景4.2.1 插入节点x是父节点（P）的左子节点  （<strong>LL双红</strong>）<ol>
<li>将父节点P染黑，祖父节点PP染红</li>
<li>将祖父节点右旋</li>
</ol>
</li>
<li>情景4.2.2 插入节点x是父节点（P）的右子节点（<strong>LR双红</strong>）<ol>
<li>将父节点P左旋</li>
<li>处理<strong>LL双红</strong>的情况</li>
</ol>
</li>
</ol>
</li>
<li><p>情景4.3 叔叔节点不存在或为黑色节点，并且插入节点的父亲节点P是祖父节点PP的右子节点</p>
<ol>
<li>情景4.3.1 新插入节点x是父节点P的右子节点（<strong>RR双红</strong>）<ol>
<li>将插入节点x的父亲节点染黑，祖父节点PP染红</li>
<li>然后将祖父节点左旋</li>
</ol>
</li>
<li>情景4.3.2 新插入节点x是父节点P的左子节点（<strong>RL双红</strong>）<ol>
<li>将父节点P右旋</li>
<li>处理<strong>RR双红</strong>的情况</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<h2 id="12-7"><a href="#12-7" class="headerlink" title="12&#x2F;7"></a>12&#x2F;7</h2><h3 id="删除链表"><a href="#删除链表" class="headerlink" title="删除链表"></a>删除链表</h3><ol>
<li>一般来讲，需要删除头节点，创建一个dummy node 头节点是比较合适的。<ul>
<li>不需要删除头节点的题目，就没有必要创建dummy node</li>
</ul>
</li>
<li>删除链表中的节点，一般需要定位到目标节点的上一个节点<ul>
<li>但若不能定位到上一个节点，脑筋急转弯，将下一个节点的值复制到本届点，然后删除下一个节点（保证目标节点不是尾节点）</li>
</ul>
</li>
</ol>
<h2 id="12-8"><a href="#12-8" class="headerlink" title="12&#x2F;8"></a>12&#x2F;8</h2><ol>
<li><p>JDK1.7源码中，求大于等于一个数的最小2次幂</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">8</span>;<br><span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> (ans-<span class="hljs-number">1</span>)&lt;&lt;<span class="hljs-number">1</span>;<br>i |= i&gt;&gt;<span class="hljs-number">1</span>;<br>i |= i&gt;&gt;<span class="hljs-number">2</span>;<br>i |= i&gt;&gt;<span class="hljs-number">4</span>;<br>i |= i&gt;&gt;<span class="hljs-number">8</span>;<br>i |= i&gt;&gt;<span class="hljs-number">16</span>;<br><span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> i - (i&gt;&gt;&gt;<span class="hljs-number">1</span>);<br><br>System.out.println(res);  <span class="hljs-comment">//8</span><br></code></pre></td></tr></table></figure></li>
</ol>
<h2 id="12-10"><a href="#12-10" class="headerlink" title="12&#x2F;10"></a>12&#x2F;10</h2><p>赋值语句</p>
<p>A&#x3D;B   <strong>A有了新的值 是B</strong></p>
<h2 id="3-13-1"><a href="#3-13-1" class="headerlink" title="3&#x2F;13"></a>3&#x2F;13</h2><p>分割字串：相邻元素之间加逗号</p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/" class="print-no-link">#学习记录</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>算法学习记录</div>
      <div>http://example.com/2023/12/05/算法学习记录/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>dutsc</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2023年12月5日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2023/12/05/%E4%BB%8E%E9%9B%B6%E9%85%8D%E7%BD%AE%E5%90%88%E9%80%82%E7%89%88%E6%9C%AC%E7%9A%84CUDA%E5%AE%B9%E5%99%A8/" title="从零配置合适版本的CUDA容器">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">从零配置合适版本的CUDA容器</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2023/12/05/Docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" title="Docker学习笔记">
                        <span class="hidden-mobile">Docker学习笔记</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
  
  
    <article id="comments" lazyload>
      
  <div id="valine"></div>
  <script type="text/javascript">
    Fluid.utils.loadComments('#valine', function() {
      Fluid.utils.createScript('https://lib.baomitu.com/valine/1.5.1/Valine.min.js', function() {
        var options = Object.assign(
          {"appId":"znnF2Oz54UgHanY4ku1ECw1d-gzGzoHsz","appKey":"OusddZKdtXbjLqzj71mD9UUu","path":"window.location.pathname","placeholder":"说点什么","avatar":"retro","meta":["nick","mail","link"],"requiredFields":[],"pageSize":10,"lang":"zh-CN","highlight":true,"recordIP":false,"serverURLs":"","emojiCDN":null,"emojiMaps":null,"enableQQ":true},
          {
            el: "#valine",
            path: window.location.pathname
          }
        )
        new Valine(options);
        Fluid.utils.waitElementVisible('#valine .vcontent', () => {
          var imgSelector = '#valine .vcontent img:not(.vemoji)';
          Fluid.plugins.imageCaption(imgSelector);
          Fluid.plugins.fancyBox(imgSelector);
        })
      });
    });
  </script>
  <noscript>Please enable JavaScript to view the comments</noscript>


    </article>
  


          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
    <div class="statistics">
  
  

  
    
      <span id="leancloud-site-pv-container" style="display: none">
        总访问量 
        <span id="leancloud-site-pv"></span>
         次
      </span>
    
    
      <span id="leancloud-site-uv-container" style="display: none">
        总访客数 
        <span id="leancloud-site-uv"></span>
         人
      </span>
    
    

  
</div>

  
  
  
</div>
<div>
  <span id="timeDate">载入天数...</span>
  <span id="times">载入时分秒...</span>
  <script>
  var now = new Date();
  function createtime(){
      var grt= new Date("12/05/2023 10:00:00");//此处修改你的建站时间或者网站上线时间
      now.setTime(now.getTime()+250);
      days = (now - grt ) / 1000 / 60 / 60 / 24;
      dnum = Math.floor(days);
      hours = (now - grt ) / 1000 / 60 / 60 - (24 * dnum);
      hnum = Math.floor(hours);
      if(String(hnum).length ==1 ){
          hnum = "0" + hnum;
      }
      minutes = (now - grt ) / 1000 /60 - (24 * 60 * dnum) - (60 * hnum);
      mnum = Math.floor(minutes);
      if(String(mnum).length ==1 ){
                mnum = "0" + mnum;
      }
      seconds = (now - grt ) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum);
      snum = Math.round(seconds);
      if(String(snum).length ==1 ){
                snum = "0" + snum;
      }
      document.getElementById("timeDate").innerHTML = "本站已经运行&nbsp"+dnum+"&nbsp天";
      document.getElementById("times").innerHTML = hnum + "&nbsp小时&nbsp" + mnum + "&nbsp分&nbsp" + snum + "&nbsp秒啦~~";
  }
  setInterval("createtime()",250);
  </script>
</div>


  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script defer src="/js/leancloud.js" ></script>

  <script  src="/js/local-search.js" ></script>




  
<script src="/js/diy/love.js"></script>
<script src="/js/diy/xiantiao.js"></script>



<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
