<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>从零配置合适版本的CUDA容器</title>
    <link href="/2023/12/05/%E4%BB%8E%E9%9B%B6%E9%85%8D%E7%BD%AE%E5%90%88%E9%80%82%E7%89%88%E6%9C%AC%E7%9A%84CUDA%E5%AE%B9%E5%99%A8/"/>
    <url>/2023/12/05/%E4%BB%8E%E9%9B%B6%E9%85%8D%E7%BD%AE%E5%90%88%E9%80%82%E7%89%88%E6%9C%AC%E7%9A%84CUDA%E5%AE%B9%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="Configure-a-container-from-zero"><a href="#Configure-a-container-from-zero" class="headerlink" title="Configure a container from zero"></a><strong>Configure a container from zero</strong></h1><h2 id="一、文档目的"><a href="#一、文档目的" class="headerlink" title="一、文档目的"></a>一、文档目的</h2><p>​由于实验需要pytorch2.0和cuda&lt;&#x3D;11.8的实验环境，若使用pytorch NGC，最早支持pytorch2.0的容器版本是23.03-py3，但其中的CUDA_VERSION为12.1（<a href="https://catalog.ngc.nvidia.com/orgs/nvidia/containers/pytorch/layers">https://catalog.ngc.nvidia.com/orgs/nvidia/containers/pytorch/layers</a> 查看需注册NVIDIA账号）。经查阅CUDA Driver与CUDA Version的对应关系（<a href="https://docs.nvidia.com/cuda/cuda-toolkit-release-notes/index.html#id4">https://docs.nvidia.com/cuda/cuda-toolkit-release-notes/index.html#id4</a> ），在现有NSL服务器驱动版本470.74的条件下，支持的最新cuda版本为11.8。考虑到pytorch官网对pytorch2.0版本只提供了cuda11.7和cuda11.8的安装链接（<a href="https://pytorch.org/get-started/previous-versions/#linux-and-windows-1">https://pytorch.org/get-started/previous-versions/#linux-and-windows-1</a> ），于是本文选择cuda11.8+cudnn8.9.0（参照<a href="https://developer.nvidia.com/rdp/cudnn-archive">https://developer.nvidia.com/rdp/cudnn-archive</a> ）</p><h2 id="二、文件准备"><a href="#二、文件准备" class="headerlink" title="二、文件准备"></a>二、文件准备</h2><p>在 NSL1的 <code>/home/share/from_zero</code> 目录下准备好了cuda11.8和cdunn8.9.0的安装文件。这里附上下载链接，可以使用wget直接下载，也可以下载到本地，再使用xftp上传到服务器。</p><p>cuda：<a href="https://developer.download.nvidia.com/compute/cuda/11.8.0/local_installers/cuda_11.8.0_520.61.05_linux.run">https://developer.download.nvidia.com/compute/cuda/11.8.0/local_installers/cuda_11.8.0_520.61.05_linux.run</a></p><p>cudnn：<a href="https://developer.nvidia.com/downloads/compute/cudnn/secure/8.9.0/local_installers/11.8/cudnn-linux-x86_64-8.9.0.131_cuda11-archive.tar.xz/">https://developer.nvidia.com/downloads/compute/cudnn/secure/8.9.0/local_installers/11.8/cudnn-linux-x86_64-8.9.0.131_cuda11-archive.tar.xz/</a></p><h2 id="三、构建步骤"><a href="#三、构建步骤" class="headerlink" title="三、构建步骤"></a>三、构建步骤</h2><p>​本文选择在NSL1服务器上进行操作，如选择别的server，请确保已有ubuntu:20.04镜像。</p><ol><li>选择ubuntu:20.04镜像，run一个容器，如：</li></ol><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript">$ docker <span class="hljs-built_in">run</span> -<span class="hljs-keyword">it</span> <span class="hljs-comment">--gpus all --name myenv -w /workspace ubuntu:20.04 bash</span><br></code></pre></td></tr></table></figure><ol start="2"><li>将&#x2F;home&#x2F;share&#x2F;from_zero中的两个安装包拷贝到当前容器中</li></ol><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-variable">$ </span>apt install openssh-client -y<br><span class="hljs-variable">$ </span>scp username<span class="hljs-variable">@192</span>.<span class="hljs-number">168.1</span>.<span class="hljs-number">151</span><span class="hljs-symbol">:/home/share/from_zero</span> .<br><span class="hljs-comment"># 根据提示输入yes和密码，此处更换用户名</span><br></code></pre></td></tr></table></figure><ol start="3"><li>按照顺序执行以下命令</li></ol><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs applescript">$ cd from_zero<br>$ chmod +x cuda_11<span class="hljs-number">.8</span><span class="hljs-number">.0</span>_520<span class="hljs-number">.61</span><span class="hljs-number">.05</span>_linux.<span class="hljs-built_in">run</span><br><br><span class="hljs-comment"># 安装libxml2，按照指引选择地区和时区(6.Aisa &amp;&amp; 70 Shanghai)</span><br>$ apt install libxml2 -y<br><br><span class="hljs-comment"># 运行cuda安装程序</span><br>$ ./cuda_11<span class="hljs-number">.8</span><span class="hljs-number">.0</span>_520<span class="hljs-number">.61</span><span class="hljs-number">.05</span>_linux.<span class="hljs-built_in">run</span><br><span class="hljs-comment"># 出现报错如下</span><br>Failed <span class="hljs-keyword">to</span> verify gcc <span class="hljs-built_in">version</span>. See <span class="hljs-built_in">log</span> <span class="hljs-keyword">at</span> /var/<span class="hljs-built_in">log</span>/cuda-installer.<span class="hljs-built_in">log</span> <span class="hljs-keyword">for</span> details.<br></code></pre></td></tr></table></figure><ol start="4"><li>安装gcc，再次安装cuda</li></ol><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-comment"># Step 1: download model from huggingface</span><br>查看/var/log/cuda-installer.log<br>$ cat /var/log/cuda-installer.log<br>[<span class="hljs-built_in">INFO</span>]: Driver <span class="hljs-keyword">not</span> installed.<br>[<span class="hljs-built_in">INFO</span>]: Checking compiler version<span class="hljs-built_in">..</span>.<br>[<span class="hljs-built_in">INFO</span>]: gcc location: <br>[<span class="hljs-built_in">ERROR</span>]: Missing gcc. gcc is required <span class="hljs-keyword">to</span> continue.<br><br><span class="hljs-comment"># 发现缺少gcc，于是安装gcc</span><br>$ apt install gcc -y<br><br><span class="hljs-comment"># 再次运行安装程序</span><br>$ ./cuda_11.8.0_520.61.05_linux.<span class="hljs-built_in">run</span><br><br><span class="hljs-comment"># 跟随安装程序的指引进行安装</span><br><span class="hljs-comment"># 注意不要安装cuda driver，容器不需要安装cuda driver，直接使用server上的cuda driver</span><br></code></pre></td></tr></table></figure><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAi8AAAFuCAYAAABJOPgQAAAgAElEQVR4Ae2d67WrIBBG01PaSTH2Yi2Wkjq8axBwwAE1yT1Csn/clXNFXjNb+Xh6u91uM/+wAQzAAAzAAAzAQEcM4KyOnIXQRGzDAAzAAAzAgDTcz+eTf9gABmAABmAABmCgSQaMQYZFvBgBKDvUPQzAAAzAAAzAwKUMyACLoVEQL4ZRLENxjQcYBmAABmAABv6YAcTLHxscUcR6KhiAARiAARh4jwHEC+KFHgMMwAAMwAAMdMUA4gVguwKW3sp7vRXsh/1gAAa+gQHEC+IF8QIDMAADMAADXTGAeAHYroD9hh4DdaDnCwMwAAPvMYB4QbwgXmAABmAABmCgKwYQL/8R2PswrQf7TMN8V3nVwlDk7yly7If9YAAGYOC7GfioeLkP4zyFkwincR7ut/n2GOdn1nC7a+NjCQv3P5/zNA7zQ+KoRv52e8yj3JOnkdyj49znYcpOBz4cV6ez/VsExzTcs/Jt70vLX7BBKL9lnxDG73lbYzNsBgMwAANfz8DHxItr2CclPu6PeRy8QMnFgzTYQbyosLtcf47zQ4PnGvdpnvLr+h7zbxE9WVrmfQfEh4+HeDluq42Ae9P2pIftYQAGYAAGAgMfEi8VoWCNLBTEixTqMT6T0Y0gGOT6+DjjOKNM92GepmEexjCdMy2jQ1GcGCNHEuZEVTaao4SRlE0M6f4pMRaMbI4+hcbcso8LuyflHJMRHxldmuYxGelKp6Vi3iEffr++J4LPz7wfuBdeYKBnBj4jXrwo0Gs6olGsxrkiXkSsuFGZ0IBPi2hJrx+BriBenpLeMvWTpCl1ePqpLsn7/piHMRUEQUjFuhmCIEkzhFs22AlbRNxjWScjo1jeDkvefmrMEkohXX4RKzAAAzAAA1/KwGfEy9nGuSJe4noYMbgXFG4aSf99yBkl8aKmknS5XfrTPHhhYwmUI+LFHGXR+eRlt8KMuqZ5L+Ll3EjUEcHHPZbfuQYXMAADMNAWA82JFz1yof++3c422AXxokcrMuFwfwzzOMn6GpkCSqeUBNxUQKyOTBYqW4uLs3ySh8AKc+JFTUWFKSlZJ+TEzzJt5BZE52KI/9PTggEYgAEY+HIGPiNe3I4gNaKhjWY1znLNWLArDfO65sVPjYSG2/8e3+1zXrxoUSGCJN/hZIoXP0oShUSpvlo07dlH0izd7+IiXrSv+HsV0tgCW8AADPwCAx8SL35Uwtpt5ISNHsWQhah+UW7S0N9nJxjiQlgRHzrezpZjLQjc3yfFy31wu6PCup101Gd5GJZr6TqYOLXltnjfnfjKRU+8Z1PGbGpMha8izuf9GOchLlhGvPzCw0kdaYRgAAZgwGbgY+JFDJxMn4RzXqRBFmEQz16Rs1L8QlQRL2pkJTnnJRE2ofCGoFEN/uJkY8QmjGLkIxpZHnn5zTNnYj3WkaaH3r1kjNhIudZ71ngBSjtM7zaSM3C8zVx9ES/BdvyGZ4NfWIABGPgdBj4qXgDnd8DB1/gaBmAABmDgKgYQL5uRG2C8CkbyhT0YgAEYgIEjDCBeEC+syocBGIABGICBrhhAvABsV8AeUeTcQ88NBmAABr6bgY+IF0mEf5+zAQ/ddz90+Bf/wgAMwMB7DLQhXuLha8s5L8eE0Lprx21h/hMBtWzdTr5l9B/yBer3oMZ+2A8GYAAGvpuBdsRL6VTZHXEgh9YdFi9KJAnYy4m6nxsxOSa69vPjofvuhw7/4l8YgAEYeI+B3xMvSiTJ2Sk3d4jevqD4lDA5kg5Qvwc19sN+MAADMPDdDPy0eJHKy8cN15EbmRa6z49wiJ4s5vViR3+WIJ02kumr7GC88OkDN2qkP/YoaU9qfZCdHw/ddz90+Bf/wgAMwMB7DPy8eHGiJJ706z9HoEZn0pESe82LCCAtaPT/F3E0Lh97nMZZTu1d77XzA+r3oMZ+2A8GYAAGvpuBnxcv8QORYZQkERf5dJItXtI0ZCRGPmPw9B929H/7tTvpGh07PR66737o8C/+hQEYgIH3GPigePGjCO7clGwaxTfc6SiGEgYyzVIc7VD3GemkYqB+rxMZWT7bkZda2W2x8XQfk/QiRU8ZhW8q5WfJJCM92/yA+j2osR/2gwEYgIHvZuCD4mVHOBjCI4qZC8WLteZliB9fzOtUEi/L2hn5wKKeMnJfl87EUqyzs4ekh3jhJfPdLxn8i39hAAY+zcAPi5fl69bpbiNbTKyCoyxelqmjxzpl5MVaKo6Wr0MPYxBFdn6fdjLp8eKAARiAARj4JgZ+T7yoKZztOS+2mFimhbbgrwtvRYz4Q/PilJASKI97PIL//vCLdxl5iTb5pgeKumyfE2yCTWAABj7NQDvixYuKVBAEAWD9XnHCrlWOz1/7tJNJjxcHDMAADMDANzHQhniprYf5wbBvAoy68MKEARiAARj4NAOIlwbF0aedTHq8OGAABmAABr6JAcQL4oW1J2od1Dc93NSFxgoGYOBbGfiIePlW41AvHnwYgAEYgAEYaI+B7xUvatePbFc+Bt96Gq47vI4e+UG7HbUv9x3jEDthJxiAARioMfDd4qV0wu2OKJEPNR4XL9tD5p7P5TwYMfx9UFuj/beNVofc52EMH2qUA+7WLdXrPRbAywceJz/ltXwde7lv/cjk80QdJG6pLPX61ctplZ1r2AwGYAAGYOA9BhAvhpA5L15WsZIAeR/mcXzMd5+HExZKUMm28Cl8wVruVaInSScrY56OnFcz3FMQztVh+VikXRYRL4X6ZeWqlZmw1D/YA3vAAAzAwOsMIF6MBvhcw3+mcZdpqXA+jf57ceCxfLfxrAfgWFoBnG2aa/wz9Qvp8Wv5hGtwAQMwAAOfYQDx8hHxog+qq0z/yDqcMPIi3zwKf4cySLh85yn83/r18dbppuWTA2F0J8RdxccBUKplyaeNKvWzysu1uj+xD/aBARiAgdMMIF4MaE41/Hn8u4xiLB9qDEJi+c2uB8Egv2G66Kh4cemH9TGLuMjX6Jyqw5myFOt3QCTltuL/px/YlClsjj1gAAZ+kwHEi9GAnmr4jfi3jQgxBEYQDDr+Jp4B5cF4p+pwMM34kjhSTl0v/kakwAAMwAAMfJABxIthzFMNvxE/FS+GcHFxautMDNES83nM44HppnN1OFkWxAsvochjjVXCouDHXjwzMPBRBhAvBlCnGv7HMI9hx5CklUyriHApb7ve3W0kIyLGFNRj1OtObHFUrEMxzcLOp2r9aJxonGAABmAABv6eAcTLu+Lllp65Ime8xPNaZIRi8/mBsNtInF06W8WDUBAat5uMvqyLhOWcl7hg18gzOaSvmGapLJX6GbbjIf77hxibY3MYgIFfY+C7xYsXDknjXW1wl0W1YpR8AeyvgUF9eRnCAAzAAAy0ysD3ipeqSAHIVoGkXLAJAzAAAzCwxwDiBZHz0UVUe8ARzksJBmAABmDgXQYQL4gXxAsMwAAMwAAMdMUA4gVguwL2XbVOfHp8MAADMNA/A22IF7VDhsW1r0Ml26PFoe5ffhaM7DLKr22E27Lt+rgPXi8rLw9sBwMwAAMw8CoD7YiXTcNqnV8iu4HSLxwXzzPZNMwrJPdhdOenLI38uHyRWQRUXga5Jt8aUuJK4kzjMD+yrzi77csiHPI0CuWQM15c/kFshN+D8asOt+pySLysNsrTf83Oq5jKd29poZWH5Xkn/5evb2fbxJPwgr25p+xbbINtYAAGemOgYfEiB77JIW3ruSjLoW7hmz4LbGcbVXf/pMSHHCo3eIGSCwctXlTY3YmZtVzO6U4wTEl5j8GwFWTH4lUetkbES6hHzUe1sBB//Q0jQ4GB8P+KLRAzTAvCAAzAwNcx8GHxIo1JOjKyNjyVBsZqbD1sboRCRj8KIwfnGr/tMfixfFYZ5FoYeVHiReLkQiqUQ66fm3YpiBc1wiAjPfEQOrFLLUzCrbok9tuOakn5w0hQUn5JK4wKxd9MuO28GIJtoq3V/bWw7f1b/52LX2FQlWmbL/GwCQzAAAy0xEDz4iVOxxjH5IshTzVeSQOegWg1+BXxIvk6YeMavXUEIL2e5WE2kJZ4CenJCMM9E0q1MJ+fVZdYd4lf+mRBSHtb7lN2zupZi1sL2z4ooXyMvGxts/UZ92ATGICBb2WgA/GyjHI81fSRdsapxs9q1ENDa4VVxEvy8UURBqF8+u+QdvXXEC95GqEckk4tLORj1UXiTaNbLyKfE9A2XP8O4mD7wJ+ycyiH/63FrYWt5VLlkWk+veZFpvyy/Pi/she2gQ8YgIEvZOAj4kUaoO3UwvHFq+Y0RzC2b4iH0T6y/1TjZzXqWT7J9EwQDUY8V2cvAvTf7ntF05mpo4J40dNUOn8nQtQ0kg6r1cWJHllsLL4qTfu0Ll68rR5q5KXABQIGAQMDMAAD38vAR8TLCog0fp9c86IbU6ORPzttJB80LDXcJRGwu+ZlKWMu3o7voDHqVRtdqYXtiRcviOI6onB//NX2TqE/JRJjeksatbi1sJUrX5ZcuEk+4rfiSFJah016WTkJx14wAAMw0AcDTYsXN6KhRiDy/wtkpxq/cL+128gJGy285CvLfrQnETb3WbZar6MXhvhI7t8DwYgvX5t2ozcvrnnJBY400knDL3lao0Mh322Zne3zhcMHG/+aj4phrg5ZGd21aR6ykRfEy9ZfvICxCQzAwDcz0LB4sRrYbeNabPwqDat5zotv4Nf1FLKo9bHs8hExEnfaZOe8mELFEiSlB6lwb21HUS3M1/vhpofkLBk/RZSIFz9iEc/MWWyt6yh/J7uORNzFtSalaaesjpndkjRrYd4X06YMUm5Zu7OekSPrd5Kpvorfv/lBpm4Ze3DAOg8Y+GoGpD0x3ns311gbAdbN719TDVnaYNZeSGuDe3yKppYeYX/mb14q7z8z2BAbwgAM/DADbYiXH3YAggHRCAMwAAMwAAPnGEC8IJzovcAADMAADMBAVwwgXgC2K2DpnZzrnWAv7AUDMPCNDCBeEC+IFxiAARiAARjoioE2xAsLdruCZqvit7vAtvfQ+8EmMAADMAADn2GgHfGiznNZnLs0iOlOou224o9tlRYBlZdBroVD6kpbpaNa97uf8jRieOYwJdjECfLxxcc9u6cU939cV9uvP1meV/xTe7glPSmfK+MQTtpd7FYLq6WpP3S51J1PDlTt9T/4I83OOzAXvrtg5yfZkXe18Z66YKu01ei7Q8nWM0XyLzlLwc82ju5+65C6PfGiynd3wmMtlzOgiz+t3zjae6Cy/Mw099L4WLgXhfHwt9t8fwzz+IHvBp31jwGjBWjV7+fyDKNGQQiF//MyPuoL7oMVGICBv2agbfFy8x9llNGP/JA133Cfa6ikkc5ERxAAmZhwjpBrYeRFiRcJy4VUKIdcP3RWjZFfmqac8BtGGaZ5lFEGZ4NpOaRtGmN4MjqlRlBkNOfQAW5GWSKIud2ze6XeApH8S+ot96nRquVvbXujfsEXB36DvWM5VZxa2Pb+LRPn4vPS2toUm2ATGICB/8uAtCmGjRsZeXENkp+OyRtH31idamjyhlg1eObHIaUBLogXyXc9ln7trafXK87LRIA4QcddhIw/PdZ/SXkcwter1ZRakk4oh/VZgUpZxC4ydSUnCt/DCIS/P7dZkl9IM+Qb/r/+lvxj1u+xxjOgTEAtpRvsmAg67efN36Hsod7h/8fLsldWwrElDMAADHyWgQ7Eix99KYyY1BqxDSxmw+sNaoXJtYJ4ST4I6Bp/P6qg/940lMp5tfyMNFw9x3Ge/AhQHOHR4iKPF8pfK0cIcwJpHUWJozY6fbnXKnf8FpOqn0/X9E9ezlen/7I1L8HfZp6hntavF4dhpEhEXEiL361PsQk2gQEYuJqB9sWLbyzjRxKzxudUQ2U2vB5CK0yuFcSL5BtGXvTft0pDnjjbyC+m4xr39fs9oVF9TjJltEwFFcWLnt4y8kjKkNkyht0f7sOQbvTiv4kXo35i61KZsus1v9fCtunn633UBzmzPLdxeYFhExiAARi4goHGxYsewveNTLYj53xDpdddKOishr4iXpZpj2V6Rr4AHQVGYSfMxrlGfjHNXDCERlRdL4oXPUIVyh/in/kNcVWerg5GuWuCzfRPnuaZcvl7zXQPhG38YJUl1P2Fcm3SJ43DghTbqfcR3MANDFQZaFq8SAOlty/n/5eXXa0Rs16G7n5rt5F8NTl+ZVleIqoHnjTY91m+Sh2/1ryJV5payV5M1TSNBcGPcR5kzUtt5CWO+pxf8zImX2deROOybkTb5e4WKmufLDbWIjOtp/OZsXA4CjX/gMpuq+F/r3kRoZKvnXLXpnmIO60Wv4dRNYshrqU+xh7YAwZg4K8ZaFi8SKOZ7WCJjfMKylnxIgYW8SGNmBstkV07YTRH7dR5PqdlAas0riI0wv35mSyJCAnl0g1+uJb91tJ0DbrejSPnwMhi2j3xcnM7kkY/EhTXrRxQ8CIeok1cHf1i4bCQ2NV/mgcRbnFqavGRto38new6EnEXR6b0qJdRvwPlzH2R5JfZNAmTtC3xItcfYtd19MzZ+khZuKfaM/rrlxn5Ze8Y+ITPL2ZA3u/GM3/BbiMvDtKGr/Ywrg3n8Z0ltfQIM0Cw4ODaF78QYID3AAzAQA8MtCFeaAwQBDAAAzAAAzAAAwcZQLwcNFQPSpQy0mOCARiAARj4BQYQL4gXlD4MwAAMwAAMdMUA4gVguwL2F3oU1JGeMwzAAAzUGWhDvKhdIizYrTvsd4Aub7/+HRvAAr6GARiAAYuBdsRL3H4bHKXPGgnXtluQP7ZV2tryLNfCCbulrdJx5MbvftrUI5Q9+1WCTZwg25ofYct2TDOL0+j1V3wgML4azwL5nWtSDvGB80P2yYFaWDXPZNv9stW9en+jvqXMfTyD+Ak//RoDDYuXcC7HejZIfrCZOOtsA+jutw6p2xMvSpTImSjrIXX+oXHxp3nSJ9zWGqQsPzPNWvyGws76IDxkr8YL8T/9WytPLWxbjjBqxMcet7ahkcEmMAAD7zPQtni5+Y8yyuiHOqBNO/5coyKjI6sY0umYHxwUgRFGXpR4kXi5kArliMf274mLTLxs0lQ99+1hc/qAt2kew+mwuY1CHu66fBfpOT/lUL5xGWlIz8fJ0gwjED7NEEcO74uH+kn6akRq+Xu1r9gihmv77cQTW4Z4m2nEkl1q5dzzhQ8PPky4OBC2vX/LWS3tbfz3H2zSxIYwAAPfzIC0EUb9LjikTjduSWPjp2M2J7cuYJ5qFPLGXecTGvr8WkG8uAZWwtz9oae9jAQdOlreyG9NM6RnH/O/CKdwAu59fgz+77x+IQ+57kSbmooLYb6+SZr+K8tOOLi4cmruMoqwlnF9MRzxwfl4wQZrPus3lAy7HCinAXoCf60etbBtuqHsjLxsbaP9yd/YBwZg4DUGOhAvfvSlMGJyqlHJGuwEGitMrhXEixupCeIlioPtVFeSRy6McsEW8tPpSZxwXf7Ow3SaEqbTDHVS1+PIkLpmpRntmucX0lT5xnvVtU29T8cLAkCBbZXF8oGUw8hvU6asvLV61MLMdL0ADCNI0xCErqpPlr+ZDvckAhMbwQ8MwIAw0L548Y3QMD7ndJpjceCpRqXWoFlhcq0gXiTfMMKi/15HB3YAM/KL6WhhkTfEeZhu3PKwkIe6XhYvaoonTAVJ3VVc99IIaap8Sz5IviElaWphtbteqSBedBq6LAfKuffSK9VD4tXCtunKaOH2Y48Wv9u4O9wouxMXW8EADPwqA42LF92A+QYh25FzvlFZ12QkTtcNYWgg5FpBvCzTLMv0xaA+6rf2tMOUQeHhMvKLaUpDrEeaQjmkXHlYKGsIsxp31bAXxYuOdyRNdY/pA1/OZH1MlocZL6arfe9tmNc9t4tO37Bv4u+Yz+qfWnlqYZt0lb1jmC6rkXe8jzBGWmAABmBgl4GmxYs0GLq3nv9fXvinGpVwv7XbSL5+rBejyhesw2hP0hDe3Vep191GebyDUxbVNEPDbaztiIuFjTUvSR3ublGxs59qTE3xEtNcBZfsfhoeXiztiALnl3GY7/qBC0LDiU1VFnWPGS+GBxus4mId1TLsourohEBiX51G+e8aS8UwV8/sS9ru2nbkJYzUIVTKPsA22AYGYOAIAw2LFxEFWaMggmJKrxUbldgIbkFIpjNk900YzVE7WWRXjaxTcA2yNIRhKiU/k8VsJA1Bk5enlqbcq8pyeLeRF2dLWad5GMZF/KmGvSRenDDwu5Ak/jTuLAJO6vOYxzj6tI5sPWJ6qiy78Ra/a3vL33HXUckuqo4OfNMvWxbivcq/SX6Zn5Iw76dJly/U7yHrj9apuGjPEM7vbs/qyAuMewpMwxd8fTkD8i42nv/iYhjr5vevqQYiNlK7hl8bOdYS8AIzIH6fy10GsTt2hwEYgIErGGhDvNBI0NDCAAzAAAzAAAwcZADxctBQVyhL8qRHAwMwAAMwAANbBhAviBeUPgzAAAzAAAx0xQDiBWC7ApYeyLYHgk2wCQzAwK8x0IZ4+cEFu26bcNjhorcivyOm8h03hbRe2aH1aw8G9aUxgAEYgIF2GWhHvLzYgJ9qiEUkhePkXcNubcf+Y2dJmU7XXW9NrnyYsSBePv1AnvLBH5Xp03UkvT9+LuCEEVEYgIEKAz8sXhbhcvk269PiZTnrJpZbzj0Jh+sdHHn5dEOMeKFh/zRTpAdTMAADNQZ+VLxkAiCqOzlVd/IH0k3zOKwnzi6nu8q1cZZDycRw+vRaHS8eeufSraV58DTeWD778wBRPHjxEsqyOdxOTc9F8RPTrpUzC/NfmHYfPwy2iL/rIXXFwwBjnjyctYeTMPiAARiAAZuBHxQvgzulV048zaFYvi0UTpZdpmbWQ/MWwbOZ4hHB4E5YXYSOCAk9NVVP8wXxYo3UyLXwEcVYluVI/q1IsT+pUCtnEna7z49w8rAXIVE8aVHi7KJPL37MQ/4JAX0/f294zPnk//ZLDLtgFxj4PQZ+T7zI0feTjK6sIwQOfN/YPlQjmjbK208TmPG0uNhN83+IF1WvIGpUnaTMab0OjObkttpLT8Jd3fX3fX7v4eKFis9hAAZg4P8w8EHx4kcm3PTBtH4vKGvoTEfqBv/I/eqeTUOswjZ5qcZcRhP0CMnS2K7fonHTQlKXOEIj9TPqJY20XnCr6+Ia8Fqa/0G8lMqi7LKxWa2cef1UOsG+m/T8PffHMI/T5KfZDNsZaYU0+f0/Dzx2xa4wAAPfwMAHxcsbQOgG/2SDVmo4Teco8XJzX2BOP/iXiJBNOV4UL1pMbNJ8Qbw4oaFGV/RISh6W1Hf1z8ZmNYGSp2nUYZOeec8ru6rWMpv+NPLhPmwGAzAAA9/PwA+Ll2X6RE8fLWs71kW698c4D48AwQvi5Xab62mG6ZVUjNQfvGWEK65lyXcbvbXmxa77kTUvz3w9i5RLrY0RgbOOYgWb8lv3NfbBPjAAAzBgMfDT4mXZQfScoxC46V01z1kW9d5j7/418eLyiDuY8jQXKB8x/KiIqZ/zUtxt5Otij5Ts1D2WUZ0rE22jy7PWId9t9LjzEFoPIdfgAgZgAAbOMdCOePFbbdfdPXsVWc5pkQqs4mMvDuHygNjiBdvw8oABGIABGOiDgTbES+zB92G0vuEub6Huu16wg/9gAAZg4FcYQLz8jHBaR6o2Z9X8jA14sf3Ki416wjoMfDcDiBcabg5HgwEYgAEYgIGuGEC8AGxXwNKb+u7eFP7FvzAAA0cY+F7xImecdLEIeNn6XF2obJ6DcyDeC8LMbWl+5aDBF/I6Aij38CKDARiAARjIGfhu8bJ3QFyhwW1uN44pXv4HzLIuZt3qnMPC//+HzUkTrmAABmDgLAOIF0PA/Kx4OXCa7lnAuJ+XEgzAAAzAwKcZQLy8K1780frhYLjnU3/DR0Yy9P/95wD895LWKRr1mYJQHick5LtI0zyO6dH6tXjum01+uuz4rqJlCipMsy2/a7nzw+YGDptjnVDglF9YgAEYuIABxIth9FMjL15kjI/laH0nLOLHHJfPA+j1LCIu9P/DKb/2NUlzOZdlK0T217zkZdlVvtbIi78WBcv9MQ/5pwAMG+7mRRxeeDAAAzAAAy8ygHgxDHdevKh1Ivn6FPl/FDPWmhJDhOQiIk/TldmIl9fFjFcZvszzlfTctWkevDhDlFTsl9uf//NihgEYgIH/wgDixQDrtHjRC4M3gkEJlkTIhEbQECEiGKppSlwjnjv6f5ynMG0kvzodHyefFoqCxBIvkuZjmMdp8umu00kxnmFDwoJ/+YUFGIABGPg0A4gXo+H9rHgJU0fL9E86PSRAGyIkFxEbQVSPF6d4zHiVhyjP17RNuv7m00CSXsU/hj+wF/aCARj4RQYQL0aD8GnxcnMjLmNhG7IhXqKgObnmJYgPt6C2tFam8qCH+Nom92Eeh/Xr2mKbdRqskpZOg7//y7DpL76wqDPPHAzAgDCAeDEa1o+Ll5tMHT2zRt9f01M8T7WY1wkJa7dRPd5jnPzhfNM8DCdHSSzxkk9FTeP8YLcRYsR4bmhUaFRgAAb+ioHvFi9eGGynakqArcJgGpbdQ3/lCPIp+YTrsAEDMAADMJAy8L3ihZ4howMwAAMwAAMw8JUMIF4A+yvBppeS9lKwB/aAARj4JgYQL4gXxAsMwAAMwAAMdMUA4gVguwL2m3oO1IWeMAzAAAy8xsAXixdrC/JrRgIu7AYDMAADMAAD7TDQgHh5zOMkW4L9tuATx9Cf2tLMCAsjLDAAAzAAAzDwFQxcLF6W0ZG4LVkORMu/wlwBDfHSjgqmR4IvYAAGYAAG/oqBa8WLcShaFCQSNg3z4A9dm/SXjOXE2uxwt+dz/TiipBHCN2e8iEDyIz1Jmll+z0xE3Qf1zaBpnOMR/BVx9VdOJB9eGDAAAzAAA7/EwLXixfr2jjtK/+G/Ziwnzu6LEkAAABxCSURBVK5H5McRGi8YotAxBYS15iVcM9J0Qirkd5udAApfg/YiKwqW+2MetJgy8+dB+qUHibrCOwzAAAz8HQONi5d1NGX5PtAjmas7LV68CHkEsRGEkvzfCgtfZHZh0zycWI8DxH8HMbbG1jAAAzDwWwy0LV6CeBBxYYzSvCReSmmKQCmFyfd9HjLdNM2TX1gcR2GCEOI3EZa8SH7rRYK/8TcMwMBfMnCteMlHO9xHAKfZTQ/lYXqUxAuFl8SLWhuTjObsiBftFFn/8tRCB+GCcIEBGIABGICBP2PgWvFyq+w2cuIlrEG5z4/xuYgaBceyLmWY7+raKjLC+hathsO1wpoXLUj0SI8s8h0eMZ8l33QKa81X58ff2AUGYAAGYAAGPs3AxeJFHFo458WPhJi7jaJY0XHD+pj1y9BSufAv7jra2W0UhZAWL25EKN1t9LgD46dhJD2YggEYgAEYOMJAA+Kl4Kh8GicKlsL9hP/ZcN0RsLgHTmEABmAABv4XA4gXRA+iBwZgAAZgAAa6YgDxArBdAfu/VDzp0kOEARiAgX4YaFe8ICoQFTAAAzAAAzAAAwYDiBfDKKjvftQ3vsJXMAADMPB7DCBevHhx25/D7iS9ZdqfPSOGcv+yMB6a33to8Dk+hwEYgIFrGbhYvCznrkRhIALhQ+KgfoBdxejZFukE0FoYIzgMbcIADMAADMDAnzBwsXgJIkLOZgnntIRr7/0iXt6zXyLaeBj/5GHE5jALAzAAA8cYaFe8ZIfUPZ/TrL8nJEf0L98ZktGacQ2T0ZEwxRN/V2EkJ/XGcGuUpza6UgujgaeBhwEYgAEYgIE/YaBt8fIMnwe4zcmR/O7TAUqw3B/zMKafCTgy8pKkGYCrCZRaWIjP75+AS+/kWO8EO2EnGICBb2SgcfGyjpgkX5V24mWah4d8o8gG84h4SdIM6dQESi0sxOe36JOSr7huM4xdsAsMwAAM2Ay0LV70tE4mHO6PYR6nyU8dpVNK4uySeEmmm6wFwlk+CTi1MEQLogUGYAAGYAAG/oSBbsWLFhUiSPJdSqZ4yaebLDFiXQsw1sLCPfz+Cbja//xt90ywC3aBARj4Vgb6FC/yZejhMYcvQFtrV5Zr6TqYmxcvyxeh77NbvKtHd0R4hHssEVILs+7nGkIGBmAABmAABj7OwMXipXLOiwgFLSyyUY9k+mca50WQaJX9mMcp7Cxa1848xsnvNprmwRixEZW63rPGC+q1Fhbu4Vf7gb/hAQZgAAZg4LMMXCxePlsZ4MCeMAADMAADMPD9DCBeGM77+HAeL47vf3HgY3wMAzBwJQOIF8QL4gUGYAAGYAAGumIA8QKwXQF7pdInb3qaMAADMNAGA4gXxAviBQZgAAZgAAa6YgDxArBdAUuvp41eD37ADzAAA1cygHhBvCBeYAAGYAAGYKArBhAvANsVsFcqffKmpwkDMAADbTCAeEG8IF5gAAZgAAZgoCsGEC8A2xWw9Hra6PXgB/wAAzBwJQOIF8QL4gUGYAAGYAAGumIA8QKwXQF7pdInb3qaMAADMNAGA4gXxAviBQZgAAZgAAa6YgDxArBdAUuvp41eD37ADzAAA1cygHhBvCBeYAAGYAAGYKArBhAvANsVsFcqffKmpwkDMAADbTCAeEG8IF5gAAZgAAZgoCsGEC8A2xWw9Hra6PXgB/wAAzBwJQOIF8QL4gUGYAAGYAAGumIA8QKwXQF7pdInb3qaMAADMNAGA4gXxAviBQZgAAZgAAa6YgDxArBdAUuvp41eD37ADzAAA1cygHhBvCBeYAAGYAAGYKArBhAvANsVsFcqffKmpwkDMAADbTCAeEG8IF5gAAZgAAZgoCsGEC8A2xWw9Hra6PXgB/wAAzBwJQOIF8QL4gUGYAAGYAAGumIA8QKwXQF7pdInb3qaMAADMNAGA4gXxAviBQZgAAZgAAa6YgDxArBdAUuvp41eD37ADzAAA1cygHhBvCBeYAAGYAAGYKArBhAvANsVsFcqffKmpwkDMAADbTCAeEG8IF5gAAZgAAZgoCsGEC8A2xWw9Hra6PXgB/wAAzBwJQOIF8QL4gUGYAAGYAAGumIA8QKwXQF7pdInb3qaMAADMNAGA4gXxAviBQZgAAZgAAa6YgDxArBdAUuvp41eD37ADzAAA1cygHhBvCBeYAAGYAAGYKArBhAvANsVsFcqffKmpwkDMAADbTCAeEG8IF5gAAZgAAZgoCsGEC8A2xWw9Hra6PXgB/wAAzBwJQOIF8QL4gUGYAAGYAAGumIA8QKwXQF7pdInb3qaMAADMNAGA4gXxAviBQZgAAZgAAa6YgDxArBdAUuvp41eD37ADzAAA1cygHhBvCBeYAAGYAAGYKArBhAvANsVsFcqffKmpwkDMAADbTCAeEG8IF5gAAZgAAZgoCsGEC8A2xWw9Hra6PXgB/wAAzBwJQOIF8QL4gUGYAAGYAAGumIA8QKwXQF7pdInb3qaMAADMNAGA4gXxAviBQZgAAZgAAa6YgDxArBdAUuvp41eD37ADzAAA1cygHhBvCBeYAAGYAAGYKArBhAvANsVsFcqffKmpwkDMAADbTCAeEG8IF5gAAZgAAZgoCsGEC8A2xWw9Hra6PXgB/wAAzBwJQOIF8QL4gUGYAAGYAAGumIA8QKwXQF7pdInb3qaMAADMNAGA4gXxAviBQZgAAZgAAa6YgDxArBdAUuvp41eD37ADzAAA1cygHhBvCBeYAAGYAAGYKArBhAvANsVsFcqffKmpwkDMAADbTCAeEG8IF5gAAZgAAZgoCsGEC8A2xWw9Hra6PXgB/wAAzBwJQOIF8QL4gUGYAAGYAAGumIA8QKwXQF7pdInb3qaMAADMNAGA4gXxAviBQZgAAZgAAa6YgDxArBdAUuvp41eD37ADzAAA1cygHhBvCBeYAAGYAAGYKArBhAvANsVsFcqffKmpwkDMAADbTCAeEG8IF5gAAZgAAZgoCsGEC8A2xWw9Hra6PXgB/wAAzBwJQOIF8QL4gUGYAAGYAAGumIA8QKwXQF7pdInb3qaMAADMNAGA4gXxAviBQZgAAZgAAa6YgDxArBdAUuvp41eD37ADzAAA1cygHhBvCBeYAAGYAAGYKArBhAvANsVsFcqffKmpwkDMAADbTCAeEG8IF5gAAZgAAZgoCsGEC8A2xWw9Hra6PXgB/wAAzBwJQOIF8QL4gUGYAAGYAAGumIA8QKwXQF7pdInb3qaMAADMNAGA4gXxAviBQZgAAZgAAa6YgDxArBdAUuvp41eD37ADzAAA1cygHhBvCBeYAAGYAAGYKArBhAvANsVsFcqffKmpwkDMAADbTCAeEG8IF5gAAZgAAZgoCsGEC8A2xWw9Hra6PXgB/wAAzBwJQOIF8QL4gUGYAAGYAAGumIA8QKwXQF7pdInb3qaMAADMNAGA4gXxAviBQZgAAZgAAa6YgDxArBdAUuvp41eD37ADzAAA1cygHhBvCBeYAAGYAAGYKArBhAvANsVsFcqffKmpwkDMAADbTCAeEG8IF5gAAZgAAZgoCsGEC8A2xWw9Hra6PXgB/wAAzBwJQOIF8QL4gUGYAAGYAAGumIA8QKwXQF7pdInb3qaMAADMNAGA4gXxAviBQZgAAZgAAa6YgDxArBdAUuvp41eD37ADzAAA1cygHhBvCBeYAAGYAAGYKArBhAvANsVsFcqffKmpwkDMAADbTCAeEG8IF5gAAZgAAZgoCsGEC8A2xWw9Hra6PXgB/wAAzBwJQOIF8QL4gUGYAAGYAAGumIA8QKwXQF7pdInb3qaMAADMNAGA4gXxAviBQZgAAZgAAa6YgDxArBdAUuvp41eD37ADzAAA1cygHhBvCBeYAAGYAAGYKArBhAvANsVsFcqffKmpwkDMAADbTCAeEG8IF5gAAZgAAZgoCsGEC8A2xWw9Hra6PXgB/wAAzBwJQOIF8QL4gUGYAAGYAAGumIA8QKwXQF7pdInb3qaMAADMNAGA4gXxAviBQZgAAZgAAa6YgDxArBdAUuvp41eD37ADzAAA1cygHhBvCBeYAAGYAAGYKArBhAvANsVsFcqffKmpwkDMAADbTCAeEG8IF5gAAZgAAZgoCsGEC8A2xWw9Hra6PXgB/wAAzBwJQOIF8QL4gUGYAAGYAAGumIA8QKwXQF7pdInb3qaMAADMNAGA4gXxAviBQZgAAZgAAa6YgDxArBdAUuvp41eD37ADzAAA1cygHhBvCBeYAAGYAAGYKArBhAvANsVsFcqffKmpwkDMAADbTCAeEG8IF5gAAZgAAZgoCsGEC8A2xWw9Hra6PXgB/wAAzBwJQOIF8QL4gUGYAAGYAAGumIA8QKwXQF7pdInb3qaMAADMNAGA4gXxAviBQZgAAZgAAa6YgDxArBdAUuvp41eD37ADzAAA1cygHhBvCBeYAAGYAAGYKArBhAvANsVsFcqffKmpwkDMAADbTCAeEG8IF5gAAZgAAZgoCsGEC8A2xWw9Hra6PXgB/wAAzBwJQOIF8QL4gUGYAAGYAAGumIA8QKwXQF7pdInb3qaMAADMNAGA4gXxAviBQZgAAZgAAa6YgDxArBdAUuvp41eD37ADzAAA1cygHhBvCBeYAAGYAAGYKArBhAvANsVsFcqffKmpwkDMAADbTCAeEG8IF5gAAZgAAZgoCsGEC8A2xWw9Hra6PXgB/wAAzBwJQOIF8QL4gUGYAAGYAAGumIA8QKwXQF7pdInb3qaMAADMNAGA4gXxAviBQZgAAZgAAa6YgDxArBdAUuvp41eD37ADzAAA1cygHhBvCBeYAAGYAAGYKArBhAvANsVsFcqffKmpwkDMAADbTCAeEG8IF5gAAZgAAZgoCsGEC8A2xWw9Hra6PXgB/wAAzBwJQOIF8QL4gUGYAAGYAAGumIA8QKwXQF7pdInb3qaMAADMNAGA4gXxAviBQZgAAZgAAa6YgDxArBdAUuvp41eD37ADzAAA1cygHhBvCBeYAAGYAAGYKArBhAvANsVsFcqffKmpwkDMAADbTCAeEG8IF5gAAZgAAZgoCsGEC8A2xWw9Hra6PXgB/wAAzBwJQOIF8QL4gUGYAAGYAAGumIA8QKwXQF7pdInb3qaMAADMNAGA4gXxAviBQZgAAZgAAa6YgDxArBdAUuvp41eD37ADzAAA1cygHhBvCBeYAAGYAAGYKArBhAvANsVsFcqffKmpwkDMAADbTCAeEG8IF5gAAZgAAZgoCsGEC8A2xWw9Hra6PXgB/wAAzBwJQOIF8QL4gUGYAAGYAAGumIA8QKwXQF7pdInb3qaMAADMNAGA4gXxAviBQZgAAZgAAa6YgDxArBdAUuvp41eD37ADzAAA1cygHhBvCBeYAAGYAAGYKArBhAvANsVsFcqffKmpwkDMAADbTCAeEG8IF5gAAZgAAZgoCsGEC8A2xWw9Hra6PXgB/wAAzBwJQOIF8QL4gUGYAAGYAAGumIA8QKwXQF7pdInb3qaMAADMNAGA4gXxAviBQZgAAZgAAa6YgDxArBdAUuvp41eD37ADzAAA1cygHhBvCBeYAAGYAAGYKArBhAvANsVsFcqffKmpwkDMAADbTCAeEG8IF5gAAZgAAZgoCsGEC9fCex9HqZpHu5/p5DvwzQLTM/nX+Qr9XvO4+Ng/e7DPE3DfP9KXx+0Qaj7Y5yfp2zx9yz9Ws92fXaeJ31z0veBgUO/P+L308/D/7R5Je0mynnyvXuIs0qdd+J/RrxYhpVr4+OcktONjMR3jaE0iM95Gof58YeN8eEXqC/n2pA+5lHKfbbuO446XB6XzskXzyu+SsordR7nR3JtgVJezNNwr3NQ8buIoWl4vCc8dPpGGcW2h8pZiLvxTcau4/iUYHj9gd6UJS+zlO1UWU6yFPMz4r1pl4/6qFbOGPaCH+7DPE7LO+v0e+u0b/bL97rNDP8dskstnn83mvzV4u3X0+a+lp9P8z/Y3C7Lq3X423K+zsub9TvEVpqHPF+GrW9OMBgB1s3zzQJArp1swB/jc23osjTv8v9CA3m4nC8YaDdtVy4lVh7jPE3T6brv5nOq7CdfBC/4KimviIOCb448DDW/3+4PN8qyK4Bq9rlCvJgv6PThS2xYK/8nw7Lnar8MJ1mKZTXinc47tdcRlvbrk6Z5uxnljHXI7937vzSW0zw8VrF+fwzzOBzsxL1pH6vur9vsVbtU4rn6TYV3RSXeq/6o5ud9+R9sbvnh7Wt/VM7Xedl7Nj4f/v/Fi284hnGZVpARFHv4Puu9G85KGjnVw1nTLD0A4aWyTB+EsnxkisOVc5zHaRl5eIzTPAxKuJnlFEf6MunRJEkrCr77rMs57o1eJA94yQ4FgJJ8rXtKZZF81l6mG2EI00aSpho5W/62Rmf2/e7EsbeLPFwh3XW0y5fZiahl6moc1QhDxmDi98PltOxSuCZpVsSLcLz6+TYLM06cZeVcuV7ycfGCTXX6WbykfsJFyS4JM4W6vNy4GwzW7FKrw66PSnxKnZZyjMM4T5btXq6fYa9a/Zyta+W82Z3A3XhZmkE47drMKH/Cg+G/JLwUvxwvNIzC8ebZ/aQffDmL+RWfh/o7+eXnT+rm2z95Nsfgoz3fFstZsr2/Xmpzsmcseb/s8LL33g2jjUmaWX75e+mePJPj6WUO0g4YovCDIy/eAYvD7rMAYPWiA2ixMMaLwBnQNWLygMgDID2cNE3zwXBlGOdHUpZlqkA3Ii7veM8OIOFB9uV8DALlYx6lUZFrO+WUvPKy6v8vdvLTJXdJ13rgS2Usv0CifUP55TeW105vtyzBvjpN//fGr9k9m/CN3xdfp8wE/+vyhmsrE1FARJ8uPeKVozX+phy6nDH+er9pxxBnU4c8XijrYvu4Hifms9YhrfeaTlKHJF7OdchrTTPaJZS3+ivxP7SOqWaXah2Wepd8VOdzqf+5Ons7xzKtdq/63d/vpjnvC2v6/no5y+KlFi8Jk3dhNsVaspkul/33B/3u+Aoc5nwesO1ZP1TzC+WwnwexpxZW+f+DrY4/f8t7fp36Tn2U+C95z9fLGcqx/d3Gi++QaMe17jHMvwPqvIS0tc/CNSPNJL/M7y5MCRYZYS8ObOj81r//SLyoHrfZUBYUr+5dinFDXF/xuMYiXE/WLqg0Q7gVL88jGnw10hYQFSZpSxoSb/I96Fp+cWRF1ceBo0Yg8nIm9VJ5e+C25ROgTjQ4obxWekfKYtwTylR/GJSPQt5SltBD9r/5A7b0ptOXzDK6kHEWfJuXL/gs5LlnXxc/y0/FDXWNv0YdbJE8OWbiwmqrnJoXnaeugxXvRN1juXX68e+TLMV4Bqc1u9Tq4NM0WcrjbXwZXq5GeWpllTCX9gm/uzjS0VhHB2NPdLecBfFSi2eE5b40bbZXbxf+Qb9HW/rn80C5k3q4+8/6QU1l6/z031Iu/RyF/8dnTr2TnU0UQzpeLc08TKdjhEV/5WE6P51G/rcVL9SnFubTifnn6br/G89SLU0rLHkvpVOsic/N/JX9b8UBlmKANUyzBUAyFmOL0aQCocDhuv5/uBYMHAptOEsMu5tmyM8NnS1iIjokhFXyOGvAFX7l2MN1Vw9HiCNlc07Pp2PSqYZ6OU++eHTewTbh90hZ3D1KOIS4m4YkhS8you5f7bnca691UrYOcWu+rYX5+JGRkN47vwa7W38tdUhEzU45k2FWEXbhOarFq4UdquNJlmpp1uxyoJymjyReJnad+I3vkw+Wv1Y3K0yv19otp9GQSpq1eLnNjDKYNjPus/k80QHaSVPKsbJuPL878bfly94lWfxifrnNNkwW3snuXaamHl99/nQ5z/h2U85C/Wv1q4X5ctV5MfxWS7MWJvaU9WDS4XfP73nWGhh5KbxcDGctQ2x3/0CrxlLujS+rBT5ZdzLIMNw4zEMYCtwx5tkHxN1vlDM2ypKfXsialHOBbxmWXKa+4nBlXk4N/KG/CzYtxTXKFW1xpCx5PVU+5YehUEbDntHvMd3CQ5Tb+kjj7tMsl7PwkohlMcKNOkR7qvyewuYk040+jdyO2i8+LI7S6DxyH+VhJbvU6hDDCn6K4Ub9S2G6XPk9tTr4e00f5fHydP/DWorcl9X/Bx/ulrMiXgLHed0kTe3bPHyv82Dcv9blg353Pth2xrYjqidY2i17Ib/cZgaTxXfyU01z6Hi5b/Owko/yeLpOB8q5+krZzYoX2sZamM/bfMZiuQ6+d3V+ml1tl5jmUnbpmMXOWBZm1vNjIy+bxaeyQMmvbXEGkyE/Y05MClmqUHL9PrvKRQiCEa00l7BnXEArEKvhyj1jxvIqIGrGTMrp48g158BaOfW942arcd5gywjEEBq5WnlcmOR7QsnG8tp13i1L/lCo8snDII30ZpG2ZTeJZ12Xa8GHsX75MPLW1vFhkPLt+L1YTsnvE0womyzpKSZD3WI+BtfBxm6B9yJ2j9WvYhddpuLfJ1kqplPwbbj/DR/V+Xyj/NEf9nOxeanKaO+ot/Uvtg+NdL2cgTPVKfO2qcVbwkKe6XoKKV+V62B78/cNu23Skw5l9j6ynvNNPG/3s37YtEeavcUnuj2Kz1HIX8o2Zu/kl5+/I2te5Hlf6rq+5w+UM5Q3+d3GC/yt7zHj/RLyL72vXXhIWz8P4ZqRZu2ZlmdFrc9aOD24K8+X9TMjL5KYWuEsq4rjAiVfgbDaOs4B+wLIwxd7nv6ac6RrsFb1LPGSc15Ufnma2hDu79Bw1YwZ8naQFsoU7tG/1kPo4PeOqJRzAVYebGtKSK9Ql3NuwgtKg1P6W4DKXha6zPnfma3jmpOgoJPV8kZZnM22L91Yv7gjab2n6vfgr1jO5QGZhmGxVTZNEPnxvnMr+o3dRlFAWT6TF55RTleHV5jIyriKr/Cwr76LjEo+k4wU2jvzZFfS4hu/oy3Yyccr1q9kl2jftSyLz/T/T7JUS9PkTIm4UB9J45SPas/KG+U/63cRC3JUgvJ9+tzWyrnYfPXx+qy4NV7R9/nzp9PMd7JImhWua7765IhVyZe5oCmV56wf9vLbfR7sd/Lqm5PPX/L+zH2k/Zf5drec+jlVf5faHEmv8n4pv6+9PRTX8h7S793w7kzaYp9f6b2UTIPLYIPeeVtiQV3/nHhRiSYvwLwC+r5amL6Pv6MyT2xbtMsbL+ximurhePeev/C7vMCi+Ppg2d+tey3+X9illr8Z1jhLZpk78XfTZcfvx961HbHW5PvldftdK16afnhfN+r10P/mi0eU/LImJN0+f70/DrLU5MvlN1nqhpn/9g7F71/HQJPvl4PvRoNzxIthlK+D9mfqKC/cZaoxGb7spf5f9nLhOXr9xYztsN3HGfiy98v/Fy+9NByU8+TUFC+Xj79cYBAGYQAGYOAQA4gXQDkECg01Yg0GYAAGYKAVBhAviBfECwzAAAzAAAx0xQDiBWC7ArYV1U856IHCAAzAwHUMIF4QL4gXGIABGIABGOiKAcQLwHYFLD2d63o62B7bwwAMtMIA4gXxgniBARiAARiAga4YQLwAbFfAtqL6KQc9UBiAARi4joGqeJFA/mEDGIABGIABGICB1hgwxON1asooDCMDjA7BAAzAAAzAAAzsMYB4QUTBAAzAAAzAAAx0xUBXhd1TYoSj1mEABmAABmDgyxn4B+D6zBhC6woXAAAAAElFTkSuQmCC" alt="img"></p><p>​ 选择install进行安装。</p><ol start="5"><li>添加环境变量</li></ol><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-variable">$ </span>vim ~/.bashrc<br><br><span class="hljs-comment"># 在最后加入这两行</span><br>export <span class="hljs-title class_">PATH</span>=<span class="hljs-variable">$PATH</span><span class="hljs-symbol">:/usr/local/cuda/bin</span><br>export <span class="hljs-title class_">LD_LIBRARY_PATH</span>=<span class="hljs-variable">$LD_LIBRARY_PATH</span><span class="hljs-symbol">:/usr/local/cuda/lib64</span><br><br><span class="hljs-comment"># 使其生效</span><br><span class="hljs-variable">$ </span>source ~/.bashrc<br><br><span class="hljs-comment"># 验证安装成功</span><br><span class="hljs-variable">$ </span>nvcc -V<br></code></pre></td></tr></table></figure><ol start="6"><li>安装cudnn（其实就是解压，复制部分文件到cuda的相关目录下）</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">解压安装包 这里我已解压完成</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">复制文件到相应目录</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">cp</span> from_zero/cudnn-linux-x86_64-8.9.0.131_cuda11-archive/include/cudnn.h /usr/local/cuda/include/</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">cp</span> /workspace/from_zero/cudnn-linux-x86_64-8.9.0.131_cuda11-archive/lib/libcudnn* /usr/local/cuda/lib64</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">chmod</span> a+r /usr/local/cuda/include/cudnn.h</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">chmod</span> a+r /usr/local/cuda/lib64/libcudnn*</span> <br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">cp</span> /workspace/from_zero/cudnn-linux-x86_64-8.9.0.131_cuda11-archive/include/cudnn_version.h /usr/local/cuda/include</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看cudnn版本</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">cat</span> /usr/local/cuda/include/cudnn_version.h | grep CUDNN_MAJOR -A 2</span><br></code></pre></td></tr></table></figure><ol start="7"><li>安装对应版本的pytorch2.0</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">竟然没有安装python，那么安装一下</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">apt install python3</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">apt install python3-pip</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">配置软连接</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">ln</span> -s /usr/bin/python3 /usr/bin/python</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">apt-get install python3-pip -y</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">运行pytorch官网安装脚本</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">pip install torch==2.0.0+cu118 torchvision==0.15.1+cu118 torchaudio==2.0.1 --index-url https://download.pytorch.org/whl/cu118</span><br></code></pre></td></tr></table></figure><p>至此，所有的步骤完成，笔者在myenv容器中clone一个nanoGPT仓库，可以正常运行flashattention的实验。</p><h2 id="四、说明"><a href="#四、说明" class="headerlink" title="四、说明"></a>四、说明</h2><p>​当需要一个容器时，首先考虑NVIDIA NGC。当NGC无法满足要求时，按照本guide，理论上来说可以自行选择cuda版本，选择的时候需要注意以下几个条件：</p><ol><li>cuda版本适配cuda driver版本：<a href="https://docs.nvidia.com/cuda/cuda-toolkit-release-notes/index.html#id4">https://docs.nvidia.com/cuda/cuda-toolkit-release-notes/index.html#id4</a></li><li>cuda版本适配cudnn版本：<a href="https://developer.nvidia.com/rdp/cudnn-archive">https://developer.nvidia.com/rdp/cudnn-archive</a></li><li>pytorch（tensorflow）版本适配cuda版本</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>环境配置</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法学习记录</title>
    <link href="/2023/12/05/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    <url>/2023/12/05/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<h1 id="算法学习记录"><a href="#算法学习记录" class="headerlink" title="算法学习记录"></a>算法学习记录</h1><blockquote><p>本文档按照时间 记录了笔者写算法题的随笔</p><p>更多题解分享与思路交流可移步笔者leetcode主页：<a href="https://leetcode.cn/u/dutsc/">https://leetcode.cn/u/dutsc/</a></p></blockquote><h2 id="十一假期"><a href="#十一假期" class="headerlink" title="十一假期"></a>十一假期</h2><p>子序列，子串类型的动态规划</p><p>滑动窗口</p><p>HashSet</p><p>优先队列（堆，可传比较器）</p><p>单调队列（滑动窗口的最大值）（用双端队列实现Deuqe）</p><p>用map统计元素出现的频率 <code>map.put(num,map.getOrDefault(num,0)+1);</code></p><p>往优先队列中传入比较器，注意比较器也要有泛型(使用匿名内部类)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java">Queue&lt;Map.Entry&lt;Integer,Integer&gt;&gt; pq = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;&gt;(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Comparator</span>&lt;Map.Entry&lt;Integer,Integer&gt;&gt;()&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(Map.Entry&lt;Integer,Integer&gt; e1,Map.Entry&lt;Integer,Integer&gt; e2)</span>&#123;<br>        <span class="hljs-keyword">return</span> e1.getValue() - e2.getValue();<br>    &#125;<br>&#125;);<br><span class="hljs-comment">//Map.Entry中第一个存放num数值，第二个存放num出现的频率。</span><br><span class="hljs-comment">//优先队列实现一个小顶堆，按照出现的频率排序</span><br><span class="hljs-comment">// 完全可以使用数组int[]代替</span><br><br><span class="hljs-comment">//若存入优先队列的值是Double类型，需要使用内置的Double.compare()方法来作为compare的返回值</span><br></code></pre></td></tr></table></figure><p>编辑距离  dp</p><h2 id="10-8"><a href="#10-8" class="headerlink" title="10&#x2F;8"></a>10&#x2F;8</h2><p>优先队列题目优化，改用大顶堆，找到出现频率前k高的元素然后再poll</p><p>lambda表达式的写法，比比较器方便</p><p>深度优先搜索 dfs   ‘X’ ‘O’变化   <strong>标记法</strong></p><h3 id="集合的时间复杂度"><a href="#集合的时间复杂度" class="headerlink" title="集合的时间复杂度"></a>集合的时间复杂度</h3><ul><li><p>ArrayList     查 O（1） 增  末尾0（1）中间0（n）    删0（n）</p></li><li><p>LinkedList    查 O（n） 增 末尾0（1）中间0（n） 删0（1）<br>因为增加到中间，要先查询到增加的位置，故增加到中间时间复杂度为O(n)</p></li><li><p>Set集合有三个常见的实现类：HashSet，TreeSet，LinkedHashSet。<br>简单的说，如果你关注性能，应该使用HashSet；<br>如果你需要一个有序的Set集合，应该使用TreeSet；<br>如果你需要一个Set集合保存了原始的元素插入顺序，应该使用LinkedHashSet。</p><ul><li><p>HashSet 是基于散列表实现的，元素没有顺序；add、remove、contains方法的时间复杂度为O(1)。(contains为false时，就直接往集合里存)<br>总结：查 0（1） 增 0（1） 删0（1）</p></li><li><p>TreeSet是基于树实现的（红黑树），元素是有序的；add、remove、contains方法的时间复杂度为O(log (n))(contains为false时，插入前需要重新排序)。</p><p>总结：查 0（log n） 增 0（log n） 删0（log n）</p></li><li><p>LinkedHashSet介于HashSet和TreeSet之间，是基于哈希表和链表实现的，支持元素的插入顺序；基本方法的时间复杂度为O(1)；</p><p>待定<br>总结：查 0（1） 增 0（1） 删0（1）</p></li></ul></li><li><p>map集合有三个常见的实现类：HashMap，TreeMap，LinkedHashMap。</p><ul><li>TreeMap基于红黑树（一种自平衡二叉查找树）实现的，时间复杂度平均能达到O(log n)。</li><li>HashMap是基于散列表实现的，时间复杂度平均能达到O(1)。正常是0(1)到0（n） jdk1.8添加了 红黑树 是 0（log n）</li><li>TreeMap的get操作的时间复杂度是O(log(n))的，相比于HashMap的O(1)还是差不少的。</li><li>LinkedHashMap的出现就是为了平衡这些因素，能以O(1)时间复杂度查找元素，又能够保证key的有序性</li></ul></li></ul><h2 id="10-9"><a href="#10-9" class="headerlink" title="10&#x2F;9"></a>10&#x2F;9</h2><p>并查集基础题</p><p>并查集困难题，应用没做出来？？</p><p>每日一题，不会做</p><h2 id="10-13"><a href="#10-13" class="headerlink" title="10&#x2F;13"></a>10&#x2F;13</h2><p>做了一些基础的模拟题，贪心题</p><p>String的valueOf方法   将基本数据类型转换成字符串型的方法</p><p>String 类别中已经提供了将基本数据型态转换成 String 的 static 方法 ，也就是 String.valueOf() 这个参数多载的方法 </p><h4 id="拓展：将String转为基本数据类型"><a href="#拓展：将String转为基本数据类型" class="headerlink" title="拓展：将String转为基本数据类型"></a>拓展：将String转为基本数据类型</h4><p>要将 String 转换成基本数据型态转 ，大多需要使用基本数据型态的包装类别 </p><p>　　比如说 String 转换成 byte ，可以使用 Byte.parseByte(String s) ，这一类的方法如果无法将 s 分析 则会丢出 NumberFormatException </p><p>（1）byte : Byte.parseByte(String s) : 将 s 转换成 byte </p><p>（2）Byte.parseByte(String s, int radix) : 以 radix 为基底 将 s 转换为 byte ，比如说 Byte.parseByte(“11”, 16) 会得到 17 </p><p>（3）double : Double.parseDouble(String s) : 将 s 转换成 double </p><p>（4）float : Double.parseFloat(String s) : 将 s 转换成 float </p><p>（5）int : Integer.parseInt(String s) : 将 s 转换成 int </p><p>（6）long : Long.parseLong(String s)</p><p>上述方法都可以忽略字符串中的前导0，直接转化为去除前导零的数字</p><h4 id="putIfAbsent-k-v"><a href="#putIfAbsent-k-v" class="headerlink" title="putIfAbsent(k,v)"></a>putIfAbsent(k,v)</h4><p>如果key不为空，就不插入新值了</p><p>若key不为空，则返回旧的value；若key为空，则返回null（返回旧的value）</p><h4 id="computeIfAbsent"><a href="#computeIfAbsent" class="headerlink" title="computeIfAbsent"></a>computeIfAbsent</h4><blockquote><p>putIfAbsent()中没有计算方法，直接给出value，而computeIfAbsent()中可以有value的计算方法（函数），也可以使用lambda表达式</p></blockquote><p> java8之前。从map中根据key获取value操作可能会有下面的操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Object</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> map.get(<span class="hljs-string">&quot;key&quot;</span>);<br><span class="hljs-keyword">if</span> (key == <span class="hljs-literal">null</span>) &#123;<br>    key = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>    map.put(<span class="hljs-string">&quot;key&quot;</span>, key);<br>&#125;<br></code></pre></td></tr></table></figure><p>java8之后。上面的操作可以简化为一行，若key对应的value为空，会将第二个参数的返回值存入并返回</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Object</span> <span class="hljs-variable">key2</span> <span class="hljs-operator">=</span> map.computeIfAbsent(<span class="hljs-string">&quot;key&quot;</span>, k -&gt; <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>());<br></code></pre></td></tr></table></figure><p>如果v已经计算好了，那么适合使用putIfAbsent(k, v)，如果v还未计算，同时计算需要一些耗时,那么建议使用computeIfAbsent，将获取v值的计算放到lambada表达式体内，这样只有再map不含有k对应值时才会进行获取v值的计算，可以优化性能</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MapInfo</span> &#123;<br> <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">computeIfAbsent</span><span class="hljs-params">()</span>&#123; <span class="hljs-comment">// jdk1.8新特性哦</span><br>        HashMap&lt;String&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&amp;lt;&gt;();<br>        map.put(<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;is map&quot;</span>);<br>        map.put(<span class="hljs-string">&quot;2&quot;</span>,<span class="hljs-string">&quot;contains a mapping&quot;</span>);<br>        map.put(<span class="hljs-string">&quot;3&quot;</span>,<span class="hljs-string">&quot;specified&quot;</span>);<br>        map.put(<span class="hljs-string">&quot;4&quot;</span>,<span class="hljs-string">&quot;inappropriate&quot;</span>);<br>        map.computeIfAbsent(<span class="hljs-string">&quot;5&quot;</span>, MapInfo::apply);<br>        System.out.println(map.get(<span class="hljs-string">&quot;5&quot;</span>));<br>    &#125;<br> <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title function_">apply</span><span class="hljs-params">(String v)</span> &#123;<br>        <span class="hljs-type">return</span> <span class="hljs-variable">v</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;is 5&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="10-16"><a href="#10-16" class="headerlink" title="10&#x2F;16"></a>10&#x2F;16</h2><p>720.词典中最长的单词</p><p>注意：</p><ol><li>注意返回值为String，返回null是不对的，若为null应该返回””</li><li>只找最大或最小的值，考虑优先队列存储，传入比较器</li></ol><h2 id="10-18"><a href="#10-18" class="headerlink" title="10&#x2F;18"></a>10&#x2F;18</h2><h3 id="移位运算符"><a href="#移位运算符" class="headerlink" title="移位运算符"></a>移位运算符</h3><p>根据这个规则，左移32位后，右边补上32个0值是不是就变成了十进制的0了？答案是NO，当int类型进行左移操作时，左移位数大于等于32位操作时，会先求余（%）后再进行左移操作。也就是说左移32位相当于不进行移位操作，左移40位相当于左移8位（40%32&#x3D;8）。当long类型进行左移操作时，long类型在二进制中的体现是64位的，因此求余操作的基数也变成了64，也就是说左移64位相当于没有移位，左移72位相当于左移8位（72%64&#x3D;8）<br>注意：其它几种整形byte，short移位前会先转换为int类型（32位）再进行移位</p><p>和左移一样，int类型移位大于等于32位时，long类型大于等于64位时，会先做求余处理再位移处理，byte，short移位前会先转换为int类型（32位）再进行移位。以上是正数的位移，我们再来看看负数的右移运算，</p><h3 id="无符号移位"><a href="#无符号移位" class="headerlink" title="无符号移位&gt;&gt;&gt;"></a>无符号移位&gt;&gt;&gt;</h3><p>无符号右移运算符&gt;&gt;&gt;和右移运算符&gt;&gt;是一样的，只不过右移时左边是补上符号位，而无符号右移运算符是补上0，也就是说，对于正数移位来说等同于：&gt;&gt;，负数通过此移位运算符能移位成正数。</p><p>在不大于自身数值类型最大位数的移位时，一个数左移n位，就是将这个数乘以2的n次幂；一个数右移n位，就是将这个数除2的n次幂，然后取整。<br>比如int32位的（64位也是同样方法）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">7</span> &gt;&gt; <span class="hljs-number">1</span>  = <span class="hljs-number">7</span>/<span class="hljs-number">2</span>  取整为<span class="hljs-number">3</span><br><span class="hljs-number">7</span> &lt;&lt; <span class="hljs-number">1</span>  = <span class="hljs-number">7</span>*<span class="hljs-number">2</span>  为<span class="hljs-number">14</span><br></code></pre></td></tr></table></figure><p>如果移动位数超过了32位怎么办？把移位数和32取余数得到的数字套用即可：</p><p>如 9 &gt;&gt; 67<br>1、先67对32取余，结果是3<br>2、然后9&#x2F;8 得到结果为1</p><h4 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h4><p>C艹里面1最大左移31位，变成最小负数，然后这个数不能再-1</p><h5 id="java"><a href="#java" class="headerlink" title="java"></a>java</h5><h2 id="10-20"><a href="#10-20" class="headerlink" title="10&#x2F;20"></a>10&#x2F;20</h2><h3 id="Tree的bfs与图的bfs的区别"><a href="#Tree的bfs与图的bfs的区别" class="headerlink" title="Tree的bfs与图的bfs的区别"></a>Tree的bfs与图的bfs的区别</h3><p>相信对于Tree的BFS大家都已经轻车熟路了：要把root节点先入队，然后再一层一层的无脑遍历就行了。</p><p>对于图的BFS也是一样滴～ 与Tree的BFS区别如下：<br>1、tree只有1个root，而图可以有多个源点，所以首先需要把多个源点都入队。<br>2、tree是有向的因此不需要标志是否访问过，而对于无向图来说，必须得标志是否访问过！<br>并且为了防止某个节点多次入队，需要在入队之前就将其设置成已访问！</p><p>图的bfs遍历时，需要创建一个used数组来标记某个节点是否已经入队。已经入队的节点标记为true，将某个节点入队之前先判断它是否已经被访问过，若没有被访问过再入队。</p><p>入队之前判断，这样可以保证一个节点不会重复入队。</p><h3 id="1162-地图分析"><a href="#1162-地图分析" class="headerlink" title="1162.地图分析"></a>1162.地图分析</h3><p>这是一道典型的BFS基础应用，为什么这么说呢？<br>因为我们只要先把所有的陆地都入队，然后从各个陆地同时开始一层一层的向海洋扩散，那么最后扩散到的海洋就是最远的海洋！<br>并且这个海洋肯定是被离他最近的陆地给扩散到的！</p><h3 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h3><p>课程表题目210 207   给出课程学习的拓扑排序，利用BFS</p><h3 id="c-map的性质"><a href="#c-map的性质" class="headerlink" title="c++map的性质"></a>c++map的性质</h3><p><img src="https://cdn.jsdelivr.net/gh/dutsc/cloud-image/blog-img/202312052038181.png" alt="cpp中map的性质"></p><p>输出1 4 3 5</p><p>若key与之前的key相等，则不会替换之前的map</p><p>map可以通过m3[1]直接获取key为1的value值，并且通过++来使value+1</p><h2 id="10-26"><a href="#10-26" class="headerlink" title="10&#x2F;26"></a>10&#x2F;26</h2><p>拓扑排序+动态规划   类型的困难题  1857</p><p>快速获取数组中的最大值最小值的方法：</p><p>Java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Arrays.stream(nums).max().getAsInt();<br></code></pre></td></tr></table></figure><p>C++</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">*<span class="hljs-built_in">max_element</span>(array,array+n);<br><span class="hljs-type">int</span> myMax = *<span class="hljs-built_in">min_element</span>(arr.<span class="hljs-built_in">begin</span>(),arr.<span class="hljs-built_in">end</span>());<span class="hljs-comment">//也可以</span><br></code></pre></td></tr></table></figure><h2 id="10-28"><a href="#10-28" class="headerlink" title="10&#x2F;28"></a>10&#x2F;28</h2><p>判断一个数是不是2的整数次幂</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">if</span>(!num&amp;(num<span class="hljs-number">-1</span>)) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br></code></pre></td></tr></table></figure><p>此操作，翻转了num最右边的1</p><p>c++将数字转化为字符串</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">to_string</span>();<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/dutsc/cloud-image/blog-img/202312052038387.png"></p><p>将字符串转化为数字</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><br>atoi;<span class="hljs-comment">//string to int   可以直接忽略前导0  超过上下界输出上下界</span><br>atof;<span class="hljs-comment">//string to float</span><br></code></pre></td></tr></table></figure><h2 id="11-2"><a href="#11-2" class="headerlink" title="11&#x2F;2"></a>11&#x2F;2</h2><p>只知道当前节点，想要删除当前节点的方法：</p><p><strong>不可取的设计模式！</strong> 本质上来说，单链表节点无法做到在链表里删除自身</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//只适用于Java，因为Java有垃圾回收器GC</span><br><span class="hljs-keyword">if</span>(node.next!=<span class="hljs-literal">null</span>)&#123;<br>    node.val = node.next.val;<br>    node.next = node.next.next;<br>&#125;<br><span class="hljs-keyword">else</span>&#123;<br>    node = <span class="hljs-literal">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>lambda表达式中的差值，若是long类型，则必须转换为 int类型，否则会报错。因为compare方法返回的是int类型，要想不强转，只能重写compare方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">long</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">long</span>[<span class="hljs-number">2</span>][n];<br>PriorityQueue&lt;<span class="hljs-type">long</span>[]&gt; minHeap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;&gt;((a,b)-&gt;a[<span class="hljs-number">1</span>]-b[<span class="hljs-number">1</span>]);<br></code></pre></td></tr></table></figure><h2 id="11-3"><a href="#11-3" class="headerlink" title="11&#x2F;3"></a>11&#x2F;3</h2><p>取出一个点，一次遍历它的上下左右的技巧：</p><p><img src="https://cdn.jsdelivr.net/gh/dutsc/cloud-image/blog-img/202312052038506.png" alt="遍历一个矩阵中上下左右四个位置"></p><h2 id="11-11"><a href="#11-11" class="headerlink" title="11&#x2F;11"></a>11&#x2F;11</h2><h4 id="记忆化深度优先搜索："><a href="#记忆化深度优先搜索：" class="headerlink" title="记忆化深度优先搜索："></a>记忆化深度优先搜索：</h4><p>当发现DFS出现大量重复计算时，若是矩阵，则可以创建一个缓存矩阵，来存储其已经遍历到的结果，这样就可以不用每次DFS的时候都要重新遍历了。</p><p>省下used数组空间的小技巧：</p><p>329.矩阵中的最长递增路径   一题中，memo矩阵存储从该点开始DFS的最长路径，将其初始值置为0，这样在遍历过程中，若$memo[i][j]$是0，就可以认为该位置没有被遍历过，就要重新遍历；</p><p>若$memo[i][j]$ 不是0，则直接返回该点的值即可，不需要再重新遍历。</p><h2 id="11-16"><a href="#11-16" class="headerlink" title="11&#x2F;16"></a>11&#x2F;16</h2><p>判断连接成完美矩形的条件：</p><ul><li>左下，右上，右下，左上的点只出现一次，其他的点成对出现<br>于是这就有了思路：若某一节点不在哈希表中，则加入，若已经在哈希表中，则删除，最后判断哈希表中元素个数是否为4，而且是左下，右上，右下，左上四个节点</li><li>每个矩形面积的累加和，看是不是等于最大的右上值减去最小的左下值，相等则true，不相等则false</li></ul><p>这里有一个小技巧：判断矩形的某一个点是已经存在。</p><p>由于矩形的点是用一个二元组来表示的，常规想法不太好存储，有一个小妙招：Set中存储<string> ，将矩形每个点的坐标拼接起来，这个String就代表该点的坐标，只需要判断该String是否在哈希表中即可。</p><p><strong>非常巧妙的变二维为一维的思想！</strong></p><h2 id="11-17"><a href="#11-17" class="headerlink" title="11&#x2F;17"></a>11&#x2F;17</h2><p>c++中，size()  和 length() 返回值类型是无符号数unsigned，若需要转为int类型则需要调用强制类型转换函数</p><h2 id="11-22"><a href="#11-22" class="headerlink" title="11&#x2F;22"></a>11&#x2F;22</h2><p>java数组的clone方法</p><p>A.一维数组：深克隆（重新分配空间，并将元素复制过去）</p><p>对clone后的数组进行修改不会影响源数组。<br>B.二维数组：浅克隆（只传递引用）</p><p>对clone后的数组进行修改时，将对源数组也产生影响（因为复制的是引用，实际上指向的是同一个地址）</p><p>实现二维数组的深克隆</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span>[][] a=&#123;&#123;<span class="hljs-number">3</span>,<span class="hljs-number">1</span>,<span class="hljs-number">4</span>,<span class="hljs-number">2</span>,<span class="hljs-number">5</span>&#125;,&#123;<span class="hljs-number">4</span>,<span class="hljs-number">2</span>&#125;&#125;;<br><span class="hljs-type">int</span>[][] b=<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[a.length][];<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;a.length;i++)&#123;<br>        b[i]=a[i].clone();<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="11-28"><a href="#11-28" class="headerlink" title="11&#x2F;28"></a>11&#x2F;28</h2><h3 id="筛法求素数"><a href="#筛法求素数" class="headerlink" title="筛法求素数"></a>筛法求素数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-type">int</span> n;<br><span class="hljs-type">Scanner</span> <span class="hljs-variable">sc</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>n = sc.nextInt();<br><span class="hljs-type">int</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>; i &lt; n; i++) &#123;<br>    arr[i] = i;<br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>; i &lt; n; i++) &#123;<br>    <span class="hljs-keyword">if</span> (arr[i] != <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-type">int</span> j, temp;<br>        temp = arr[i];<br>        <span class="hljs-keyword">for</span> (j = <span class="hljs-number">2</span> * temp; j &lt; n; j = j + temp) &#123; <span class="hljs-comment">//这一步可以直接从temp[i]*temp[i]开始进行查找，可以证明</span><br>            arr[j] = <span class="hljs-number">0</span>;<br>        &#125;<br>        System.out.print(arr[i] + <span class="hljs-string">&quot; &quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>下标就是其值</p><h2 id="11-29"><a href="#11-29" class="headerlink" title="11&#x2F;29"></a>11&#x2F;29</h2><p>c++优先队列自定义排序    </p><p>优先队列使用仿函数，仿函数后面不加()，sort中使用仿函数，必须要加()；sort使用普通函数，必须使用static的函数，</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(<span class="hljs-type">int</span> &amp;a,<span class="hljs-type">int</span> &amp;b)</span></span>&#123;<br>        <span class="hljs-keyword">return</span> a&gt;b;<br>    &#125;<br><br> <span class="hljs-built_in">sort</span>(candidates.<span class="hljs-built_in">begin</span>(),candidates.<span class="hljs-built_in">end</span>(),cmp);<br></code></pre></td></tr></table></figure><p>注意：</p><ol><li><p>若有两个数，使用pair比使用vector快得多</p></li><li><p>使用emplace比push快，push要加上{}，emplace不用，直接写两个数就可以</p></li><li><p>priority_queue的排序返回值类型是bool，不是int  注意！！而且，&gt;  前者&gt;后者是从小到大排序，&lt; 前者&lt;后者是从大到小排序  ，优先队列使用仿函数排序，不能加()；使用普通函数排序，必须是static，而且必须使用函数指针（*暂时还没有研究）</p></li><li><p>sort排序顺序与java中的相同，与priority_queue相反，&lt; 表示从小到大排序，&gt;表示从大到小排序。<strong>sort使用仿函数必须加()，sort使用普通函数不加()，但是普通函数必须是static的</strong></p></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">cmpo</span>&#123;<br>    <span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; &amp;x,pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; &amp;y)</span></span>&#123;<br>        <span class="hljs-keyword">return</span> x.first*y.second&gt;x.second*y.first;<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">// class cmpv&#123;</span><br><span class="hljs-comment">//     public:</span><br><span class="hljs-comment">//     bool operator()(vector&lt;int&gt; &amp;x,vector&lt;int&gt; &amp;y)&#123;</span><br><span class="hljs-comment">//         return x[0]*y[1]&gt;x[1]*y[0];</span><br><span class="hljs-comment">//     &#125;</span><br><span class="hljs-comment">// &#125;;</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// bool cmp(pair&lt;int,int&gt; x,pair&lt;int,int&gt; y)&#123;</span><br>    <span class="hljs-comment">//     return x.first*y.second-x.second*y.first;</span><br>    <span class="hljs-comment">// &#125;</span><br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">kthSmallestPrimeFraction</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; arr, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = arr.<span class="hljs-built_in">size</span>();<br>        priority_queue&lt;pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;,vector&lt;pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; &gt;,cmpo&gt; minHeap;<br>        <span class="hljs-comment">// priority_queue&lt;vector&lt;int&gt;,vector&lt;vector&lt;int&gt;&gt;,cmpv&gt; minHeap;</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = i+<span class="hljs-number">1</span>;j&lt;n;j++)&#123;<br>                <span class="hljs-comment">// minHeap.push(&#123;arr[i],arr[j]&#125;);</span><br>                minHeap.<span class="hljs-built_in">emplace</span>(arr[i],arr[j]);<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">int</span> len = minHeap.<span class="hljs-built_in">size</span>();<br>        pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; temp;<br>        <span class="hljs-comment">// vector&lt;int&gt; temp; </span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i&lt;len;++i)&#123;<br>            <span class="hljs-keyword">if</span>(i==k<span class="hljs-number">-1</span>)&#123;<br>                temp = minHeap.<span class="hljs-built_in">top</span>();<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-comment">// pair&lt;int,int&gt; t = minHeap.top();</span><br>            <span class="hljs-comment">// cout &lt;&lt; t.first &lt;&lt; &quot; &quot; &lt;&lt; t.second &lt;&lt; endl;</span><br>            minHeap.<span class="hljs-built_in">pop</span>();<br>        &#125;<br>        vector&lt;<span class="hljs-type">int</span>&gt; a;<br>        a.<span class="hljs-built_in">push_back</span>(temp.first);<br>        a.<span class="hljs-built_in">push_back</span>(temp.second);<br>        <span class="hljs-comment">// a.push_back(temp[0]);</span><br>        <span class="hljs-comment">// a.push_back(temp[1]);</span><br>        <span class="hljs-keyword">return</span> a;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>c++排序方法：</p><p><img src="https://cdn.jsdelivr.net/gh/dutsc/cloud-image/blog-img/202312052038606.png" alt="cpp排序方法"></p><h2 id="2022-1-8"><a href="#2022-1-8" class="headerlink" title="2022 1&#x2F;8"></a>2022 1&#x2F;8</h2><p>java中可以使用path.split(“&#x2F;“)将字符串path使用&#x2F;进行分割，并返回一个字符串数组。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">String[] names = path.split(<span class="hljs-string">&quot;/&quot;</span>);<br></code></pre></td></tr></table></figure><p>中间有不定数量空格隔开的字符串，也能分割成字符串数组</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-type">BufferedReader</span> <span class="hljs-variable">br</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InputStreamReader</span>(System.in));<br>String[] tt = br.readLine().split(<span class="hljs-string">&quot; +&quot;</span>);<br></code></pre></td></tr></table></figure><h2 id="背包问题"><a href="#背包问题" class="headerlink" title="背包问题"></a>背包问题</h2><h2 id="01背包"><a href="#01背包" class="headerlink" title="01背包"></a>01背包</h2><p>若采用先遍历物品，再遍历背包容量的方式，背包容量要从大到小遍历</p><h2 id="完全背包"><a href="#完全背包" class="headerlink" title="完全背包"></a>完全背包</h2><p>遍历顺序与01背包不同，若采用先遍历物品，再遍历背包容量的方式，背包容量要从小到大遍历，这样每一个物品都可以无限次被拿取。</p><p>求一共有多少种零钱组合金额的题目，就是求有多少种物品放入背包的方式，递推公式一般为$dp[i] +&#x3D; dp[i-cost[i]]$ ，而且注意，$dp[0]$ 一定要初始化为1，否则后面都是0，没有意义。</p><p>&#x3D;&#x3D;for循环的遍历顺序与 是 组合还是排列  有关系！&#x3D;&#x3D;</p><ol><li>先遍历物品（钱币金额），再遍历背包容量（金钱总额），求的是组合数</li><li>先遍历背包容量（金钱总额），再遍历物品（钱币金额），求的是排列数。</li></ol><p>滚动数组中，倒序遍历是为了保证每个物品只被添加一次</p><h2 id="子序列问题"><a href="#子序列问题" class="headerlink" title="子序列问题"></a>子序列问题</h2><blockquote><p>子序列默认不连续，子数组默认连续</p></blockquote><h3 id="最长递增子序列（LIS）"><a href="#最长递增子序列（LIS）" class="headerlink" title="最长递增子序列（LIS）"></a>最长递增子序列（LIS）</h3><p>对于每一个位置，依次遍历该位置之前的所有位置，求得最长递增子序列的长度，然后再加一</p><p>on2</p><h4 id="Ologn的解法"><a href="#Ologn的解法" class="headerlink" title="Ologn的解法"></a>Ologn的解法</h4><p>利用贪心和二分的思想，维护一个最长自增子序列数组d，若a[i] &lt; d[len] ，则在d数组中二分查找第一个小于a[i] 的元素，在他的下一个位置将d数组中的元素替换成a[i] ，</p><p>这是因为，总是想让最长上升子序列上升的最慢。len的值(index+1) 就是最长递增子序列的长度。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-type">int</span>[] d;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">lengthOfLIS</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-keyword">if</span>(n==<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        d = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        d[<span class="hljs-number">0</span>] = nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;i&lt;n;++i)&#123;<br>            <span class="hljs-keyword">if</span>(nums[i]&gt;d[index])&#123;<br>                d[++index] = nums[i];<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nums[i]==d[index]) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">id</span> <span class="hljs-operator">=</span> binarySearch(<span class="hljs-number">0</span>,index,d,nums[i]);<br>                d[id] = nums[i];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> index+<span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-type">int</span> <span class="hljs-title function_">binarySearch</span><span class="hljs-params">(<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r,<span class="hljs-type">int</span>[] d,<span class="hljs-type">int</span> target)</span>&#123;<br>        <span class="hljs-keyword">while</span>(l&lt;r)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> ((r-l)&gt;&gt;<span class="hljs-number">1</span>)+l;<br>            <span class="hljs-keyword">if</span>(d[mid]&gt;=target) r = mid;<br>            <span class="hljs-keyword">else</span> l = mid+<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> r;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="最长连续递增子序列"><a href="#最长连续递增子序列" class="headerlink" title="最长连续递增子序列"></a>最长连续递增子序列</h3><p>因为要求连续递增子序列，所以就不需要比较$dp[i]$和$dp[j] (j&lt;i)$ ，而是直接比较$dp[i+1]$ 和$dp[i]$ ，故只需要一层for循环即可。</p><p>区别：</p><ul><li>不连续的子序列，跟之前的所有状态都有关（0-i个状态）</li><li>连续的子序列，只跟前一个状态有关。</li></ul><h3 id="最长重复子数组"><a href="#最长重复子数组" class="headerlink" title="最长重复子数组"></a>最长重复子数组</h3><h3 id="最长公共子序列（LCS）"><a href="#最长公共子序列（LCS）" class="headerlink" title="最长公共子序列（LCS）"></a>最长公共子序列（LCS）</h3><h2 id="1-23"><a href="#1-23" class="headerlink" title="1&#x2F;23"></a>1&#x2F;23</h2><p>辗转相除法求最大公约数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">GCD</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (a%b == <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-keyword">return</span> b;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">GCD</span>(b, a%b);<br>&#125;<br></code></pre></td></tr></table></figure><p>最小公倍数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-title function_">LCM</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span>&#123;<br>    <span class="hljs-keyword">return</span> a/GCD(a,b)*b;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="1-24"><a href="#1-24" class="headerlink" title="1&#x2F;24"></a>1&#x2F;24</h2><h3 id="Manacher算法"><a href="#Manacher算法" class="headerlink" title="Manacher算法"></a>Manacher算法</h3><p>马拉车算法</p><p>Manacher 算法是在线性时间内求解最长回文子串的算法。</p><p>算法要点：</p><p><img src="C:/Users/s%27c/AppData/Roaming/Typora/typora-user-images/image-20220124140113642.png" alt="image-20220124140113642"></p><ol><li><p>奇偶统一判断：在每一个字符中间加入一个本字符串中没有出现过的字符（首尾也加）</p><p>转换之后，所有的回文串长度都是奇数</p><p>对于以$T[i]$ 为中心的最长回文子串，其长度为$2\times L[i]-1$ (带#)</p><p>可以证明，$Len$ 数组可以求出，$Len(i)$ 表示以下标为i的字符为中心，最长回文子串的长度为$Len(i)-1$ .原问题就转化为求$Len(i)$ （每一个字符的回文半径）</p></li></ol><p>求最长回文子串</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">addString</span><span class="hljs-params">(String s)</span>&#123;<br>        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>(<span class="hljs-string">&quot;#&quot;</span>);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i&lt;s.length();++i)&#123;<br>            sb.append(s.charAt(i));<br>            sb.append(<span class="hljs-string">&#x27;#&#x27;</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> sb.toString();<br>    &#125;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">longestPalindrome</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> s.length();<br>        <span class="hljs-keyword">if</span>(s.length()&lt;<span class="hljs-number">2</span>)&#123;<br>            <span class="hljs-keyword">return</span> s;<br>        &#125;<br>        s = addString(s);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">mx</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">loc</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">mymax</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span>[] p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">2</span>*n+<span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i&lt;<span class="hljs-number">2</span>*n+<span class="hljs-number">1</span>;++i)&#123;<br>            <span class="hljs-keyword">if</span>(mx-i&gt;<span class="hljs-number">0</span> &amp;&amp; <span class="hljs-number">2</span>*loc-i&gt;=<span class="hljs-number">0</span>)&#123;<br>                p[i] = Math.min(mx-i,p[<span class="hljs-number">2</span>*loc-i]);<br>            &#125;<br>            <span class="hljs-keyword">else</span> p[i] = <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">while</span>(i+p[i]&lt;<span class="hljs-number">2</span>*n+<span class="hljs-number">1</span> &amp;&amp; i-p[i]&gt;=<span class="hljs-number">0</span> &amp;&amp; s.charAt(i+p[i])==s.charAt(i-p[i]))&#123;<br>                p[i]++;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(i+p[i]&gt;mx)&#123;<br>                mx = i+p[i];<br>                loc = i;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(mymax&lt;p[i])&#123;<br>                mymax = p[i];<br>                start = i;<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> s.substring(start-p[start]+<span class="hljs-number">1</span>,start+p[start]);<br>        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i&lt;t.length();++i)&#123;<br>            <span class="hljs-keyword">if</span>(t.charAt(i)==<span class="hljs-string">&#x27;#&#x27;</span>)&#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            sb.append(t.charAt(i));<br>        &#125;<br>        <span class="hljs-keyword">return</span> sb.toString();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>求回文串的个数（把加上#的数组中，每一个p[i]的值&#x2F;2并累加）为什么？？？  好像懂了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">addString</span><span class="hljs-params">(String s)</span>&#123;<br>        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>        sb.append(<span class="hljs-string">&#x27;#&#x27;</span>);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> s.length();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i&lt;n;++i)&#123;<br>            sb.append(s.charAt(i));<br>            sb.append(<span class="hljs-string">&#x27;#&#x27;</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> sb.toString();<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">countSubstrings</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-keyword">if</span>(s.length()&lt;<span class="hljs-number">2</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        &#125;<br>        s = addString(s);<br>        <span class="hljs-comment">// System.out.println(s);</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> s.length();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">mx</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>,loc = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span>[] p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        <span class="hljs-type">char</span>[] c = s.toCharArray();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i&lt;n;++i)&#123;<br>            <span class="hljs-keyword">if</span>(mx&gt;i &amp;&amp; <span class="hljs-number">2</span>*loc-i&gt;=<span class="hljs-number">0</span>)&#123;<br>                p[i] = Math.min(mx-i,p[<span class="hljs-number">2</span>*loc-i]);<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>                p[i] = <span class="hljs-number">1</span>;<br>            &#125;<br>            <span class="hljs-keyword">while</span>(i+p[i]&lt;s.length()&amp;&amp;i-p[i]&gt;=<span class="hljs-number">0</span> &amp;&amp; c[i+p[i]]==c[i-p[i]])&#123;<br>                p[i]++;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(i+p[i]&gt;mx)&#123;<br>                mx = i+p[i];<br>                loc = i;<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i&lt;p.length;++i)&#123;<br>            sum+=p[i]/<span class="hljs-number">2</span>;<br>            <span class="hljs-comment">// System.out.println(p[i]);</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> sum;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>唯一一个疑点：为什么取最小值？</p><h2 id="1-26"><a href="#1-26" class="headerlink" title="1&#x2F;26"></a>1&#x2F;26</h2><h3 id="线段树"><a href="#线段树" class="headerlink" title="线段树"></a>线段树</h3><p>查询方法：</p><ol><li>如果这个区间被完全包括在目标区间里里面，直接返回这个区间的值</li><li>如果这个区间的左儿子和目标区间有交集，那么搜索左儿子</li><li>如果这个区间的右儿子和目标区间有交集，那么搜索右儿子</li></ol><p>那么对于区间操作，我们考虑引入一个名叫“lazy tag 懒标记）的东西——之所以称其“lazy<em>”，是因为原本区间修改需要通过先改变叶子节点的值，然后不断地向上递归修改祖先节点直至到达根节点，时间复杂度最高可以到达O</em>(<em>n<strong>l</strong>o<strong>g</strong>n</em>)的级别。但当我们引入了懒标记之后，区间更新的期望复杂度就降到了<em>O</em>(<em>l<strong>o</strong>g**n</em>)的级别且甚至会更低.</p><h4 id="懒标记"><a href="#懒标记" class="headerlink" title="懒标记"></a>懒标记</h4><blockquote><p>pushdown都是在区间分裂之前进行</p></blockquote><p>懒标记的作用是，记录每次，每个结点要更新的值。     但线段树的优点不在于全记录，而是传递式记录：</p><p>整个区间都被操作，记录在公共祖先节点上，只修改了一部分，就只记录在这部分的公共祖先上，如果只修改了自己的话，就只改变自己。</p><p>懒标记的意义</p><p>由于我们要做的操作是区间加一个数，所以我们不妨在区间进行修改时为该区间打上一个标记，就不必再修改他的儿子所维护区间，等到要使用该节点的儿子节点维护的值时，再将懒标记下放即可，可以节省很多时间，对于每次区间修改和查询，将懒标记下传，可以节省很多时间</p><p>注意：也是第一次写代码一直不通过的原因：</p><ol><li>用线段树维护不同的情况（如区间和，区间最大值），pushdown的逻辑会稍有变化。<br>若是维护区间最值，第一种情况就是tree的区间是[l,r]的子集<br>若是维护区间和，第一种情况就是tree的区间与[l,r]相等</li><li>查询query和更新update时，要查询的l r不要变，只改变lc，rc就好</li><li>build时，要查询的l r都要变，lc rc也要变</li></ol><p>L,R是要查询的区间的范围</p><h4 id="区间都乘某个数"><a href="#区间都乘某个数" class="headerlink" title="区间都乘某个数"></a>区间都乘某个数</h4><p>若是区间乘法，（洛谷模板题2）则要设两个懒标记，一个lazyAdd，一个lazyMul。</p><p>乘法操作时，lazyMul*&#x3D;k   lazy+&#x3D;k</p><p>加法操作时 lazyMul不变   lazyAdd+&#x3D;k</p><h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><h5 id="区间修改"><a href="#区间修改" class="headerlink" title="区间修改"></a>区间修改</h5><ol><li>如果整个区间都被包含就修改整个区间，否则分裂区间，递归处理子区间后再回溯处理父节点代表的区间。</li><li>懒标记：如果每次递归处理到叶子节点，复杂度不行，付姐带你表示的区间是左右儿子的整合，我修改父节点表示的区间，因为打了标记，我就会把以前的修改顺带做了，并且把懒标记传递下去。</li></ol><h5 id="java对象数组特点"><a href="#java对象数组特点" class="headerlink" title="java对象数组特点"></a>java对象数组特点</h5><ol><li><p>对于对象数组，使用运算符new只是为数组本身分配空间，并没有对数组的元素进行初始化。即数组元素都为空，<br><img src="https://cdn.jsdelivr.net/gh/dutsc/cloud-image/blog-img/202312052038164.png" alt="对象数组初始化"></p><p>正确的使用方法，应该分别对每个对象进行初始化，<strong>并且不能使用增强for循环</strong>，因为增强for循环不是本体。</p></li><li><p>对于基本数据类型，采用new初始化数组时，数组元素也进行了相应的初始化</p></li></ol><h4 id="带懒标记的线段树模板"><a href="#带懒标记的线段树模板" class="headerlink" title="带懒标记的线段树模板"></a>带懒标记的线段树模板</h4><blockquote><p>Java版本</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span>&#123;<br>    <span class="hljs-type">int</span> l;<br>    <span class="hljs-type">int</span> r;<br>    <span class="hljs-type">int</span> add;<br>    <span class="hljs-type">int</span> sum;<br><span class="hljs-comment">//    int mul;</span><br>    Node(<span class="hljs-type">int</span> _l,<span class="hljs-type">int</span> _r)&#123;<br>        <span class="hljs-built_in">this</span>.l = _l;<br>        <span class="hljs-built_in">this</span>.r = _r;<br>    &#125;<br>    Node()&#123;<br><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SegmentTreePushdown</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[] nums;<br>    <span class="hljs-keyword">static</span> Node[] tree;<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> n;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">int</span>[] _nums = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">7</span>,<span class="hljs-number">9</span>,<span class="hljs-number">11</span>&#125;;<br>        nums = _nums;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        tree = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>[<span class="hljs-number">4</span>*n];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i&lt;<span class="hljs-number">4</span>*n;++i)&#123;<br>            tree[i] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>();<br>        &#125;<br>        build(<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,n-<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">for</span>(Node tt:tree)&#123;<br>            System.out.println(tt.l + <span class="hljs-string">&quot; &quot;</span> + tt.r + <span class="hljs-string">&quot; &quot;</span> + tt.sum);<br>        &#125;<br>        update(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">5</span>,<span class="hljs-number">3</span>);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">sumtt</span> <span class="hljs-operator">=</span> query(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">4</span>);<br>        System.out.println(sumtt);<br>    &#125;<br><br>    <span class="hljs-comment">// 建树</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">build</span><span class="hljs-params">(<span class="hljs-type">int</span> node, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end)</span>&#123;<br>        tree[node].l = start;<br>        tree[node].r = end;<br>        <span class="hljs-keyword">if</span>(start==end)&#123;<br>            tree[node].sum = nums[start];<br>            <span class="hljs-keyword">return</span> ;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> ((end-start)&gt;&gt;<span class="hljs-number">1</span>)+start;<br>        build(node&lt;&lt;<span class="hljs-number">1</span>,start,mid);<br>        build(node&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>,mid+<span class="hljs-number">1</span>,end);<br>        pushup(node);<br>    &#125;<br>    <span class="hljs-comment">// 区间更新</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">update</span><span class="hljs-params">(<span class="hljs-type">int</span> node,<span class="hljs-type">int</span> L, <span class="hljs-type">int</span> R, <span class="hljs-type">int</span> val)</span>&#123;<br>        System.out.println(<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">if</span>(L&lt;=tree[node].l &amp;&amp; R&gt;=tree[node].r)&#123;<br>            tree[node].add += val;<br>            tree[node].sum += val*(tree[node].r-tree[node].l+<span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">return</span> ;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> ((tree[node].r-tree[node].l)&gt;&gt;<span class="hljs-number">1</span>)+tree[node].l;<br>        pushdown(node);<br>        <span class="hljs-keyword">if</span>(L&lt;=mid)<br>            update(node&lt;&lt;<span class="hljs-number">1</span>,L,R,val);<br>        <span class="hljs-keyword">if</span>(R&gt;mid)<br>            update(node&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>,L,R,val);<br>        pushup(node);<br>    &#125;<br>    <span class="hljs-comment">// 区间查询</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">query</span><span class="hljs-params">(<span class="hljs-type">int</span> node, <span class="hljs-type">int</span> L,<span class="hljs-type">int</span> R)</span>&#123;<br>        <span class="hljs-keyword">if</span>(L&gt;tree[node].r || R&lt;tree[node].l) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span>(L&lt;=tree[node].l &amp;&amp; R&gt;=tree[node].r) <span class="hljs-keyword">return</span> tree[node].sum;<br>        pushdown(node);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> ((tree[node].r-tree[node].l)&gt;&gt;<span class="hljs-number">1</span>)+tree[node].l;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span>(L&lt;=mid)<br>            res += query(node&lt;&lt;<span class="hljs-number">1</span>,L,R);<br>        <span class="hljs-keyword">if</span>(R&gt;mid)<br>            res += query(node&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>,L,R);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-comment">// 回溯更新</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">pushup</span><span class="hljs-params">(<span class="hljs-type">int</span> node)</span>&#123;<br>        tree[node].sum = tree[node&lt;&lt;<span class="hljs-number">1</span>].sum+tree[node&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>].sum;<br>    &#125;<br>    <span class="hljs-comment">// 下传懒标记</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">pushdown</span><span class="hljs-params">(<span class="hljs-type">int</span> node)</span>&#123;<br>        <span class="hljs-keyword">if</span>(tree[node].add!=<span class="hljs-number">0</span>)&#123;<br>            tree[node&lt;&lt;<span class="hljs-number">1</span>].add += tree[node].add;<br>            tree[node&lt;&lt;<span class="hljs-number">1</span>].sum += tree[node].add*(tree[node&lt;&lt;<span class="hljs-number">1</span>].r-tree[node&lt;&lt;<span class="hljs-number">1</span>].l+<span class="hljs-number">1</span>);<br>            tree[node&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>].add += tree[node].add;<br>            tree[node&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>].sum += tree[node].add*(tree[node&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>].r-tree[node&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>].l+<span class="hljs-number">1</span>);<br>            tree[node].add = <span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这份代码第一次写，出错的地方：</p><ol><li><code>update</code> 和<code>query</code> 在判断递归条件的时候，要用L R和mid作比较，而不是用tree的lr。</li><li>pushdown操作中，子节点的懒标记要使用+&#x3D;，而不是直接赋值。因为可能子节点之前就有懒标记了。</li></ol><blockquote><p>c++版本</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//</span><br><span class="hljs-comment">// Created by s&#x27;c on 2022/4/4.</span><br><span class="hljs-comment">//</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;iostream&quot;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MAX = <span class="hljs-number">100010</span>;<br><span class="hljs-type">int</span> nums[MAX]=&#123;<span class="hljs-number">0</span>&#125;;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span>&#123;<br>    <span class="hljs-type">int</span> l;<br>    <span class="hljs-type">int</span> r;<br>    ll add;<br>    ll sum;<br>&#125;;<br>node tree[<span class="hljs-number">4</span>*MAX];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pushup</span><span class="hljs-params">(<span class="hljs-type">int</span> node)</span></span>&#123;<br>    tree[node].sum = tree[node&lt;&lt;<span class="hljs-number">1</span>].sum + tree[node&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>].sum;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">build</span><span class="hljs-params">(<span class="hljs-type">int</span> node,<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r)</span></span>&#123;<br>    tree[node].l = l;<br>    tree[node].r = r;<br>    <span class="hljs-keyword">if</span>(l==r)&#123;<br>        tree[node].sum = nums[l];<br>        <span class="hljs-keyword">return</span> ;<br>    &#125;<br>    <span class="hljs-type">int</span> mid = ((r-l)&gt;&gt;<span class="hljs-number">1</span>)+l;<br>    <span class="hljs-built_in">build</span>(node&lt;&lt;<span class="hljs-number">1</span>,l,mid);<br>    <span class="hljs-built_in">build</span>(node&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>,mid+<span class="hljs-number">1</span>,r);<br>    <span class="hljs-built_in">pushup</span>(node);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pushdown</span><span class="hljs-params">(<span class="hljs-type">int</span> node)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(tree[node].add)&#123;<br>        tree[node&lt;&lt;<span class="hljs-number">1</span>].add += tree[node].add;<br>        tree[node&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>].add += tree[node].add;<br>        tree[node&lt;&lt;<span class="hljs-number">1</span>].sum += tree[node].add*(tree[node&lt;&lt;<span class="hljs-number">1</span>].r-tree[node&lt;&lt;<span class="hljs-number">1</span>].l+<span class="hljs-number">1</span>);<br>        tree[node&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>].sum += tree[node].add*(tree[node&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>].r-tree[node&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>].l+<span class="hljs-number">1</span>);<br>        tree[node].add = <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">update</span><span class="hljs-params">(<span class="hljs-type">int</span> node,<span class="hljs-type">int</span> L,<span class="hljs-type">int</span> R,<span class="hljs-type">int</span> val)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(L&lt;=tree[node].l &amp;&amp; R&gt;=tree[node].r)&#123;<br>        tree[node].sum += val*(tree[node].r-tree[node].l+<span class="hljs-number">1</span>);<br>        tree[node].add += val;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-type">int</span> mid = ((tree[node].r-tree[node].l)&gt;&gt;<span class="hljs-number">1</span>)+tree[node].l;<br>    <span class="hljs-built_in">pushdown</span>(node);<br>    <span class="hljs-keyword">if</span>(L&lt;=mid) <span class="hljs-built_in">update</span>(node&lt;&lt;<span class="hljs-number">1</span>,L,R,val);<br>    <span class="hljs-keyword">if</span>(R&gt;mid) <span class="hljs-built_in">update</span>(node&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>,L,R,val);<br>    <span class="hljs-built_in">pushup</span>(node);<br>&#125;<br><span class="hljs-function">ll <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> node,<span class="hljs-type">int</span> L,<span class="hljs-type">int</span> R)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(R&lt;tree[node].l || L&gt;tree[node].r) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span>(L&lt;=tree[node].l &amp;&amp; R&gt;=tree[node].r) <span class="hljs-keyword">return</span> tree[node].sum;<br>    <span class="hljs-type">int</span> mid = ((tree[node].r-tree[node].l)&gt;&gt;<span class="hljs-number">1</span>)+tree[node].l;<br>    <span class="hljs-built_in">pushdown</span>(node);<br>    ll res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span>(L&lt;=mid) res+=<span class="hljs-built_in">query</span>(node&lt;&lt;<span class="hljs-number">1</span>,L,R);<br>    <span class="hljs-keyword">if</span>(R&gt;mid) res+=<span class="hljs-built_in">query</span>(node&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>,L,R);<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> n,m;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i&lt;n;++i)&#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;nums[i]);<br>    &#125;<br>    <span class="hljs-built_in">build</span>(<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,n<span class="hljs-number">-1</span>);<br>    <span class="hljs-keyword">while</span>(m--&gt;<span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-type">int</span> tt;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;tt);<br>        <span class="hljs-keyword">if</span>(tt==<span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-comment">// update</span><br>            <span class="hljs-type">int</span> l,r,k;<br>            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>,&amp;l,&amp;r,&amp;k);<br>            <span class="hljs-built_in">update</span>(<span class="hljs-number">1</span>,l<span class="hljs-number">-1</span>,r<span class="hljs-number">-1</span>,k);<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-comment">// query</span><br>            <span class="hljs-type">int</span> l,r;<br>            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;l,&amp;r);<br>            ll ans = <span class="hljs-built_in">query</span>(<span class="hljs-number">1</span>,l<span class="hljs-number">-1</span>,r<span class="hljs-number">-1</span>);<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%ld\n&quot;</span>,ans);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="树状数组"><a href="#树状数组" class="headerlink" title="树状数组"></a>树状数组</h3><h4 id="区间长度"><a href="#区间长度" class="headerlink" title="区间长度"></a>区间长度</h4><p>$c[i]$ 存储的值的区间长度为$lowbit(i)$ 则$lowbit(i)&#x3D;(-i)&amp;i$  </p><h4 id="前驱和后继"><a href="#前驱和后继" class="headerlink" title="前驱和后继"></a>前驱和后继</h4><p>$c[i]$ 的直接前驱为$c[i-lowbit(i)]$ ,$c[i]$ 的直接后继为$c[i+lowbit(i)]$ </p><p>前驱，即$c[i]$ 的直接前驱的直接前驱，即$c[i]$ 左侧所有子树的根</p><p>后继，即$c[i]$ 直接后继的直接后继，即$c[i]$ 的所有祖先</p><h4 id="查询前缀和"><a href="#查询前缀和" class="headerlink" title="查询前缀和"></a>查询前缀和</h4><p>$c[i]$ 的前缀和$sum[i]$ 等于$c[i]$ 加上$c[i]$ 的前驱</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sum</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span></span>&#123;<br>    <span class="hljs-type">int</span> s = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(;i&gt;<span class="hljs-number">0</span>;i-=<span class="hljs-built_in">lowbit</span>(i))&#123;<br>        s+=c[i];<br>    &#125;<br>    <span class="hljs-keyword">return</span> s;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="点更新"><a href="#点更新" class="headerlink" title="点更新"></a>点更新</h4><p>若对$a[i]$ 修改，则只需要对$c[i]$ 及其所有的后继（祖先节点）进行修改即可，不需要修改其他节点</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> i,<span class="hljs-type">int</span> v)</span></span>&#123;<br>    <span class="hljs-keyword">for</span>(;i&lt;=n;i+=<span class="hljs-built_in">lowbit</span>(i))&#123;<br>        c[i]+=v;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>注意：树状数组的下标必须从1开始，而不能从0开始，因为lowbit(i)&#x3D;0会出现死循环</p><h4 id="查询区间和"><a href="#查询区间和" class="headerlink" title="查询区间和"></a>查询区间和</h4><p>用前缀和数组的思想</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sum</span><span class="hljs-params">(<span class="hljs-type">int</span> i,<span class="hljs-type">int</span> j)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">sum</span>(j)-<span class="hljs-built_in">sum</span>(i<span class="hljs-number">-1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="1-30"><a href="#1-30" class="headerlink" title="1&#x2F;30"></a>1&#x2F;30</h2><h3 id="快速幂算法"><a href="#快速幂算法" class="headerlink" title="快速幂算法"></a>快速幂算法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">PowerMod</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b, <span class="hljs-type">int</span> c)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> ans = <span class="hljs-number">1</span>;<br>    a = a % c;<br>    <span class="hljs-keyword">while</span>(b&gt;<span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">if</span>(b % <span class="hljs-number">2</span> = = <span class="hljs-number">1</span>)<br>        ans = (ans * a) % c;<br>        b = b/<span class="hljs-number">2</span>;<br>        a = (a * a) % c;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="矩阵快速幂"><a href="#矩阵快速幂" class="headerlink" title="矩阵快速幂"></a>矩阵快速幂</h3><p>就是把整数的乘法换成矩阵的乘法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//矩阵乘法    </span><br><span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[][] Mul(<span class="hljs-type">int</span>[][] a,<span class="hljs-type">int</span>[][] b, <span class="hljs-type">int</span> n, <span class="hljs-type">int</span> mod)&#123;<br>        <span class="hljs-type">int</span>[][] temp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n][n];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i&lt;n;++i)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;j&lt;n;++j)&#123;<br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;k&lt;n;++k)&#123;<br>                    temp[i][j] += ((a[i][k]%mod)*(b[k][j]%mod))%mod;<br>                    temp[i][j] %= mod;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> temp;<br>    &#125;<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[][] FastPow(<span class="hljs-type">int</span>[][] a,<span class="hljs-type">int</span> p,<span class="hljs-type">int</span> mod)&#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> a.length;<br>        <span class="hljs-comment">//对于矩阵乘法来说，应该初始化为单位矩阵</span><br>        <span class="hljs-type">int</span>[][] res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n][n];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i&lt;n;++i)&#123;<br>            res[i][i] = <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">while</span>(p&gt;<span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">if</span>(p%<span class="hljs-number">2</span>==<span class="hljs-number">1</span>) res = Mul(res,a,n,mod);<br>            p = p&gt;&gt;<span class="hljs-number">1</span>;<br>            a = Mul(a,a,n,mod);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br></code></pre></td></tr></table></figure><h2 id="2-8"><a href="#2-8" class="headerlink" title="2&#x2F;8"></a>2&#x2F;8</h2><h3 id="贝祖定理"><a href="#贝祖定理" class="headerlink" title="贝祖定理"></a>贝祖定理</h3><p>如果$ax+by&#x3D;z$ 成立，那么一定满足$z$ 是$x$ 和$y$ 的最大公约数的倍数，$a,b,x,y,z$ 都是整数。</p><p>若java中，lc提交时出现int与二进制数不能进行位运算的错误，则给运算整体加上括号。</p><h3 id="2的幂"><a href="#2的幂" class="headerlink" title="2的幂"></a>2的幂</h3><p>判断一个数是2的幂的条件</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++">n&amp;(n<span class="hljs-number">-1</span>)==<span class="hljs-number">0</span>;<br>或者<br>n&amp;(-n) = n;<br></code></pre></td></tr></table></figure><h3 id="交换法实现全排列"><a href="#交换法实现全排列" class="headerlink" title="交换法实现全排列"></a>交换法实现全排列</h3><p>　　原理：假设以字符串第0个位置（也就是第一个字符）为起点，分别与后面的每一个位置对应的字符进行交换。直到k等于字符串最后一个位置时，就会排列出新的组合。</p><h3 id="数组所能开辟的最大空间"><a href="#数组所能开辟的最大空间" class="headerlink" title="数组所能开辟的最大空间"></a>数组所能开辟的最大空间</h3><ul><li><p><strong>函数内申请的变量，数组，是在栈（stack）中申请的一段连续的空间。栈的默认大小为2M或1M，开的比较小。</strong></p></li><li><p><strong>全局变量，全局数组，静态数组（static）则是开在全局区（静态区）（static）。大小为2G，所以能够开的很大。</strong>(1.5-1.8G之间)</p><p>1e7  ——1e9    </p></li><li><p><strong>而malloc、new出的空间，则是开在堆（heap）的一段不连续的空间。理论上则是硬盘大小。</strong></p></li></ul><h3 id="dfs中的两个函数"><a href="#dfs中的两个函数" class="headerlink" title="dfs中的两个函数"></a>dfs中的两个函数</h3><p>约束函数：能否得到可行解的约束</p><p>限界函数：能否得到最优解的约束</p><h3 id="include"><a href="#include" class="headerlink" title="#include&lt;bits&#x2F;stdc++.h&gt;"></a>#include&lt;bits&#x2F;stdc++.h&gt;</h3><p>包含c++目前所有的头文件</p><h2 id="2-10"><a href="#2-10" class="headerlink" title="2&#x2F;10"></a>2&#x2F;10</h2><p>dfs求解组合问题时，每一次递归是树枝上加深深度，而for循环是遍历这一个树层，注意去重的逻辑，是在同一树层中去重。组合总和2，不排序好像没办法写。</p><h2 id="2-12"><a href="#2-12" class="headerlink" title="2&#x2F;12"></a>2&#x2F;12</h2><p>解数独，dfs返回值是boolean类型的原因</p><p>找到一个正确的答案就可以直接返回，而不用再回溯去搜索了，也就是不用搜索完全部的情况。</p><p>java中char与int相互转换</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// &#x27;1&#x27; -&gt; 1</span><br><span class="hljs-type">char</span> <span class="hljs-variable">c9</span> <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;1&#x27;</span>;<br><span class="hljs-type">int</span> <span class="hljs-variable">num9</span> <span class="hljs-operator">=</span> c9 - <span class="hljs-string">&#x27;0&#x27;</span>;<br><br><span class="hljs-comment">// 1 -&gt; &#x27;1&#x27;</span><br><span class="hljs-type">int</span> <span class="hljs-variable">num10</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br><span class="hljs-type">char</span> <span class="hljs-variable">c10</span> <span class="hljs-operator">=</span> (<span class="hljs-type">char</span>)(num10 + <span class="hljs-string">&#x27;0&#x27;</span>);<br></code></pre></td></tr></table></figure><p>在c++中若是想输入字符，一定要格外小心，输入数字之后再输入字符，就一定要记得getchar()，输入字符前一定要记得getchar()，输入字符后若想换行，也要记得getchar()</p><h3 id="memset"><a href="#memset" class="headerlink" title="memset()"></a>memset()</h3><p>memset()函数非常好用</p><p>第一个参数是一个指针，第二个参数是要初始化填入的值，第三个参数是要初始化的大小</p><p>比如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> row[<span class="hljs-number">9</span>][<span class="hljs-number">10</span>];<br><span class="hljs-type">int</span> col[<span class="hljs-number">9</span>][<span class="hljs-number">10</span>];<br><span class="hljs-type">int</span> grid[<span class="hljs-number">9</span>][<span class="hljs-number">10</span>];<br><span class="hljs-built_in">memset</span>(row,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(row));<br><span class="hljs-built_in">memset</span>(col,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(col));<br><span class="hljs-built_in">memset</span>(grid,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(grid));<br></code></pre></td></tr></table></figure><p>这就是表示把三个二维数组的初始值都填入0</p><h3 id="输入二维字符数组的两种方式"><a href="#输入二维字符数组的两种方式" class="headerlink" title="输入二维字符数组的两种方式"></a>输入二维字符数组的两种方式</h3><p>方法一</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">char</span> Map[<span class="hljs-number">5</span>][<span class="hljs-number">5</span>];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;n);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>,Map[i]);<br>    &#125;<br></code></pre></td></tr></table></figure><p>方法二</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">char</span> Map[<span class="hljs-number">5</span>][<span class="hljs-number">5</span>];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;n);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        cin&gt;&gt;Map[i];<br>    &#125;<br></code></pre></td></tr></table></figure><p>cin 输入默认情况下是忽略 回车，空格，tab等空白符</p><p>注意方格图中xy和ij的对应关系，如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> m = grid.<span class="hljs-built_in">size</span>();<br><span class="hljs-type">int</span> n = grid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br></code></pre></td></tr></table></figure><p>此时，m表示有几行，对应y轴</p><p>n表示有几列，对应x轴</p><p>遍历的时候若i与m对应，j与n对应，则</p><figure class="highlight x++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs x++"><span class="hljs-built_in">int</span> x = j + d[k][<span class="hljs-number">0</span>];<br><span class="hljs-built_in">int</span> y = i + d[k][<span class="hljs-number">1</span>];<br>dfs(y,x);<br></code></pre></td></tr></table></figure><p>注意终止条件中i，j与m，n的对应关系，这个是最重要的，自己定义的xy怎么都可以。</p><h2 id="2-16"><a href="#2-16" class="headerlink" title="2&#x2F;16"></a>2&#x2F;16</h2><h3 id="记忆化容器的选择"><a href="#记忆化容器的选择" class="headerlink" title="记忆化容器的选择"></a>记忆化容器的选择</h3><p>但使用布尔数组作为记忆化容器往往无法区分「状态尚未计算」和「状态已经计算，并且结果为 false」两种情况。</p><p>因此我们需要转为使用 int[石子列表下标][跳跃步数]，默认值 0 代表状态尚未计算，−1 代表计算状态为 false，1 代表计算状态为 true。</p><p>存哈希表的技巧：可以把数组中的数值存为x，数组下标存为y，这样便于查找</p><p>记忆化容器可以使用哈希表</p><p>若哈希表中需要存储的辨识关键字有多个，则可以采用字符串形式。比如青蛙过河中，可以采用<code>k+&quot;-&quot;+i</code>  的string形式存储，y值存储搜索成功或失败（没有搜索到则不在哈希表中）</p><h2 id="2-27"><a href="#2-27" class="headerlink" title="2&#x2F;27"></a>2&#x2F;27</h2><p>二分法查找符合条件的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">while</span>(l&lt;r)&#123;<br>    <span class="hljs-comment">//....</span><br>    <span class="hljs-keyword">if</span>(check())&#123;<br>    l = mid + <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-keyword">else</span>&#123;<br>    r = mid;<br>&#125;<br>&#125;<br><br><br><span class="hljs-keyword">return</span> r;<br><span class="hljs-comment">// return l;也对,因为此时l==r，才会退出循环</span><br></code></pre></td></tr></table></figure><p>排序后，要找第一个符合条件的，这样分析</p><p><img src="https://cdn.jsdelivr.net/gh/dutsc/cloud-image/blog-img/202312052038491.png" alt="威哥讲解二分法"></p><p>nnnyyy  （n表示不满足条件，y表示满足条件）</p><p>满足条件了，就保持不变，即r &#x3D; mid</p><p>不满足条件说明mid指向的是n，那么就l&#x3D;mid＋1</p><p>找到一个符合条件的也不要急于返回，因为还可能有更优的，本题中对应，还有更小的符合条件的y</p><p>二分法的题目一定要注意取值范围，不行就把int变为long</p><h4 id="位运算的优先级"><a href="#位运算的优先级" class="headerlink" title="位运算的优先级"></a>位运算的优先级</h4><p><strong>非常低，运算时必须加括号</strong>，否则就会出错</p><p>111222333</p><p>找最小的2，就是（最左边的，符合条件的）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">while</span>(l&lt;r)&#123;<br>    <span class="hljs-type">int</span> mid = ((r-l)&gt;&gt;<span class="hljs-number">1</span>)+l;<br>    <span class="hljs-keyword">if</span>(nums[mid]&lt;target)&#123;<br>        l = mid + <span class="hljs-number">1</span>;<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        r = mid;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">return</span> r;<br></code></pre></td></tr></table></figure><p>找最大的2，就是（最右边的，符合条件的）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">while</span>(l&lt;r)&#123;<br>    <span class="hljs-type">int</span> mid = ((r-l+<span class="hljs-number">1</span>)&gt;&gt;<span class="hljs-number">1</span>)+l;<br>    <span class="hljs-keyword">if</span>(nums[mid]&gt;target)&#123;<br>        r = mid - <span class="hljs-number">1</span>;<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        l = mid;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">return</span> l;<br></code></pre></td></tr></table></figure><p>符合条件，就保持不变，等于mid，而且if中的条件包含等于号的那一部分，也是等于mid，两者是相互对应的。(这个不适用全部的，还是要用check的思想来考虑问题)</p><p>找最左边的符合条件的，则r   right遇到了就保持不变</p><p>找最右边的符合条件的，则l  left遇到了就保持不变</p><h4 id="二分法的本质"><a href="#二分法的本质" class="headerlink" title="二分法的本质"></a>二分法的本质</h4><p>二分法的本质是<strong>二段性</strong>，并不是从一个有序数组中找出一个数（这只是二分法的一个应用）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">search</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-comment">//通过二分找到分割点   整个数组中最小的元素</span><br>        <span class="hljs-keyword">if</span>(n==<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">if</span>(n==<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> target==nums[<span class="hljs-number">0</span>]?<span class="hljs-number">0</span>:<span class="hljs-number">-1</span>;<br>        <span class="hljs-type">int</span> l = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> r = n<span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">while</span>(l&lt;r)&#123;<br>            <span class="hljs-type">int</span> mid = ((r-l+<span class="hljs-number">1</span>)&gt;&gt;<span class="hljs-number">1</span>)+l;<br>            <span class="hljs-keyword">if</span>(nums[mid]&gt;=nums[<span class="hljs-number">0</span>])&#123;<br>                l = mid;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                r = mid - <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(target&lt;nums[<span class="hljs-number">0</span>])&#123;<br>            <span class="hljs-comment">//后半段二分</span><br>            l = l+<span class="hljs-number">1</span>;<br>            r = n<span class="hljs-number">-1</span>;<br>            <span class="hljs-keyword">while</span>(l&lt;r)&#123;<br>                <span class="hljs-type">int</span> mid = ((r-l)&gt;&gt;<span class="hljs-number">1</span>)+l;<br>                <span class="hljs-keyword">if</span>(nums[mid]&lt;target)&#123;<br>                    l = mid + <span class="hljs-number">1</span>;<br>                &#125;<span class="hljs-keyword">else</span>&#123;<br>                    r = mid;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">return</span> target==nums[r]?r:<span class="hljs-number">-1</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-comment">//前半段二分</span><br>            l = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">while</span>(l&lt;r)&#123;<br>                <span class="hljs-type">int</span> mid = ((r-l)&gt;&gt;<span class="hljs-number">1</span>)+l;<br>                <span class="hljs-keyword">if</span>(nums[mid]&lt;target)&#123;<br>                    l = mid + <span class="hljs-number">1</span>;<br>                &#125;<span class="hljs-keyword">else</span>&#123;<br>                    r = mid;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">return</span> target==nums[r]?r:<span class="hljs-number">-1</span>;<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="2-28"><a href="#2-28" class="headerlink" title="2&#x2F;28"></a>2&#x2F;28</h2><h3 id="旋转数组"><a href="#旋转数组" class="headerlink" title="旋转数组"></a>旋转数组</h3><p>有序数组通过旋转转变为部分有序，要找出其中最小（最大）的元素，要使用二分法。</p><p>找到最大的元素比较方便，使用向上取整，l &#x3D; mid，因为此时可以避免nums[mid]与nums[0]是同一个元素，避免了极端情况的错误。</p><p>找到最大元素的下标后，判断是不是最后一个元素，若是最后一个元素，则若找最小的元素要返回nums[0]；若不是最后一个元素，则返回nums[l+1]即可。</p><p>有重复元素的代码模板</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findMin</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> l = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> r = n<span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">while</span>(r&gt;<span class="hljs-number">0</span> &amp;&amp; nums[<span class="hljs-number">0</span>]==nums[r]) r--;<br>        <span class="hljs-keyword">if</span>(r==l) <span class="hljs-keyword">return</span> nums[l];<br>        <span class="hljs-keyword">while</span>(l&lt;r)&#123;<br>            <span class="hljs-type">int</span> mid = ((r-l+<span class="hljs-number">1</span>)&gt;&gt;<span class="hljs-number">1</span>)+l;<br>            <span class="hljs-keyword">if</span>(nums[mid]&gt;=nums[<span class="hljs-number">0</span>]) l = mid;<br>            <span class="hljs-keyword">else</span> r = mid - <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(l==n<span class="hljs-number">-1</span>)&#123;<br>            <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>];<br>        &#125;<br>        <span class="hljs-keyword">return</span> nums[l+<span class="hljs-number">1</span>];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="3-1"><a href="#3-1" class="headerlink" title="3&#x2F;1"></a>3&#x2F;1</h2><p>向上取整的方法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">(n<span class="hljs-number">-1</span>)/m+<span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><h2 id="3-7"><a href="#3-7" class="headerlink" title="3&#x2F;7"></a>3&#x2F;7</h2><h3 id="快速将数字转成n进制表示的字符串"><a href="#快速将数字转成n进制表示的字符串" class="headerlink" title="快速将数字转成n进制表示的字符串"></a>快速将数字转成n进制表示的字符串</h3><p>Integer.toString(int par1,int par2),par1表示要转成字符串的数字，par2表示要转成的进制表示，如：</p><p>Integer.toString(22,2),表示把22转成2进制表示的字符串，</p><p>Integer.toString(22,10),表示把22转成10进制表示的字符串，</p><p>Integer.toString(22,16),表示把22转成16进制表示的字符串，</p><p>Integer.toString(22,36),表示把22转成36进制表示的字符串，即10到36之间的数字表示为a到z的表示</p><h3 id="二维前缀和模板"><a href="#二维前缀和模板" class="headerlink" title="二维前缀和模板"></a>二维前缀和模板</h3><p>「二维前缀和」解决的是二维矩阵中的矩形区域求和问题。</p><p>二维前缀和数组中的每一个格子记录的是「以当前位置为区域的右下角（区域左上角恒定为原数组的左上角）的区域和」</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 预处理前缀和数组</span><br>&#123;<br>    sum = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">1</span>][m + <span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt;= m; j++) &#123;<br>            <span class="hljs-comment">// 当前格子(和) = 上方的格子(和) + 左边的格子(和) - 左上角的格子(和) + 当前格子(值)【和是指对应的前缀和，值是指原数组中的值】</span><br>            sum[i][j] = sum[i - <span class="hljs-number">1</span>][j] + sum[i][j - <span class="hljs-number">1</span>] - sum[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] + matrix[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>];<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 首先我们要令左上角为 (x1, y1) 右下角为 (x2, y2)</span><br><span class="hljs-comment">// 计算 (x1, y1, x2, y2) 的结果</span><br>&#123;<br>    <span class="hljs-comment">// 前缀和是从 1 开始，原数组是从 0 开始，上来先将原数组坐标全部 +1，转换为前缀和坐标</span><br>    x1++; y1++; x2++; y2++;<br>    <span class="hljs-comment">// 记作 22 - 12 - 21 + 11，然后 不减，减第一位，减第二位，减两位</span><br>    <span class="hljs-comment">// 也可以记作 22 - 12(x - 1) - 21(y - 1) + 11(x y 都 - 1)</span><br>    ans = sum[x2][y2] - sum[x1 - <span class="hljs-number">1</span>][y2] - sum[x2][y1 - <span class="hljs-number">1</span>] + sum[x1 - <span class="hljs-number">1</span>][y1 - <span class="hljs-number">1</span>];<br>&#125;<br><br><br></code></pre></td></tr></table></figure><h3 id="前缀和、树状数组、线段树选择"><a href="#前缀和、树状数组、线段树选择" class="headerlink" title="前缀和、树状数组、线段树选择"></a>前缀和、树状数组、线段树选择</h3><p>针对不同的题目，我们有不同的方案可以选择（假设我们有一个数组）：</p><p>数组不变，求区间和：「前缀和」、「树状数组」、「线段树」</p><p>多次修改某个数，求区间和：「树状数组」、「线段树」</p><p>多次整体修改某个区间，求区间和：「线段树」、「树状数组」（看修改区间的数据范围）</p><p>多次将某个区间变成同一个数，求区间和：「线段树」、「树状数组」（看修改区间的数据范围）</p><p>这样看来，「线段树」能解决的问题是最多的，那我们是不是无论什么情况都写「线段树」呢？</p><p>答案并不是，而且恰好相反，只有在我们遇到第 4 类问题，不得不写「线段树」的时候，我们才考虑线段树。</p><p>因为「线段树」代码很长，而且常数很大，实际表现不算很好。我们只有在不得不用的时候才考虑「线段树」。</p><p>总结一下，我们应该按这样的优先级进行考虑：</p><p>简单求区间和，用「前缀和」<br>多次将某个区间变成同一个数，用「线段树」<br>其他情况，用「树状数组」</p><h4 id="树状数组模板"><a href="#树状数组模板" class="headerlink" title="树状数组模板"></a>树状数组模板</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 上来先把三个方法写出来</span><br>&#123;<br>    <span class="hljs-type">int</span>[] tree;<br>    <span class="hljs-type">int</span> <span class="hljs-title function_">lowbit</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> &#123;<br>        <span class="hljs-keyword">return</span> x &amp; -x;<br>    &#125;<br>    <span class="hljs-comment">// 查询前缀和的方法</span><br>    <span class="hljs-type">int</span> <span class="hljs-title function_">query</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> x; i &gt; <span class="hljs-number">0</span>; i -= lowbit(i)) ans += tree[i];<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>    <span class="hljs-comment">// 在树状数组 x 位置中增加值 u</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> u)</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> x; i &lt;= n; i += lowbit(i)) tree[i] += u;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 初始化「树状数组」，要默认数组是从 1 开始</span><br>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) add(i + <span class="hljs-number">1</span>, nums[i]);<br>&#125;<br><br><span class="hljs-comment">// 使用「树状数组」：</span><br>&#123;   <br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">update</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> val)</span> &#123;<br>        <span class="hljs-comment">// 原有的值是 nums[i]，要使得修改为 val，需要增加 val - nums[i]</span><br>        add(i + <span class="hljs-number">1</span>, val - nums[i]); <br>        nums[i] = val;<br>    &#125;<br>    <br>    <span class="hljs-type">int</span> <span class="hljs-title function_">sumRange</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> &#123;<br>        <span class="hljs-keyword">return</span> query(r + <span class="hljs-number">1</span>) - query(l);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>求两个数组（一个数组也可以）中相加等于target的数对的个数</p><p>O(nlogn)</p><ol><li><p>先对两个数组排序</p></li><li><p>用双指针法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//一个从头开始遍历，一个从尾开始遍历,和小于sum则左边++，和大于sum则右边--</span><br>Arrays.sort(nums1);<br>Arrays.sort(nums2);<br><span class="hljs-keyword">while</span>(i&lt;n &amp;&amp; j&gt;=<span class="hljs-number">0</span>)&#123;<br>    <span class="hljs-keyword">if</span>(nums1[i]+nums[j]&lt;target)&#123;<br>        i++;<br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nums1[i]+nums[j]&gt;target)&#123;<br>        j--;<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        i++;<br>        j--;<br>        res++;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h2 id="3-8"><a href="#3-8" class="headerlink" title="3&#x2F;8"></a>3&#x2F;8</h2><p>前缀和数组的下标数量通常比数组的下标数量多1.</p><p>树状数组需要结合差分数组才能完成区间修改+单点查询</p><h3 id="差分数组"><a href="#差分数组" class="headerlink" title="差分数组"></a>差分数组</h3><p>区间修改，单点查询</p><p>差分数组比原数组多一位，且最后一位什么也不表示，求前缀和的时候也不用管他。</p><p>可以看到，如果需要对L<del>R 范围内所有数都进行相同的操作，我们不需要从L</del>R遍历arr然后在每个值上进行相同操作，只需要在差分数组d中改变L和R+1的值即可。但是在查询arr数组中某个位置的数时，却要根据差分数组从前往后递推求值。（求前缀和）</p><h2 id="3-10"><a href="#3-10" class="headerlink" title="3&#x2F;10"></a>3&#x2F;10</h2><p>连续异或运算也可以使用前缀异或，但是要利用一个特性：相同的值异或结果为0</p><p>本质上还是利用集合（区间结果）的容斥原理。只不过前缀和需要利用「减法（逆运算）」做容斥，而前缀异或是利用「相同数值进行异或结果为 00（偶数次的异或结果为 00）」的特性实现容斥.</p><h3 id="归并排序求逆序对的数目"><a href="#归并排序求逆序对的数目" class="headerlink" title="归并排序求逆序对的数目"></a>归并排序求逆序对的数目</h3><p>思想：每一次合并时，统计右边的数组对逆序对的贡献。若左边数组还没合并完成，右边的数先合并到总数组中，那么右边合并的数就会对逆序对产生贡献，产生的贡献为<strong>左边数组剩余的数字的数目</strong></p><p>注意，归并排序中有一个优化，即在递归的过程中，若两个小数组分别排序后，合并之前，首先判断一下$nums[mid]$ 与$nums[mid+1]$ 的大小关系。若$$nums[mid] \leq nums[mid+1]$$ </p><p>则可以直接返回左边数组的逆序对的数目+右边数组的逆序对的数目，而不必计算合并时产生的逆序对的数目$crossNum$ .但是注意，只有在合并函数merge中才有逆序对计数操作。</p><h2 id="3-11"><a href="#3-11" class="headerlink" title="3&#x2F;11"></a>3&#x2F;11</h2><h3 id="建图"><a href="#建图" class="headerlink" title="建图"></a>建图</h3><p>建图，使用邻接表</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;Integer&gt;[] children = <span class="hljs-keyword">new</span> <span class="hljs-title class_">List</span>[n];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i&lt;n;++i)&#123;<br>            children[i] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i&lt;n;++i)&#123;<br>            <span class="hljs-keyword">if</span>(parents[i]!=-<span class="hljs-number">1</span>) <br>            &#123;<br>                children[parents[i]].add(i);<br>                <span class="hljs-comment">// children[i].add(parents[i]);</span><br>            &#125;<br>        &#125;<br></code></pre></td></tr></table></figure><p>建一个List数组，然后对每一个List元素，进行new ArrayList&lt;&gt;()</p><p>dfs返回以参数root为根的树的节点个数，但同时利用全局变量计算分数。若两次统计，会超时（先计算最大分数，再统计个数会超时）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(List&lt;Integer&gt;[] children,<span class="hljs-type">int</span> n,<span class="hljs-type">int</span> id)</span>&#123;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">score</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i&lt;children[id].size();++i)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> dfs(children,n,children[id].get(i));<br>            sum += t;<br>            score *= t;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(id!=<span class="hljs-number">0</span>) score*=(n-sum);<br>        <span class="hljs-keyword">if</span>(maxScore==score)&#123;<br>            count++;<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(maxScore&lt;score)&#123;<br>            maxScore = score;<br>            count=<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> sum;<br>    &#125;<br></code></pre></td></tr></table></figure><p>那种深度优先遍历的题目，List里面嵌套List，记得res.add(path) 这样写是<strong>不对</strong>的，因为path后续修改时，也会修改res中的值，因为add的是引用。所以应当这样写：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">res.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(path));<br></code></pre></td></tr></table></figure><h2 id="3-12"><a href="#3-12" class="headerlink" title="3&#x2F;12"></a>3&#x2F;12</h2><h3 id="注意-1"><a href="#注意-1" class="headerlink" title="注意"></a>注意</h3><p>在写dfs的时候，要在一开始就写used[i]&#x3D;true。一开始访问到就要把used数组置为true</p><h3 id="使用dfs求连通分量的个数"><a href="#使用dfs求连通分量的个数" class="headerlink" title="使用dfs求连通分量的个数"></a>使用dfs求连通分量的个数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">makeConnected</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span>[][] connections)</span> &#123;<br>        <span class="hljs-comment">//1.求边的条数m，m&lt;n-1   -1</span><br>        <span class="hljs-comment">//2.求连通分量的个数 mnum  然后-1</span><br>        <span class="hljs-keyword">if</span>(connections.length&lt;n-<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        List&lt;Integer&gt;[] link = <span class="hljs-keyword">new</span> <span class="hljs-title class_">List</span>[n];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i&lt;n;++i)&#123;<br>            link[i] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span>[] con:connections)&#123;<br>            link[con[<span class="hljs-number">0</span>]].add(con[<span class="hljs-number">1</span>]);<br>            link[con[<span class="hljs-number">1</span>]].add(con[<span class="hljs-number">0</span>]);<br>        &#125;<span class="hljs-comment">//建图完成</span><br>        <span class="hljs-type">boolean</span>[] used = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[n];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i&lt;n;++i)&#123;<br>            <span class="hljs-keyword">if</span>(!used[i])&#123;<br>                dfs(i,used,link);<br>                ans++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans-<span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> i,<span class="hljs-type">boolean</span>[] used,List&lt;Integer&gt;[] link)</span>&#123;<br>        used[i] = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">for</span>(Integer j:link[i])&#123;<br>            <span class="hljs-keyword">if</span>(!used[j])&#123;<br>                dfs(j,used,link);<br>            &#125;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="求最大连通分量"><a href="#求最大连通分量" class="headerlink" title="求最大连通分量"></a>求最大连通分量</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">makeConnected</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span>[][] connections)</span> &#123;<br>    <span class="hljs-comment">//1.求边的条数m，m&lt;n-1   -1</span><br>    <span class="hljs-keyword">if</span>(connections.length&lt;n-<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    List&lt;Integer&gt;[] link = <span class="hljs-keyword">new</span> <span class="hljs-title class_">List</span>[n];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i&lt;n;++i)&#123;<br>        link[i] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span>[] con:connections)&#123;<br>        link[con[<span class="hljs-number">0</span>]].add(con[<span class="hljs-number">1</span>]);<br>        link[con[<span class="hljs-number">1</span>]].add(con[<span class="hljs-number">0</span>]);<br>    &#125;<span class="hljs-comment">//建图完成</span><br>    <span class="hljs-type">boolean</span>[] used = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[n];<br>    <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i&lt;n;++i)&#123;<br>        <span class="hljs-keyword">if</span>(!used[i])&#123;<br>            ans = Math.max(dfs(i,used,link),ans);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br><span class="hljs-type">int</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> i,<span class="hljs-type">boolean</span>[] used,List&lt;Integer&gt;[] link)</span>&#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>    used[i] = <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">for</span>(Integer j:link[i])&#123;<br>        <span class="hljs-keyword">if</span>(!used[j])&#123;<br>            t+=dfs(j,used,link);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> t;<br>&#125;<br></code></pre></td></tr></table></figure><p>判断从start到target有没有通路，注意注意</p><p>dfs中不能直接返回</p><h3 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h3><p>使用并查集统计有多少个连通分量：统计有多少个<strong>祖先</strong> $fa[i]&#x3D;&#x3D;i$</p><p>并查集实现注意点：为了避免出现二叉搜索树中的退化问题，要做到下面两点：</p><ol><li>对于每棵树，记录这棵树的高度rank。</li><li>合并时如果两棵树的rank不同，则从rank小的向rank大的连边。</li></ol><h4 id="路径压缩"><a href="#路径压缩" class="headerlink" title="路径压缩"></a>路径压缩</h4><p>对于每个节点，一旦向上走到了一次根节点，就把这个点到父亲的边改为直接连向根。</p><p>在此之上，不仅仅是所查询的节点，在查询过程中向上经过的所有的节点，都改为直接连到根上。这样再次查询这些节点时，就可以很快知道是谁了。</p><p>在使用这种简化方法时，为了简单起见，即使树的高度发生了变化，我们也不修改rank的值。</p><h3 id="并查集的实现"><a href="#并查集的实现" class="headerlink" title="并查集的实现"></a>并查集的实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> par[MAX_N]; <span class="hljs-comment">// 父亲</span><br><span class="hljs-type">int</span> rank[MAX_N]; <span class="hljs-comment">// 树的高度</span><br><span class="hljs-comment">//初始化n个元素</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i&lt;n;++i)&#123;<br>        par[i] = i;<br>        rank[i] = <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 查询树的根</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(par[x]==x) <span class="hljs-keyword">return</span> x;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> par[x]=<span class="hljs-built_in">find</span>(par[x]);<br>&#125;<br><br><span class="hljs-comment">// 合并x和y所属的集合</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">unite</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span></span>&#123;<br>    x = <span class="hljs-built_in">find</span>(x);<br>    y = <span class="hljs-built_in">find</span>(y);<br>    <span class="hljs-keyword">if</span>(x==y) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-keyword">if</span>(rank[x]&lt;rank[y])&#123;<br>        par[x] = y;<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        par[y] = x;<br>        <span class="hljs-keyword">if</span>(rank[x]==rank[y]) rank[x]++;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 判断x和y是否属于同一个集合</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">same</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">find</span>(x)==<span class="hljs-built_in">find</span>(y);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-13"><a href="#3-13" class="headerlink" title="3&#x2F;13"></a>3&#x2F;13</h2><h3 id="迪杰斯特拉算法-最短路"><a href="#迪杰斯特拉算法-最短路" class="headerlink" title="迪杰斯特拉算法 最短路"></a>迪杰斯特拉算法 最短路</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">networkDelayTime</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] times, <span class="hljs-type">int</span> n, <span class="hljs-type">int</span> k)</span> &#123;<br>        List&lt;<span class="hljs-type">int</span>[]&gt;[] link = <span class="hljs-keyword">new</span> <span class="hljs-title class_">List</span>[n+<span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;i&lt;=n;++i)&#123;<br>            link[i] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        &#125;<br>        <span class="hljs-type">int</span>[] dist = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n+<span class="hljs-number">1</span>];<br>        Arrays.fill(dist,Integer.MAX_VALUE);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span>[] time:times)&#123;<br>            link[time[<span class="hljs-number">0</span>]].add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;time[<span class="hljs-number">1</span>],time[<span class="hljs-number">2</span>]&#125;);<br>        &#125;<br>        <span class="hljs-type">boolean</span>[] used = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[n+<span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i&lt;link[k].size();++i)&#123;<br>            dist[link[k].get(i)[<span class="hljs-number">0</span>]] = link[k].get(i)[<span class="hljs-number">1</span>];<br>        &#125;<br>        used[k] = <span class="hljs-literal">true</span>;<br>        dist[<span class="hljs-number">0</span>] = -<span class="hljs-number">1</span>;<br>        dist[k] = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i&lt;n-<span class="hljs-number">1</span>;++i)&#123;<span class="hljs-comment">//在S-V集合中进行n-1次搜索</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> Integer.MAX_VALUE;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> k;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;j&lt;=n;++j)<span class="hljs-comment">//寻找本轮循环中dist数组中的最小值</span><br>                <span class="hljs-keyword">if</span>(!used[j] &amp;&amp; dist[j]&lt;temp)&#123;<br>                    temp = dist[j];<span class="hljs-comment">//最小值是多少</span><br>                    t = j;<span class="hljs-comment">//第几个节点</span><br>                &#125;<br>            <span class="hljs-keyword">if</span>(t==k) <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>            used[t] = <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;j&lt;link[t].size();++j)&#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">to</span> <span class="hljs-operator">=</span> link[t].get(j)[<span class="hljs-number">0</span>];<br>                <span class="hljs-type">int</span> <span class="hljs-variable">w</span> <span class="hljs-operator">=</span> link[t].get(j)[<span class="hljs-number">1</span>];<br>                <span class="hljs-keyword">if</span>(!used[to] &amp;&amp; dist[to]&gt;dist[t]+w)&#123;<br>                    dist[to] = dist[t]+w;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> Arrays.stream(dist).max().getAsInt();<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>堆优化的dijkstra</p><p>注意要有used数组来标识，否则会无限入堆，会超时</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java">    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span>[] Dijkstra(List&lt;Integer&gt;[] list,<span class="hljs-type">int</span> n)&#123;<br>        <span class="hljs-type">boolean</span>[] used = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[n];<br>        <span class="hljs-type">int</span>[] dist = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        Arrays.fill(dist,INF);<br>        dist[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>        Queue&lt;<span class="hljs-type">int</span>[]&gt; que = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;&gt;((o1,o2)-&gt;o1[<span class="hljs-number">0</span>]-o2[<span class="hljs-number">0</span>]);<br>        que.offer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;dist[<span class="hljs-number">0</span>],<span class="hljs-number">0</span>&#125;);<br>        <span class="hljs-keyword">while</span>(!que.isEmpty())&#123;<br>            <span class="hljs-type">int</span>[] info = que.poll();<br>            <span class="hljs-type">int</span> <span class="hljs-variable">from</span> <span class="hljs-operator">=</span> info[<span class="hljs-number">1</span>];<br>            <span class="hljs-type">int</span> <span class="hljs-variable">cost</span> <span class="hljs-operator">=</span> info[<span class="hljs-number">0</span>];<br>            <span class="hljs-keyword">if</span>(used[from]) <span class="hljs-keyword">continue</span>;<br>            used[from] = <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">for</span>(Integer l:list[from])&#123;<br>                dist[l] = Math.min(dist[l],dist[from]+<span class="hljs-number">1</span>);<span class="hljs-comment">// 这里不推荐这样写 最好写cost+1，因为在求第二短的路径中这样写是错误的，而cost那样写就是对的</span><br>                que.offer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;dist[l],l&#125;);<span class="hljs-comment">// 可以写一个if，只有更新时才入队，这样就可以不必使用used数组   </span><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dist;<br>    &#125;<br><br><br><span class="hljs-comment">// 创建一个数组存储最短路径上，每一个节点的前一个节点的编号。可利用此数组求出源点到任意一个节点的具体最短路径</span><br><span class="hljs-comment">// k是源点</span><br>        <span class="hljs-type">int</span>[] p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n+<span class="hljs-number">1</span>];<br>        Arrays.fill(p,-<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i&lt;list[k].size();++i)&#123;<br>            <span class="hljs-type">int</span>[] info = list[k].get(i);<br>            p[info[<span class="hljs-number">0</span>]] = k;<br>        &#125;<br><br><span class="hljs-comment">// 下面就是求源点与某一个节点具体最短路径的步骤。注意k是源点，pre是终点</span><br>        <span class="hljs-type">int</span>[] stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n+<span class="hljs-number">1</span>];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">top</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">pre</span> <span class="hljs-operator">=</span> target;<br>        <span class="hljs-keyword">if</span>(pre!=k) stack[top++]=pre;<br>        <span class="hljs-keyword">while</span>(p[pre]!=-<span class="hljs-number">1</span> &amp;&amp; p[pre]!=k)&#123;<br>            stack[top++] = p[pre];<br>            pre = p[pre];<br>        &#125;<br>        stack[top++]=k;<br>        <span class="hljs-keyword">while</span>(top&gt;<span class="hljs-number">0</span>)&#123;<br>            System.out.println(stack[--top]);<br>        &#125;<br></code></pre></td></tr></table></figure><h2 id="3-18"><a href="#3-18" class="headerlink" title="3&#x2F;18"></a>3&#x2F;18</h2><h3 id="存图方式"><a href="#存图方式" class="headerlink" title="存图方式"></a>存图方式</h3><h4 id="邻接矩阵"><a href="#邻接矩阵" class="headerlink" title="邻接矩阵"></a>邻接矩阵</h4><p>适用于边数较多的<strong>稠密图</strong>使用，当边数量接近点的数量的平方，即 m \approx n^2<em>m</em>≈<em>n</em>2 时，可定义为<strong>稠密图</strong>。</p><h3 id="邻接表"><a href="#邻接表" class="headerlink" title="邻接表"></a>邻接表</h3><p><strong>链式前向星存图</strong></p><p>适用于边数较少的<strong>稀疏图</strong>使用，当边数量接近点的数量，即 m \approx n<em>m</em>≈<em>n</em> 时，可定义为<strong>稀疏图</strong>。</p><h3 id="类（边集数组）"><a href="#类（边集数组）" class="headerlink" title="类（边集数组）"></a>类（边集数组）</h3><p>Bellman-Ford算法使用，当然，该算法也可以使用邻接矩阵</p><h3 id="0x3f3f3f3f"><a href="#0x3f3f3f3f" class="headerlink" title="0x3f3f3f3f"></a>0x3f3f3f3f</h3><p>当作无穷大，很好用，无穷大加无穷大还是无穷大，并不会溢出</p><p>最后，0x3f3f3f3f还能给我们带来一个意想不到的额外好处：<br>如果我们想要将某个数组清零，我们通常会使用memset(a,0,sizeof(a))，方便又高效，但是当我们想将某个数组全部赋值为无穷大时，就不能使用memset函数而得自己写循环了，因为memset是按字节操作的，它能够对数组清零是因为0的每个字节都是0（一般我们只有赋值为-1和0的时候才使用它）。现在好了，如果我们将无穷大设为0x3f3f3f3f，那么奇迹就发生了，0x3f3f3f3f的每个字节都是0x3f！所以要把一段内存全部置为无穷大，我们只需要memset(a,0x3f,sizeof(a))。</p><h2 id="3-19"><a href="#3-19" class="headerlink" title="3&#x2F;19"></a>3&#x2F;19</h2><h3 id="链式前向星"><a href="#链式前向星" class="headerlink" title="链式前向星"></a>链式前向星</h3><p>有向图</p><p><img src="E:/Download/qq/mpFile/1020018707/Image/Group2/@2/KR/@2KRSGV6HC2%5BZ61RPPI5%7DY5.png" alt="img"></p><p>无向图</p><p><img src="E:/Download/qq/mpFile/1020018707/Image/Group2/KK/7J/KK7J737S%5DT%7D7_XFOJSBOS3I.png" alt="img"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">read</span><span class="hljs-params">()</span>&#123;<br>        n = s.nextInt();<span class="hljs-comment">//节点数</span><br>        m = s.nextInt();<span class="hljs-comment">//边数</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= m; i++) &#123;<span class="hljs-comment">//边的编号从1开始</span><br>            <span class="hljs-comment">//head[node]是以node为起点的第一条边的编号</span><br>            <span class="hljs-comment">//next[edge]是和edge同起点的下一条边的编号</span><br>            <span class="hljs-comment">//to[edge]是编号为edge的这条边的终点</span><br>            <span class="hljs-comment">//还可以加一个weighe[edge]表示边权</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">f</span> <span class="hljs-operator">=</span> s.nextInt();<br>            <span class="hljs-type">int</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> s.nextInt();<br>            next[<span class="hljs-number">2</span> * i] = head[f];<br>            to[<span class="hljs-number">2</span> * i] = t;<br>            head[f] = <span class="hljs-number">2</span> * i;<br><br>            next[<span class="hljs-number">2</span> * i + <span class="hljs-number">1</span>] = head[t];<br>            to[<span class="hljs-number">2</span> * i + <span class="hljs-number">1</span>] = f;<br>            head[t] = <span class="hljs-number">2</span> * i + <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br><br><br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">read</span><span class="hljs-params">()</span>&#123;<br>        n = s.nextInt();<span class="hljs-comment">//节点数</span><br>        m = s.nextInt();<span class="hljs-comment">//边数</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= m; i++) &#123;<span class="hljs-comment">//边的编号从1开始</span><br>            <span class="hljs-comment">//head[node]是以node为起点的第一条边的编号</span><br>            <span class="hljs-comment">//next[edge]是和edge同起点的下一条边的编号</span><br>            <span class="hljs-comment">//to[edge]是编号为edge的这条边的终点</span><br>            <span class="hljs-comment">//还可以加一个weighe[edge]表示边权</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">f</span> <span class="hljs-operator">=</span> s.nextInt();<br>            <span class="hljs-type">int</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> s.nextInt();<br>            next[<span class="hljs-number">2</span> * i] = head[f];<br>            to[<span class="hljs-number">2</span> * i] = t;<br>            head[f] = <span class="hljs-number">2</span> * i;<br><br>            next[<span class="hljs-number">2</span> * i + <span class="hljs-number">1</span>] = head[t];<br>            to[<span class="hljs-number">2</span> * i + <span class="hljs-number">1</span>] = f;<br>            head[t] = <span class="hljs-number">2</span> * i + <span class="hljs-number">1</span>;<br>        &#125;<br>        <br>        <span class="hljs-comment">//用的话就是</span><br>        <span class="hljs-comment">//for(int p = head[x]; p != 0; p = next[p])&#123;</span><br>        <span class="hljs-comment">//    dfs(to[p]);</span><br>        <span class="hljs-comment">//&#125;</span><br>    &#125;<br><br></code></pre></td></tr></table></figure><h2 id="3-20"><a href="#3-20" class="headerlink" title="3&#x2F;20"></a>3&#x2F;20</h2><h3 id="pair"><a href="#pair" class="headerlink" title="pair"></a>pair</h3><p>因为pair重写了equals方法，往堆里放的话还要重写compareTo</p><p><img src="https://cdn.jsdelivr.net/gh/dutsc/cloud-image/blog-img/202312052037784.png" alt="https://gitee.com/dutsc/cloud-images/raw/master/images/202212041129879.png"></p><p><img src="https://cdn.jsdelivr.net/gh/dutsc/cloud-image/blog-img/202312052038427.png"></p><p>这样写得到的是小顶堆</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">E</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Comparable</span>&lt;E&gt;&#123;<br>    <span class="hljs-type">int</span> x, y, z;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">E</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b, <span class="hljs-type">int</span> c)</span>&#123;<br>        x = a; y = b; z = c;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compareTo</span><span class="hljs-params">(E e)</span>&#123;<br>        <span class="hljs-keyword">if</span>(x &lt; e.x) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(x &gt; e.x) <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">if</span>(y == e.y) <span class="hljs-keyword">return</span> z - e.z;<br>            <span class="hljs-keyword">return</span> y - e.y;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hashCode</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> y*<span class="hljs-number">1000000</span> + z;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hashCode</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> Objects.hash(y,z);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">equals</span><span class="hljs-params">(Object obj)</span>&#123;<br>        <span class="hljs-keyword">if</span>(obj == <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-type">E</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> (E)obj;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">this</span>.y == e.y &amp;&amp; <span class="hljs-built_in">this</span>.z == e.z)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;E(&quot;</span>+x+<span class="hljs-string">&quot;,&quot;</span>+y+<span class="hljs-string">&quot;,&quot;</span>+z+<span class="hljs-string">&quot;)&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/dutsc/cloud-image/blog-img/202312052038456.png"></p><p>学习一下Idea中hashCode的写法</p><h3 id="扁平化"><a href="#扁平化" class="headerlink" title="扁平化"></a>扁平化</h3><p>一般三个的数据可以把它变成两个，如a,b,w    坐标(a,b) 和权重w</p><p><strong>结合数据范围，进行扁平化   把a,b变成1000*a+b这样的</strong>     也可以考虑变成字符串，然后再split</p><h4 id="二维矩阵编号"><a href="#二维矩阵编号" class="headerlink" title="二维矩阵编号"></a>二维矩阵编号</h4><p>二维矩阵中，将矩阵中的每一个单元格按顺序进行编号的方法：</p><p>这是一个通用的二维矩阵使用转为顺序编号的做法 </p><p>记住对于 row * col 的矩阵，任意的点 (i,j) 可以使用 i * col + j 转化为顺序编码 idx （等价于从上往下 从左到右编号）</p><p>反过来将 idx 恢复成 (i,j) 表示只需要 (idx &#x2F; col, idx % col) 即可</p><h3 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h3><p>放到HashMap  key部分的元素，和放到HashSet部分的元素，需要同时重写hashCode()和equals()方法</p><h2 id="3-22"><a href="#3-22" class="headerlink" title="3&#x2F;22"></a>3&#x2F;22</h2><h3 id="dp与图论"><a href="#dp与图论" class="headerlink" title="dp与图论"></a>dp与图论</h3><p>只有拓扑图的图论问题，才能使用dp求解，若不是拓扑图，则只能使用图论的方法求解。</p><h3 id="bfs超时问题"><a href="#bfs超时问题" class="headerlink" title="bfs超时问题"></a>bfs超时问题</h3><p>使用bfs时，注意used数组何时置为true很重要。</p><p>入队时把节点置为true  而不要出队时（也不一定）</p><h3 id="dfs回溯问题"><a href="#dfs回溯问题" class="headerlink" title="dfs回溯问题"></a>dfs回溯问题</h3><p>如果是纯粹的回溯问题，一定要确保每一步都要回溯，容易忘记回溯的几个地方</p><ol><li><p>sb.deleteCharAt(sb,length()-1);</p></li><li><p>used[x] [y] &#x3D; true<br>…….</p><p>used[x] [y] &#x3D; false</p></li></ol><p>如果是字符二维数组，则要确定是否访问过，并不需要多开一个used数组，直接把该位置的字符置成一个没有出现过的字符即可。</p><h2 id="3-23"><a href="#3-23" class="headerlink" title="3&#x2F;23"></a>3&#x2F;23</h2><h3 id="回溯时最容易忘记的部分"><a href="#回溯时最容易忘记的部分" class="headerlink" title="回溯时最容易忘记的部分"></a>回溯时最容易忘记的部分</h3><p>used数组是最容易忘记回溯的部分</p><h3 id="矩阵快速幂-1"><a href="#矩阵快速幂-1" class="headerlink" title="矩阵快速幂"></a>矩阵快速幂</h3><h4 id="可以用于求解数列递推问题"><a href="#可以用于求解数列递推问题" class="headerlink" title="可以用于求解数列递推问题"></a>可以用于求解数列递推问题</h4><p>矩阵快速幂用于求解一般性问题：给定大小为 n * n 的矩阵 M，求答案矩阵 M^k<br> ，并对答案矩阵中的每位元素对 PP取模。</p><p>在上述两种解法中，当我们要求解 f[i] 时，需要将 f[0] 到 f[n−1] 都算一遍，因此需要线性的复杂度。</p><p>对于此类的「数列递推」问题，我们可以使用「矩阵快速幂」来进行加速（比如要递归一个长度为 1e9 的数列，线性复杂度会被卡）。</p><p>使用矩阵快速幂，我们只需要 O(\log{n}) 的复杂度。</p><h4 id="矩阵乘法"><a href="#矩阵乘法" class="headerlink" title="矩阵乘法"></a>矩阵乘法</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">100</span>;<br> <br><span class="hljs-type">int</span> c[N][N];<br> <br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">multi</span><span class="hljs-params">(<span class="hljs-type">int</span> a[][N],<span class="hljs-type">int</span> b[][N],<span class="hljs-type">int</span> n)</span><span class="hljs-comment">//n是矩阵大小，n&lt;N</span></span><br><span class="hljs-function"> </span><br><span class="hljs-function"></span>&#123;<br> <br><span class="hljs-built_in">memset</span>(c,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span> c);<br> <br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br> <br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;j++)<br> <br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">1</span>;k&lt;=n;k++)<br> <br>c[i][j]+=a[i][k]*b[k][j];<br> <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="字节常考"><a href="#字节常考" class="headerlink" title="字节常考"></a>字节常考</h3><ol start="25"><li><p>K 个一组翻转链表</p></li><li><p>接雨水 </p></li><li><p>合并K个排序链表 </p></li><li><p>缺失的第一个正数 124. 二叉树中的最大路径和 76. 最小覆盖子串 32. 最长有效括号 72. 编辑距离 4. 寻找两个正序数组的中位数 239. 滑动窗口最大值 字节hard top10欢迎你</p></li></ol><h2 id="3-24"><a href="#3-24" class="headerlink" title="3&#x2F;24"></a>3&#x2F;24</h2><h3 id="难以处理的边界问题"><a href="#难以处理的边界问题" class="headerlink" title="难以处理的边界问题"></a>难以处理的边界问题</h3><p>遇到难以处理的边界问题时，要灵活运用max(i-1,0)  和 min(i+1,m-1)  进行处理，而不是无谓地写很多if语句判断</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[][] imageSmoother(<span class="hljs-type">int</span>[][] img) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> img.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> img[<span class="hljs-number">0</span>].length;<br>        <span class="hljs-type">int</span>[][] temp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[m][n];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i&lt;m;++i)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;j&lt;n;++j)&#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> Math.max(i-<span class="hljs-number">1</span>,<span class="hljs-number">0</span>);<br>                <span class="hljs-type">int</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> Math.min(m-<span class="hljs-number">1</span>,i+<span class="hljs-number">1</span>);<br>                <span class="hljs-type">int</span> <span class="hljs-variable">up</span> <span class="hljs-operator">=</span> Math.max(j-<span class="hljs-number">1</span>,<span class="hljs-number">0</span>);<br>                <span class="hljs-type">int</span> <span class="hljs-variable">down</span> <span class="hljs-operator">=</span> Math.min(j+<span class="hljs-number">1</span>,n-<span class="hljs-number">1</span>);<br>                <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> l;x&lt;=r;++x)&#123;<br>                    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">y</span> <span class="hljs-operator">=</span> up;y&lt;=down;++y)&#123;<br>                        num++;<br>                        ans+=img[x][y];<br>                    &#125;<br>                &#125;<br>                temp[i][j] = ans/num;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> temp;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>周赛那个k近邻也是一样</p><h3 id="字典序"><a href="#字典序" class="headerlink" title="字典序"></a>字典序</h3><p>数字的字典序，就是根据数字的前缀进行排序</p><h2 id="3-25"><a href="#3-25" class="headerlink" title="3&#x2F;25"></a>3&#x2F;25</h2><h3 id="字符串去重"><a href="#字符串去重" class="headerlink" title="字符串去重"></a>字符串去重</h3><p>遇到字符串去重问题时，考虑统计以每一个字符结尾的长度最长的符合要求的字符串的数量，最后再加起来</p><h2 id="3-30"><a href="#3-30" class="headerlink" title="3&#x2F;30"></a>3&#x2F;30</h2><h3 id="乘积最大子数组"><a href="#乘积最大子数组" class="headerlink" title="乘积最大子数组"></a>乘积最大子数组</h3><p><img src="https://cdn.jsdelivr.net/gh/dutsc/cloud-image/blog-img/202312052038901.png"></p><h3 id="数据范围问题"><a href="#数据范围问题" class="headerlink" title="数据范围问题"></a>数据范围问题</h3><p><img src="https://cdn.jsdelivr.net/gh/dutsc/cloud-image/blog-img/202312052038019.png" alt="https://gitee.com/dutsc/cloud-images/raw/master/images/202212041130517.png"> </p><p>注意这样的条件，若开静态数组，则要开10^6 范围的，因为可能会有99999的测试用例</p><h2 id="4-1"><a href="#4-1" class="headerlink" title="4&#x2F;1"></a>4&#x2F;1</h2><p>若一个数组中的元素全都出现两次，只有一个元素出现一次，那么用异或运算即可求出单独的那一个.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> &amp;x:nums)&#123;<br>    res^=x;<br>&#125;<br><span class="hljs-keyword">return</span> res;<br></code></pre></td></tr></table></figure><p>注意，这里使用&amp;效率提升很大。</p><h2 id="4-3"><a href="#4-3" class="headerlink" title="4&#x2F;3"></a>4&#x2F;3</h2><h3 id="卡特兰数"><a href="#卡特兰数" class="headerlink" title="卡特兰数"></a>卡特兰数</h3><p>$C_0 &#x3D; 1$        $C_{n+1} &#x3D; \frac{2(2n+1)}{n+2} C_n$</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">long</span> <span class="hljs-type">long</span> C = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i&lt;n;++i)&#123;<br>    C = C*<span class="hljs-number">2</span>*(<span class="hljs-number">2</span>*i+<span class="hljs-number">1</span>)/(i+<span class="hljs-number">2</span>);<br>&#125;<br><span class="hljs-keyword">return</span> C;<br></code></pre></td></tr></table></figure><p>例子1：凸n+2边形用其n-1条对角线把此凸n+2边形分割为互不重叠的三角形，有多少种方法？</p><p>例子2：圆周上共有2n个点，这2n个点配对可连成n条弦，且这些弦两两不相交的方式数有多少种？</p><p>例子3：在2n个顺序摆放的盒子中填充n个白球和n个黑球，要求任取前m个盒子，其中黑球数目不少于白球？</p><p>​变形：找钱问题：所有商品都是五角，但又n个人手里拿1块钱，n个人手里拿5角钱，如何给这n个人排序，使得不会出现找不开钱的情况（店家一开始钱为0）</p><p><img src="https://cdn.jsdelivr.net/gh/dutsc/cloud-image/blog-img/202312052038868.png" alt="https://gitee.com/dutsc/cloud-images/raw/master/images/202212041130362.png"></p><p>例子4：给定n个实数x1,x2,…,xn的一个排列，在不改变数字顺序的前提下，只通过添加括号改变运算顺序，共有多少种方法？</p><p><img src="https://cdn.jsdelivr.net/gh/dutsc/cloud-image/blog-img/202312052039704.png" alt="https://gitee.com/dutsc/cloud-images/raw/master/images/202212041131287.png"></p><h2 id="4-5"><a href="#4-5" class="headerlink" title="4&#x2F;5"></a>4&#x2F;5</h2><h3 id="线段树板子2"><a href="#线段树板子2" class="headerlink" title="线段树板子2"></a>线段树板子2</h3><p>给区间内的每个数都乘以K，使用两个懒标记</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//</span><br><span class="hljs-comment">// Created by s&#x27;c on 2022/4/5.</span><br><span class="hljs-comment">//</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;iostream&quot;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MAX = <span class="hljs-number">1000010</span>;<br><span class="hljs-type">int</span> mod;<br>ll nums[MAX];<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span>&#123;<br>    <span class="hljs-type">int</span> l;<br>    <span class="hljs-type">int</span> r;<br>    ll add;<br>    ll mul;<br>    ll sum;<br>&#125;;<br>node tree[MAX&lt;&lt;<span class="hljs-number">2</span>];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pushup</span><span class="hljs-params">(<span class="hljs-type">int</span> node)</span></span>&#123;<br>    tree[node].sum = (tree[node&lt;&lt;<span class="hljs-number">1</span>].sum + tree[node&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>].sum)%mod;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">build</span><span class="hljs-params">(<span class="hljs-type">int</span> node, <span class="hljs-type">int</span> L,<span class="hljs-type">int</span> R)</span></span>&#123;<br>    tree[node].l = L;<br>    tree[node].r = R;<br>    tree[node].mul = <span class="hljs-number">1</span>;<br>    tree[node].add = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span>(L==R)&#123;<br>        tree[node].sum = nums[L]%mod;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-type">int</span> mid = ((R-L)&gt;&gt;<span class="hljs-number">1</span>)+L;<br>    <span class="hljs-built_in">build</span>(node&lt;&lt;<span class="hljs-number">1</span>,L,mid);<br>    <span class="hljs-built_in">build</span>(node&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>,mid+<span class="hljs-number">1</span>,R);<br>    <span class="hljs-built_in">pushup</span>(node);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pushdown</span><span class="hljs-params">(<span class="hljs-type">int</span> node)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(tree[node].mul!=<span class="hljs-number">1</span>)&#123;<br>        tree[node&lt;&lt;<span class="hljs-number">1</span>].mul = (tree[node&lt;&lt;<span class="hljs-number">1</span>].mul * tree[node].mul)%mod;<br>        tree[node&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>].mul = (tree[node&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>].mul * tree[node].mul)%mod;<br>        tree[node&lt;&lt;<span class="hljs-number">1</span>].add = (tree[node&lt;&lt;<span class="hljs-number">1</span>].add * tree[node].mul)%mod;<br>        tree[node&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>].add = (tree[node&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>].add * tree[node].mul)%mod;<br>        tree[node&lt;&lt;<span class="hljs-number">1</span>].sum = (tree[node&lt;&lt;<span class="hljs-number">1</span>].sum * tree[node].mul)%mod;<br>        tree[node&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>].sum = (tree[node&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>].sum * tree[node].mul)%mod;<br>        tree[node].mul = <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(tree[node].add)&#123;<br>        tree[node&lt;&lt;<span class="hljs-number">1</span>].add = (tree[node&lt;&lt;<span class="hljs-number">1</span>].add + tree[node].add)%mod;<br>        tree[node&lt;&lt;<span class="hljs-number">1</span>].sum = (tree[node&lt;&lt;<span class="hljs-number">1</span>].sum + tree[node].add*(tree[node&lt;&lt;<span class="hljs-number">1</span>].r-tree[node&lt;&lt;<span class="hljs-number">1</span>].l+<span class="hljs-number">1</span>)%mod)%mod;<br>        tree[node&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>].add = (tree[node&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>].add + tree[node].add)%mod;<br>        tree[node&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>].sum = (tree[node&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>].sum + tree[node].add*(tree[node&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>].r-tree[node&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>].l+<span class="hljs-number">1</span>)%mod)%mod;<br>        tree[node].add = <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">update</span><span class="hljs-params">(<span class="hljs-type">int</span> node,<span class="hljs-type">int</span> L,<span class="hljs-type">int</span> R,ll v1,ll v2)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(L&lt;=tree[node].l &amp;&amp; R&gt;=tree[node].r)&#123;<br>        <span class="hljs-comment">// v1产生的影响</span><br>        tree[node].mul = (tree[node].mul * v1)%mod;<br>        tree[node].add = (tree[node].add * v1)%mod;<br>        tree[node].sum = (tree[node].sum * v1)%mod;<br><br>        <span class="hljs-comment">//v2产生的影响</span><br>        tree[node].add = (tree[node].add + v2)%mod;<br>        tree[node].sum = (tree[node].sum + v2*(tree[node].r-tree[node].l+<span class="hljs-number">1</span>)%mod)%mod;<br>        <span class="hljs-keyword">return</span> ;<br>    &#125;<br>    <span class="hljs-type">int</span> mid = ((tree[node].r-tree[node].l)&gt;&gt;<span class="hljs-number">1</span>)+tree[node].l;<br>    <span class="hljs-built_in">pushdown</span>(node);<br>    <span class="hljs-keyword">if</span>(L&lt;=mid) <span class="hljs-built_in">update</span>(node&lt;&lt;<span class="hljs-number">1</span>,L,R,v1,v2);<br>    <span class="hljs-keyword">if</span>(R&gt;mid) <span class="hljs-built_in">update</span>(node&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>,L,R,v1,v2);<br>    <span class="hljs-built_in">pushup</span>(node);<br>&#125;<br><br><span class="hljs-function">ll <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> node,<span class="hljs-type">int</span> L,<span class="hljs-type">int</span> R)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(R&lt;tree[node].l || L&gt;tree[node].r) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span>(L&lt;=tree[node].l &amp;&amp; R&gt;=tree[node].r) <span class="hljs-keyword">return</span> tree[node].sum;<br>    <span class="hljs-type">int</span> mid = ((tree[node].r-tree[node].l)&gt;&gt;<span class="hljs-number">1</span>)+tree[node].l;<br>    <span class="hljs-built_in">pushdown</span>(node);<br>    ll res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span>(L&lt;=mid) res = (res + <span class="hljs-built_in">query</span>(node&lt;&lt;<span class="hljs-number">1</span>,L,R))%mod;<br>    <span class="hljs-keyword">if</span>(R&gt;mid) res = (res + <span class="hljs-built_in">query</span>(node&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>,L,R))%mod;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> n,m,p;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>,&amp;n,&amp;m,&amp;p);<br>    mod = p;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i&lt;n;++i)&#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%ld&quot;</span>,&amp;nums[i]);<br>    &#125;<br>    <span class="hljs-built_in">build</span>(<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,n<span class="hljs-number">-1</span>);<br>    <span class="hljs-keyword">while</span>(m--&gt;<span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-type">int</span> tt;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;tt);<br>        <span class="hljs-keyword">if</span>(tt==<span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-comment">// mul</span><br>            <span class="hljs-type">int</span> x,y;<br>            ll k;<br>            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%ld&quot;</span>,&amp;x,&amp;y,&amp;k);<br>            <span class="hljs-built_in">update</span>(<span class="hljs-number">1</span>,x<span class="hljs-number">-1</span>,y<span class="hljs-number">-1</span>,k,<span class="hljs-number">0</span>);<span class="hljs-comment">// 先乘后加</span><br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(tt==<span class="hljs-number">2</span>)&#123;<br>            <span class="hljs-comment">// add</span><br>            <span class="hljs-type">int</span> x,y;<br>            ll k;<br>            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%ld&quot;</span>,&amp;x,&amp;y,&amp;k);<br>            <span class="hljs-built_in">update</span>(<span class="hljs-number">1</span>,x<span class="hljs-number">-1</span>,y<span class="hljs-number">-1</span>,<span class="hljs-number">1</span>,k);<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(tt==<span class="hljs-number">3</span>)&#123;<br>            <span class="hljs-comment">// sum</span><br>            <span class="hljs-type">int</span> x,y;<br>            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;x,&amp;y);<br>            <span class="hljs-type">long</span> t = <span class="hljs-built_in">query</span>(<span class="hljs-number">1</span>,x<span class="hljs-number">-1</span>,y<span class="hljs-number">-1</span>);<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%ld\n&quot;</span>,t);<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="注意-2"><a href="#注意-2" class="headerlink" title="注意"></a>注意</h3><p>这个代码第一次写有两个地方出现错误</p><ol><li>tree[node].mul 要在build时进行初始化，不然编译器会自动初始化为0.这不是我们想要的。<strong>要手动初始化为1</strong>.</li><li>每一个步骤都要检查  node &lt;&lt; 1    还是  node &lt;&lt; 1|1，还是  node   想好了再去写，写完要检查一遍。</li><li>在build中对结构体数组中的变量进行初始化是一个好习惯。包括java中对对象数组的初始化，一定要进行。</li></ol><h3 id="埃氏筛法求质数"><a href="#埃氏筛法求质数" class="headerlink" title="埃氏筛法求质数"></a>埃氏筛法求质数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">countPrimes</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span>[] isSu = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        Arrays.fill(isSu,<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;i&lt;n;++i)&#123;<br>            <span class="hljs-keyword">if</span>(isSu[i]==<span class="hljs-number">1</span>)&#123;<br>                res++;<br>                <span class="hljs-keyword">if</span>((<span class="hljs-type">long</span>)i*i&lt;n)&#123;<br>                    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i*i;j&lt;n;j+=i)&#123;<br>                        isSu[j] = <span class="hljs-number">0</span>;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4-6"><a href="#4-6" class="headerlink" title="4&#x2F;6"></a>4&#x2F;6</h2><h3 id="两次扫描与换根法"><a href="#两次扫描与换根法" class="headerlink" title="两次扫描与换根法"></a>两次扫描与换根法</h3><blockquote><p>树形dp的应用</p></blockquote><p>对于某种需要以每个节点为根进行一次DFS的题目，可以使用两次DFS扫描与换根法解决，实际上是利用递推式来一次求解的。</p><h3 id="parseInt与valueOf的区别"><a href="#parseInt与valueOf的区别" class="headerlink" title="parseInt与valueOf的区别"></a>parseInt与valueOf的区别</h3><ol><li><p>返回值不同<br>parseInt 返回值是int型<br>valueof  返回值是Integer型</p></li><li><p>valueof就是调用了parseInt方法的</p></li><li><p>parseInt效率比valueof效率高</p></li></ol><h3 id="ACM模式的Java输入"><a href="#ACM模式的Java输入" class="headerlink" title="ACM模式的Java输入"></a>ACM模式的Java输入</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">import</span> java.io.*;<br><span class="hljs-keyword">import</span> java.util.*;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Main&#123;<br>    <span class="hljs-keyword">public</span> statci <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException&#123;<br>        <span class="hljs-type">BufferedReader</span> <span class="hljs-variable">br</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InputStreamReader</span>(System.in));<br>        String[] tt = br.readLine().split(<span class="hljs-string">&quot; +&quot;</span>);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> tt.length;<br>        <span class="hljs-type">int</span>[] ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i&lt;n;++i)&#123;<br>            ans[i] = Integer.parseInt(tt[i]);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="java输入二维数组，"><a href="#java输入二维数组，" class="headerlink" title="java输入二维数组，"></a>java输入二维数组，</h4><p>记得抛出IOException异常</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// java输入二维数组</span><br><span class="hljs-type">BufferedReader</span> <span class="hljs-variable">br</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InputStreamReader</span>(System.in));<br><span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> Integer.parseInt(br.readLine());<br><span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i&lt;m;++i) &#123;<br>String[] tt = br.readLine().split(<span class="hljs-string">&quot; +&quot;</span>);<br>n = tt.length;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;j&lt;n;++j) &#123;<br>ans[i][j] = Integer.parseInt(tt[j]);<br>&#125;<br>&#125;<br>br.close();<br></code></pre></td></tr></table></figure><h3 id="java之ACM注意点"><a href="#java之ACM注意点" class="headerlink" title="java之ACM注意点"></a>java之ACM注意点</h3><h2 id="Java输入输出基本操作"><a href="#Java输入输出基本操作" class="headerlink" title="Java输入输出基本操作"></a>Java输入输出基本操作</h2><h3 id="Java之ACM注意点"><a href="#Java之ACM注意点" class="headerlink" title="Java之ACM注意点"></a>Java之ACM注意点</h3><p>\1. 类名称必须采用public class Main方式命名</p><p>\2. 在有多行数据输入的情况下，一般这样处理：</p><p>static Scanner in &#x3D; new Scanner(System.in);</p><p>while(in.hasNextInt())</p><p>或者是</p><p>while(in.hasNext())</p><p>\3. 有关System.nanoTime()函数的使用，该函数用来返回最准确的可用系统计时器的当前值，以毫微秒为单位。</p><p>  long startTime &#x3D; System.nanoTime();</p><p>  &#x2F;&#x2F; … the code being measured …</p><p>  long estimatedTime &#x3D; System.nanoTime() - startTime;</p><h3 id="Java之输入输出处理"><a href="#Java之输入输出处理" class="headerlink" title="Java之输入输出处理"></a>Java之输入输出处理</h3><h5 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h5><p>格式1：Scanner sc &#x3D; new Scanner (new BufferedInputStream(System.in));</p><p>格式2：Scanner sc &#x3D; new Scanner (System.in);</p><p>在读入数据量大的情况下，格式1的速度会快些。</p><p>读一个整数： int n &#x3D; sc.nextInt(); 相当于 scanf(“%d”, &amp;n); 或 cin &gt;&gt; n; </p><p>读一个字符串：String s &#x3D; sc.next(); 相当于 scanf(“%s”, s); 或 cin &gt;&gt; s; </p><p>读一个浮点数：double t &#x3D; sc.nextDouble(); 相当于 scanf(“%lf”, &amp;t); 或 cin &gt;&gt; t; </p><p>读一整行： String s &#x3D; sc.nextLine(); 相当于 gets(s); 或 cin.getline(…); </p><p>判断是否有下一个输入可以用sc.hasNext()或sc.hasNextInt()或sc.hasNextDouble()或sc.hasNextLine()</p><p>例1：读入整数</p><p>Input 输入数据有多组，每组占一行，由一个整数组成。</p><p>Sample Input</p><p>56</p><p>67</p><p>100</p><p>123</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Scanner;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">Scanner</span> <span class="hljs-variable">sc</span> <span class="hljs-operator">=</span><span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>    <span class="hljs-keyword">while</span>(sc.hasNext())&#123; <span class="hljs-comment">//判断是否结束</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">score</span> <span class="hljs-operator">=</span> sc.nextInt();<span class="hljs-comment">//读入整数</span><br>    …………<br>   &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>例2：读入实数</p><p>输入数据有多组，每组占2行，第一行为一个整数N，指示第二行包含N个实数。</p><p>Sample Input</p><p>4</p><p>56.9 67.7 90.5 12.8</p><p>5</p><p>56.9 67.7 90.5 12.8</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Scanner;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">Scanner</span> <span class="hljs-variable">sc</span> <span class="hljs-operator">=</span><span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>    <span class="hljs-keyword">while</span>(sc.hasNext())&#123;<br>      <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> sc.nextInt();<br>      <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        <span class="hljs-type">double</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> sc.nextDouble();<br>        ……………<br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>例3：读入字符串【杭电2017 字符串统计】</p><p>输入数据有多行，第一行是一个整数n，表示测试实例的个数，后面跟着n行，每行包括一个由字母和数字组成的字符串。</p><p>Sample Input</p><p>2</p><p>asdfasdf123123asdfasdf</p><p>asdf111111111asdfasdfasdf</p><p>import java.util.Scanner;</p><p>public class Main {</p><p>public static void main(String[] args) {</p><p>​    Scanner sc &#x3D; new Scanner(System.in);</p><p>​    int n &#x3D; sc.nextInt();</p><p>​    for(int i&#x3D;0;i&lt;n;i++){</p><p>​      String str &#x3D; sc.next();</p><p>​      ……</p><p>​    }</p><p>  }</p><p>}</p><p>import java.util.Scanner;</p><p>public class Main {</p><p>public static void main(String[] args) {</p><p>​    Scanner sc &#x3D; new Scanner(System.in);</p><p>​    int n &#x3D; Integer.parseInt(sc.nextLine());</p><p>​    for(int i&#x3D;0;i&lt;n;i++){</p><p>​      String str &#x3D; sc.nextLine();</p><p>​      ……</p><p>​    }</p><p>  }</p><p>}</p><h5 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h5><p>函数：</p><p>System.out.print(); </p><p>System.out.println(); </p><p>System.out.format();</p><p>System.out.printf(); </p><p>例4 杭电1170Balloon Comes!</p><p>Give you an operator (+,-,*, &#x2F; –denoting addition, subtraction, multiplication, division respectively) and two positive integers, your task is to output the result. </p><p>Input</p><p>Input contains multiple test cases. The first line of the input is a single integer T (0&lt;T&lt;1000) which is the number of test cases. T test cases follow. Each test case contains a char C (+,-,*, &#x2F;) and two integers A and B(0&lt;A,B&lt;10000).Of course, we all know that A and B are operands and C is an operator. </p><p>Output</p><p>For each case, print the operation result. The result should be rounded to 2 decimal places If and only if it is not an integer.</p><p>Sample Input</p><p>4</p><p>+ 1 2</p><p>- 1 2</p><p>* 1 2</p><p>&#x2F; 1 2</p><p>Sample Output</p><p>3</p><p>-1</p><p>2</p><p>0.50</p><p>import java.util.Scanner;</p><p>public class Main {</p><p>public static void main(String[] args) {</p><p>​    Scanner sc &#x3D;new Scanner(System.in);</p><p>​    int n &#x3D; sc.nextInt();</p><p>​    for(int i&#x3D;0;i&lt;n;i++){</p><p>​      String op &#x3D; sc.next();</p><p>​      int a &#x3D; sc.nextInt();</p><p>​      int b &#x3D; sc.nextInt();</p><p>​      if(op.charAt(0)&#x3D;&#x3D;’+’){</p><p>​        System.out.println(a+b);</p><p>​      }else if(op.charAt(0)&#x3D;&#x3D;’-‘){</p><p>​        System.out.println(a-b);</p><p>​      }else if(op.charAt(0)&#x3D;&#x3D;’*’){</p><p>​        System.out.println(a*b);</p><p>​      }else if(op.charAt(0)&#x3D;&#x3D;’&#x2F;‘){</p><p>​      if(a % b &#x3D;&#x3D; 0) System.out.println(a &#x2F; b);</p><p>​      else System.out.format(“%.2f”, (a &#x2F; (1.0*b))). Println();</p><p>​      }</p><p>​    }</p><p>   }</p><p>}</p><h5 id="格式化的输出"><a href="#格式化的输出" class="headerlink" title="格式化的输出"></a>格式化的输出</h5><p>函数：</p><p>&#x2F;&#x2F; 这里0指一位数字，#指除0以外的数字(如果是0，则不显示),四舍五入.</p><p>  DecimalFormat fd &#x3D; new DecimalFormat(“#.00#”);</p><p>  DecimalFormat gd &#x3D; new DecimalFormat(“0.000”);</p><p>  System.out.println(“x &#x3D;” + fd.format(x));</p><p>  System.out.println(“x &#x3D;” + gd.format(x));</p><p>public static void main(String[] args) {</p><p>NumberFormat formatter &#x3D; new DecimalFormat( “000000”);</p><p>String s &#x3D; formatter.format(-1234.567); &#x2F;&#x2F; -001235</p><p>System.out.println(s);</p><p>formatter &#x3D; new DecimalFormat( “##”);</p><p>s &#x3D; formatter.format(-1234.567); &#x2F;&#x2F; -1235</p><p>System.out.println(s);</p><p>s &#x3D; formatter.format(0); &#x2F;&#x2F; 0</p><p>System.out.println(s);</p><p>formatter &#x3D; new DecimalFormat( “##00”);</p><p>s &#x3D; formatter.format(0); &#x2F;&#x2F; 00</p><p>System.out.println(s);</p><p>formatter &#x3D; new DecimalFormat( “.00”);</p><p>s &#x3D; formatter.format(-.567); &#x2F;&#x2F; -.57</p><p>System.out.println(s);</p><p>formatter &#x3D; new DecimalFormat( “0.00”);</p><p>s &#x3D; formatter.format(-.567); &#x2F;&#x2F; -0.57</p><p>System.out.println(s);</p><p>formatter &#x3D; new DecimalFormat( “#.#”);</p><p>s &#x3D; formatter.format(-1234.567); &#x2F;&#x2F; -1234.6</p><p>System.out.println(s);</p><p>formatter &#x3D; new DecimalFormat( “#.######”);</p><p>s &#x3D; formatter.format(-1234.567); &#x2F;&#x2F; -1234.567</p><p>System.out.println(s);</p><p>formatter &#x3D; new DecimalFormat( “.######”);</p><p>s &#x3D; formatter.format(-1234.567); &#x2F;&#x2F; -1234.567</p><p>System.out.println(s);</p><p>formatter &#x3D; new DecimalFormat( “#.000000”);</p><p>s &#x3D; formatter.format(-1234.567); &#x2F;&#x2F; -1234.567000</p><p>System.out.println(s);</p><p>formatter &#x3D; new DecimalFormat( “#,###,###”);</p><p>s &#x3D; formatter.format(-1234.567); &#x2F;&#x2F; -1,235</p><p>System.out.println(s);</p><p>s &#x3D; formatter.format(-1234567.890); &#x2F;&#x2F; -1,234,568</p><p>System.out.println(s);</p><p>&#x2F;&#x2F; The ; symbol is used to specify an alternate pattern for negative values</p><p>formatter &#x3D; new DecimalFormat( “#;(#) “);</p><p>s &#x3D; formatter.format(-1234.567); &#x2F;&#x2F; (1235)</p><p>System.out.println(s);</p><p>&#x2F;&#x2F; The ‘ symbol is used to quote literal symbols</p><p>formatter &#x3D; new DecimalFormat( “ ‘# ‘# “);</p><p>s &#x3D; formatter.format(-1234.567); &#x2F;&#x2F; -#1235</p><p>System.out.println(s);</p><p>formatter &#x3D; new DecimalFormat( “ ‘abc ‘# “);</p><p>s &#x3D; formatter.format(-1234.567); &#x2F;&#x2F; - abc 1235</p><p>System.out.println(s);</p><p>formatter &#x3D; new DecimalFormat( “#.##%”);</p><p>s &#x3D; formatter.format(-12.5678987);</p><p>System.out.println(s);</p><p>}</p><h5 id="字符串处理String"><a href="#字符串处理String" class="headerlink" title="字符串处理String"></a>字符串处理String</h5><p>String 类用来存储字符串，可以用charAt方法来取出其中某一字节，计数从0开始： </p><p>String a &#x3D; “Hello”; &#x2F;&#x2F; a.charAt(1) &#x3D; ‘e’ </p><p>用substring方法可得到子串，如上例 </p><p>System.out.println(a.substring(0, 4)) &#x2F;&#x2F; output “Hell” </p><p>注意第2个参数位置上的字符不包括进来。这样做使得 s.substring(a, b) 总是有 b-a个字符。 </p><p>字符串连接可以直接用 + 号，如 </p><p>String a &#x3D; “Hello”; </p><p>String b &#x3D; “world”; </p><p>System.out.println(a + “, “ + b + “!”); &#x2F;&#x2F; output “Hello, world!” </p><p>如想直接将字符串中的某字节改变，可以使用另外的StringBuffer类。 </p><h5 id="高精度"><a href="#高精度" class="headerlink" title="高精度"></a>高精度</h5><p>BigInteger和BigDecimal可以说是acmer选择java的首要原因。</p><p>函数：add, subtract, divide, mod, compareTo等，其中加减乘除模都要求是BigInteger(BigDecimal)和BigInteger(BigDecimal)之间的运算，所以需要把int(double)类型转换为BigInteger(BigDecimal)，用函数BigInteger.valueOf().</p><p>import java.io.BufferedInputStream;</p><p>import java.math.BigInteger;</p><p>import java.util.Scanner;</p><p>public class Main {</p><p>public static void main(String[] args) {</p><p>Scanner cin &#x3D; new Scanner (new BufferedInputStream(System.in));</p><p>int a &#x3D; 123, b &#x3D; 456, c &#x3D; 7890;</p><p>BigInteger x, y, z, ans;</p><p>x &#x3D; BigInteger.valueOf(a);</p><p>y &#x3D; BigInteger.valueOf(b);</p><p>z &#x3D; BigInteger.valueOf(c);</p><p>ans &#x3D; x.add(y); System.out.println(ans);</p><p>ans &#x3D; z.divide(y); System.out.println(ans);</p><p>ans &#x3D; x.mod(z); System.out.println(ans);</p><p>if (ans.compareTo(x) &#x3D;&#x3D; 0) System.out.println(“1”);</p><p>}</p><p>}</p><h5 id="进制转化"><a href="#进制转化" class="headerlink" title="进制转化"></a>进制转化</h5><p>String st &#x3D; Integer.toString(num, base); &#x2F;&#x2F; 把num当做10进制的数转成base进制的st(base &lt;&#x3D; 35).</p><p>int num &#x3D; Integer.parseInt(st, base); &#x2F;&#x2F; 把st当做base进制，转成10进制的int(parseInt有两个参数,第一个为要转的字符串,第二个为说明是什么进制). </p><p>BigInter m &#x3D; new BigInteger(st, base); &#x2F;&#x2F; st是字符串，base是st的进制.</p><h3 id="进制转换"><a href="#进制转换" class="headerlink" title="进制转换"></a>进制转换</h3><p>使用Integer.toString(ta,base)函数将int类型的ta转换成base进制的String</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">BufferedReader</span> <span class="hljs-variable">br</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InputStreamReader</span>(System.in));<br><span class="hljs-type">String</span> <span class="hljs-variable">tt</span> <span class="hljs-operator">=</span> br.readLine();<br><span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> Integer.parseInt(tt);<br><span class="hljs-type">String</span> <span class="hljs-variable">ta</span> <span class="hljs-operator">=</span> Integer.toString(a,<span class="hljs-number">2</span>);<br>System.out.println(ta);<br></code></pre></td></tr></table></figure><p>使用Integer.parseInt(ta,base) 将String类型，base进制的ta转换成10进制的int</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">BufferedReader</span> <span class="hljs-variable">br</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InputStreamReader</span>(System.in));<br><span class="hljs-type">String</span> <span class="hljs-variable">tt</span> <span class="hljs-operator">=</span> br.readLine();<br><span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> Integer.parseInt(tt,<span class="hljs-number">2</span>);<br>System.out.println(a);<br></code></pre></td></tr></table></figure><h2 id="4-7"><a href="#4-7" class="headerlink" title="4&#x2F;7"></a>4&#x2F;7</h2><h3 id="求一个数的所有不重复的因子"><a href="#求一个数的所有不重复的因子" class="headerlink" title="求一个数的所有不重复的因子"></a>求一个数的所有不重复的因子</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Scanner</span> <span class="hljs-variable">sc</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br><span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> sc.nextInt();<br>List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>Set&lt;Integer&gt; set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedHashSet</span>&lt;&gt;();<br><span class="hljs-type">double</span> <span class="hljs-variable">sq</span> <span class="hljs-operator">=</span> Math.sqrt(n);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;i&lt;=sq;++i)&#123;<br>    <span class="hljs-keyword">if</span>(n%i==<span class="hljs-number">0</span>)&#123;<br>        set.add(i);<br>        set.add(n/i);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">for</span>(Integer i:set)&#123;<br>    System.out.print(i+<span class="hljs-string">&quot; &quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4-8"><a href="#4-8" class="headerlink" title="4&#x2F;8"></a>4&#x2F;8</h2><h3 id="多数去重的思路"><a href="#多数去重的思路" class="headerlink" title="多数去重的思路"></a>多数去重的思路</h3><p>多个数字组成的整体（如int[2]，最简分数去重等等），常规的去重思路</p><p>找一个基数，这个基数比最大的数据范围还要大，使用如下形式将其放入数组中存储（若数据量大就放入哈希表存储）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-comment">// 假设a，b数据的最大范围是[0-25]</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">getIndex</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">30</span>*a+b;<br>&#125;<br><span class="hljs-type">int</span>[] ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">30</span>*<span class="hljs-number">30</span>+<span class="hljs-number">30</span>];<br></code></pre></td></tr></table></figure><p>这样，只要a不变，任凭b怎么变化，getIndex得到的值都会不一样，就达到了去重的目的。</p><p>同理，若是有abc三个数，则去重的基数就要再加一个</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-type">int</span> <span class="hljs-title function_">getIndex</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b,<span class="hljs-type">int</span> c)</span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">30</span> * <span class="hljs-number">30</span> * a + <span class="hljs-number">30</span> * b + c;<br>&#125;<br><span class="hljs-type">int</span>[] ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">30</span>*<span class="hljs-number">30</span>*<span class="hljs-number">30</span>+<span class="hljs-number">30</span>*<span class="hljs-number">30</span>+<span class="hljs-number">30</span>];<br></code></pre></td></tr></table></figure><h2 id="4-11"><a href="#4-11" class="headerlink" title="4&#x2F;11"></a>4&#x2F;11</h2><h3 id="查找相邻元素"><a href="#查找相邻元素" class="headerlink" title="查找相邻元素"></a>查找相邻元素</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">adjacent_find</span>(iterator beg, iterator end);<br><span class="hljs-comment">// 查找相邻重复元素,返回相邻元素的第一个位置的迭代器</span><br>    vector&lt;<span class="hljs-type">int</span>&gt; a;<br>    a.<span class="hljs-built_in">emplace_back</span>(<span class="hljs-number">1</span>);<br>    a.<span class="hljs-built_in">emplace_back</span>(<span class="hljs-number">5</span>);<br>    a.<span class="hljs-built_in">emplace_back</span>(<span class="hljs-number">6</span>);<br>    a.<span class="hljs-built_in">emplace_back</span>(<span class="hljs-number">2</span>);<br>    a.<span class="hljs-built_in">emplace_back</span>(<span class="hljs-number">9</span>);<br>    a.<span class="hljs-built_in">emplace_back</span>(<span class="hljs-number">3</span>);<br>    vector&lt;<span class="hljs-type">int</span>&gt;::iterator it = <span class="hljs-built_in">adjacent_find</span>(a.<span class="hljs-built_in">begin</span>(),a.<span class="hljs-built_in">end</span>());<br>    <span class="hljs-keyword">if</span>(it!=a.<span class="hljs-built_in">end</span>())&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;找到了&quot;</span> &lt;&lt; endl;<br>    &#125;<span class="hljs-keyword">else</span> &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;没找到&quot;</span> &lt;&lt; endl;<br>    &#125;<br>    cout &lt;&lt; *it &lt;&lt; endl;<br></code></pre></td></tr></table></figure><h2 id="4-12"><a href="#4-12" class="headerlink" title="4&#x2F;12"></a>4&#x2F;12</h2><h3 id="寻找第k个缺失的数"><a href="#寻找第k个缺失的数" class="headerlink" title="寻找第k个缺失的数"></a>寻找第k个缺失的数</h3><p>找到一个严格升序排列的正整数组中第k个缺失的正整数。</p><p>我们发现截至到每一个位置，缺失的正整数的数量  是非递减的，于是可以考虑使用二分法，但要注意边界情况的处理。</p><h3 id="二分法找某一个值"><a href="#二分法找某一个值" class="headerlink" title="二分法找某一个值"></a>二分法找某一个值</h3><p>使用二分法找某一个符合条件的值时，要先求，然后再验证是否符合条件。因为求的是yyynnn   或者 nnnyyy类型的，可能边界值不符合题目条件。</p><h3 id="c-字符串越界"><a href="#c-字符串越界" class="headerlink" title="c++字符串越界"></a>c++字符串越界</h3><p>越界之后不会报错，而是取到一个’&#x2F;0’字符</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++">    string s = <span class="hljs-string">&quot;123&quot;</span>;<br>    cout &lt;&lt; (<span class="hljs-type">int</span>)s[<span class="hljs-number">6</span>] &lt;&lt; endl;<br>    <span class="hljs-type">int</span> a = <span class="hljs-string">&#x27; &#x27;</span>;<br>    cout &lt;&lt;  a &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><span class="hljs-comment">//0  </span><br><span class="hljs-comment">// 32</span><br></code></pre></td></tr></table></figure><h3 id="拆分正整数为几个数的和，使其乘积最大"><a href="#拆分正整数为几个数的和，使其乘积最大" class="headerlink" title="拆分正整数为几个数的和，使其乘积最大"></a>拆分正整数为几个数的和，使其乘积最大</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">if</span>(n&lt;=<span class="hljs-number">3</span>) <span class="hljs-keyword">return</span> n<span class="hljs-number">-1</span>;<br><span class="hljs-type">int</span> x = n/<span class="hljs-number">3</span>,y = n%<span class="hljs-number">3</span>;<br><span class="hljs-keyword">if</span>(y==<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-built_in">pow</span>(<span class="hljs-number">3</span>,x);<br><span class="hljs-keyword">if</span>(y==<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-built_in">pow</span>(<span class="hljs-number">3</span>,x<span class="hljs-number">-1</span>)*<span class="hljs-number">4</span>;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">pow</span>(<span class="hljs-number">3</span>,x)*<span class="hljs-number">2</span>;<br></code></pre></td></tr></table></figure><h2 id="4-13"><a href="#4-13" class="headerlink" title="4&#x2F;13"></a>4&#x2F;13</h2><h3 id="线段树暴力求解"><a href="#线段树暴力求解" class="headerlink" title="线段树暴力求解"></a>线段树暴力求解</h3><p>线段树中的暴力问题，如对$a_i$ 连续取模，可以在$loga_i$复杂度之内实现，故可以暴力求解</p><p>$x % p &lt; \frac{x}{2}$   $p&lt;x$  </p><p>第一次写，问题：</p><ol><li>build中当l&#x3D;&#x3D;r 时没有写return ;</li><li>区间暴力取模，要到了单点的时候再取模，即tr[node].r&#x3D;&#x3D;tr[node].l时</li><li>所有update  modify的最后一步一定是pushup，而不是return。一定要向上回溯</li><li>update单点更新到叶子节点时，不论该节点的lr是不是k，都要return了，注意要把return写在k if的外面。</li></ol><h2 id="4-14"><a href="#4-14" class="headerlink" title="4&#x2F;14"></a>4&#x2F;14</h2><p><a href="https://so.csdn.net/so/search?q=%E6%AC%A7%E6%8B%89%E5%87%BD%E6%95%B0&spm=1001.2101.3001.7020">欧拉函数</a>就是指:<strong>给定一个n，求得1到n中与n互质的数的个数</strong></p><p>1.如果n,m互质，那么 : φ(n*m) &#x3D; φ(n)*φ(m)</p><p>2.如果n为质数，那么 : φ(n) &#x3D; n-1，可推出1中φ(n * m) &#x3D; (n-1)*(m-1)</p><p>3.如果n % m &#x3D;&#x3D; 0，那么 : φ(n * m) &#x3D; m * φ(n)</p><p>4.在3的基础上 : if(n % m &#x3D;&#x3D; 0 &amp;&amp; φ(n &#x2F; m)%m &#x3D;&#x3D; 0) φ(n) &#x3D; φ(n&#x2F;m)*m</p><p>5.在3的基础上 : if(n % m &#x3D;&#x3D; 0 &amp;&amp; φ(n &#x2F; m)%m !&#x3D; 0) φ(n) &#x3D; φ(n&#x2F;m)*(m-1)</p><p>6.当n为奇数时，φ(n) &#x3D; φ(2*n)</p><p>7.与小于等于n中，与n互质的数之和为:φ(n)*n&#x2F;2</p><h3 id="dfs"><a href="#dfs" class="headerlink" title="dfs"></a>dfs</h3><h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><p>给定一个序列，一个数k，问是否能从序列中找到若干个数，使得其和为k，序列中的数只能使用一次</p><p><a href="https://www.papamelon.com/problem/201">https://www.papamelon.com/problem/201</a></p><h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><p>本题是一个子集树问题（选或不选2^n），与之类似的还有排列树问题（每次少一个，n!），n叉树问题（n^n），代码结构如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">dfs</span>(<span class="hljs-type">int</span> i)&#123;<br>  <span class="hljs-comment">//1 输出结果</span><br>  <span class="hljs-keyword">if</span>(i==n) <span class="hljs-built_in">printf</span>();<br>  <br>  <span class="hljs-comment">//2 剪枝</span><br>  <br>  <span class="hljs-comment">//3 遍历下一层</span><br>  <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;j&lt;k;++j)&#123; <span class="hljs-comment">// 子集树</span><br>  <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = i;j&lt;=n;++j&#123; <span class="hljs-comment">// 排列树</span><br>  <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;j&lt;n;++j&#123;  <span class="hljs-comment">// n叉树</span><br>    <span class="hljs-built_in">dfs</span>(i+<span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>第一份超时代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 超时</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;iostream&quot;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span>  <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br>ll arr[<span class="hljs-number">21</span>]=&#123;<span class="hljs-number">0</span>&#125;;<br><span class="hljs-type">bool</span> used[<span class="hljs-number">21</span>]=&#123;<span class="hljs-number">0</span>&#125;;<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">dfs</span><span class="hljs-params">(ll* arr,<span class="hljs-type">int</span> k,<span class="hljs-type">int</span> now,<span class="hljs-type">int</span> n)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(now==k) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i&lt;=n;++i)&#123;<br>        <span class="hljs-keyword">if</span>(!used[i])&#123;<br>            used[i] = <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">dfs</span>(arr,k,now+arr[i],n)) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            used[i] = <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;n)!=EOF)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i&lt;=n;++i)&#123;<br>            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld&quot;</span>,&amp;arr[i]);<br>        &#125;<br>        ll k;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld&quot;</span>,&amp;k);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i&lt;<span class="hljs-number">21</span>;++i)&#123;<br>            used[i] = <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">dfs</span>(arr,k,<span class="hljs-number">0</span>,n)) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Yes\n&quot;</span>);<br>        <span class="hljs-keyword">else</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;No\n&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>很容易写出本题代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;iostream&quot;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br>ll a[<span class="hljs-number">21</span>]=&#123;<span class="hljs-number">0</span>&#125;;<br><span class="hljs-type">int</span> n;<br>ll k;<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> i,<span class="hljs-type">int</span> sum)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(i==n) <span class="hljs-keyword">return</span> sum==k;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">dfs</span>(i+<span class="hljs-number">1</span>,sum))&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;没取%lld &quot;</span>,a[i]);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">dfs</span>(i+<span class="hljs-number">1</span>,sum+a[i]))&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;取了%lld &quot;</span>,a[i]);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;n)!=EOF)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i&lt;n;++i)&#123;<br>            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld&quot;</span>,&amp;a[i]);<br>        &#125;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld&quot;</span>,&amp;k);<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">dfs</span>(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>)) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Yes\n&quot;</span>);<br>        <span class="hljs-keyword">else</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;No\n&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>这里我也给出输出全排列的代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;iostream&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;vector&quot;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br>vector&lt;<span class="hljs-type">int</span>&gt; b;<br><span class="hljs-type">int</span> id = <span class="hljs-number">0</span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; arr,<span class="hljs-type">int</span> i,<span class="hljs-type">int</span> n,vector&lt;<span class="hljs-type">bool</span>&gt;&amp; used)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(i==n)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;j&lt;n;++j)&#123;<br>            cout &lt;&lt; b[j] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>        &#125;<br>        id++;<br>        cout &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;j&lt;n;++j)&#123;<br>        <span class="hljs-keyword">if</span>(!used[j])&#123;<br>            used[j] = <span class="hljs-literal">true</span>;<br>            b.<span class="hljs-built_in">emplace_back</span>(arr[j]);<br>            <span class="hljs-built_in">dfs</span>(arr,i+<span class="hljs-number">1</span>,n,used);<br>            b.<span class="hljs-built_in">pop_back</span>();<br>            used[j] = <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">arr</span><span class="hljs-params">(<span class="hljs-number">6</span>,<span class="hljs-number">0</span>)</span></span>;<br>    <span class="hljs-type">int</span> n = arr.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i&lt;n;++i)&#123;<br>        arr[i] = i+<span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">used</span><span class="hljs-params">(n,<span class="hljs-number">0</span>)</span></span>;<br>    <span class="hljs-built_in">dfs</span>(arr,<span class="hljs-number">0</span>,n,used);<br>    cout &lt;&lt; <span class="hljs-string">&quot;id=&quot;</span> &lt;&lt; id &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="贪心"><a href="#贪心" class="headerlink" title="贪心"></a>贪心</h3><p>n项工作，每项工作si开始，ti结束，每次只能同时参与一项工作，问最多参与多少个工作？</p><h4 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h4><p>在可选的工作中，每次都选取结束时间最早的工作，可以实现参与最多的工作。、</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//</span><br><span class="hljs-comment">// Created by s&#x27;c on 2022/4/14.</span><br><span class="hljs-comment">//</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;iostream&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;algorithm&quot;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MAX = <span class="hljs-number">100010</span>;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br>ll s[MAX];<br>ll t[MAX];<br><br><span class="hljs-type">int</span> n;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    pair&lt;ll,ll&gt; pp[MAX];<br>    <span class="hljs-keyword">while</span>(<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;n)!=EOF)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i&lt;n;++i)&#123;<br>            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld&quot;</span>,&amp;s[i]);<br>            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld&quot;</span>,&amp;t[i]);<br>            pp[i].first = t[i];<br>            pp[i].second = s[i];<br>        &#125;<br>        <span class="hljs-built_in">sort</span>(pp,pp+n);<br>        <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>        ll last = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i&lt;n;++i)&#123;<br>            <span class="hljs-keyword">if</span>(last&lt;pp[i].second)&#123;<br>                res++;<br>                last = pp[i].first;<br>            &#125;<br>        &#125;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,res);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="priority-queue的pair自定义排序"><a href="#priority-queue的pair自定义排序" class="headerlink" title="priority_queue的pair自定义排序"></a>priority_queue的pair自定义排序</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">cmp</span>&#123;<br>        <span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> U&gt;</span><br><span class="hljs-function">        <span class="hljs-type">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(T <span class="hljs-type">const</span>&amp; left, U <span class="hljs-type">const</span> &amp;right)</span> </span>&#123;<br>            <span class="hljs-keyword">if</span> (left.second &lt; right.second) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;;<br>...<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; mp;<br>    mp[<span class="hljs-number">3</span>]=<span class="hljs-number">4</span>;<br>    mp[<span class="hljs-number">2</span>]=<span class="hljs-number">44</span>;<br>    mp[<span class="hljs-number">12</span>]=<span class="hljs-number">432</span>;<br>    priority_queue&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;, vector&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt;, cmp&gt;  <span class="hljs-built_in">pq</span>(mp.<span class="hljs-built_in">begin</span>(), mp.<span class="hljs-built_in">end</span>());<span class="hljs-comment">//完成pq的初始化</span><br>&#125;<br></code></pre></td></tr></table></figure><p>cmp中，&gt;表示降序</p><h4 id="另外几种常用的"><a href="#另外几种常用的" class="headerlink" title="另外几种常用的"></a>另外几种常用的</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++">priority_queue&lt; <span class="hljs-type">int</span> &gt; q;<span class="hljs-comment">// 默认是 从大到小。 </span><br>priority_queue &lt; <span class="hljs-type">int</span> , vector&lt;<span class="hljs-type">int</span>&gt; ,less&lt;<span class="hljs-type">int</span>&gt; &gt; q;<span class="hljs-comment">//从大到小 </span><br>priority_queue &lt; <span class="hljs-type">int</span> , vector&lt;<span class="hljs-type">int</span>&gt;, greater&lt;<span class="hljs-type">int</span>&gt; &gt; q; <span class="hljs-comment">//从小到大，需要vector</span><br>priority_queue &lt; <span class="hljs-type">int</span> , vector&lt;<span class="hljs-type">int</span>&gt; , cmp1  &gt; q;<span class="hljs-comment">//从大到小，需要vector</span><br>priority_queue &lt; <span class="hljs-type">int</span> , vector&lt;<span class="hljs-type">int</span>&gt; , cmp  &gt; q;<span class="hljs-comment">//从小到大，需要vector</span><br></code></pre></td></tr></table></figure><h3 id="离散化"><a href="#离散化" class="headerlink" title="离散化"></a>离散化</h3><p>1 2 5000 900000 </p><p>变成 0 1 2 3 </p><p>只表示相对大小，而不用来表示数值大小</p><p>函数lower_bound()在first和last中的<strong>前闭后开</strong>区间进行二分查找，返回大于或等于val的<strong>第一个元素</strong>位置。如果所有元素都小于val，则返回<strong>last</strong>的位置</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//</span><br><span class="hljs-comment">// Created by s&#x27;c on 2022/4/13.</span><br><span class="hljs-comment">//</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;iostream&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;cstring&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;algorithm&quot;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> A[<span class="hljs-number">10010</span>]=&#123;<span class="hljs-number">0</span>&#125;;<br><span class="hljs-type">int</span> B[<span class="hljs-number">10010</span>]=&#123;<span class="hljs-number">0</span>&#125;;<br><span class="hljs-type">int</span> f[<span class="hljs-number">2</span>][<span class="hljs-number">10010</span>]=&#123;<span class="hljs-number">0</span>&#125;;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> INF = <span class="hljs-number">0x3f3f3f3f</span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> n = <span class="hljs-number">6</span>;<br>    <span class="hljs-type">int</span> a[]=&#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">900</span>,<span class="hljs-number">50000</span>,<span class="hljs-number">6000000</span>,<span class="hljs-number">90000000</span>&#125;;<br>    <span class="hljs-type">int</span> te[<span class="hljs-number">7</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br>    <span class="hljs-type">int</span> ls[<span class="hljs-number">7</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;a[i]);<br>        te[i]=a[i];<br>    &#125;<br>    <span class="hljs-built_in">sort</span>(te+<span class="hljs-number">1</span>,te+n+<span class="hljs-number">1</span>);<br>    <span class="hljs-type">int</span> size=<span class="hljs-built_in">unique</span>(te+<span class="hljs-number">1</span>,te+n+<span class="hljs-number">1</span>)-te<span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        ls[i]=<span class="hljs-built_in">lower_bound</span>(te+<span class="hljs-number">1</span>,te+size+<span class="hljs-number">1</span>,a[i])-te<span class="hljs-number">-1</span>;<br>        cout &lt;&lt; ls[i] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="包含unique函数的用法"><a href="#包含unique函数的用法" class="headerlink" title="包含unique函数的用法"></a>包含unique函数的用法</h4><p>使用之前必须先排序，unique返回一个迭代器，它指向不重复的最后一个数据的下标。</p><p>一般不常用，只在离散化中用到，但是离散化也可以用哈希表代替。</p><h3 id="c-中的unordered-map"><a href="#c-中的unordered-map" class="headerlink" title="c++中的unordered_map"></a>c++中的unordered_map</h3><p><code>unordered_map</code>的用法和<code>map</code>是一样的，提供了 <code>insert</code>，<code>size</code>，<code>count</code>等操作，并且里面的元素也是以<strong>pair</strong>类型来存贮的。其底层实现是完全不同的，但是就外部使用来说却是一致的。</p><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//</span><br><span class="hljs-comment">// Created by s&#x27;c on 2022/4/15.</span><br><span class="hljs-comment">//</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;iostream&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;map&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;unordered_map&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;string&quot;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    unordered_map&lt;<span class="hljs-type">int</span>, string&gt; myMap=&#123;&#123; <span class="hljs-number">5</span>, <span class="hljs-string">&quot;张大&quot;</span> &#125;,&#123; <span class="hljs-number">6</span>, <span class="hljs-string">&quot;李五&quot;</span> &#125;&#125;;<span class="hljs-comment">//使用&#123;&#125;赋值</span><br>    myMap[<span class="hljs-number">2</span>] = <span class="hljs-string">&quot;李四&quot;</span>;  <span class="hljs-comment">//使用[ ]进行单个插入，若已存在键值2，则赋值修改，若无则插入。</span><br>    myMap.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">pair</span>&lt;<span class="hljs-type">int</span>, string&gt;(<span class="hljs-number">3</span>, <span class="hljs-string">&quot;陈二&quot;</span>));<span class="hljs-comment">//使用insert和pair插入</span><br>    <span class="hljs-comment">//遍历输出+迭代器的使用</span><br>    <span class="hljs-keyword">auto</span> iter = myMap.<span class="hljs-built_in">begin</span>();<span class="hljs-comment">//auto自动识别为迭代器类型unordered_map&lt;int,string&gt;::iterator</span><br>    <span class="hljs-keyword">while</span> (iter!= myMap.<span class="hljs-built_in">end</span>())<br>    &#123;<br>        cout &lt;&lt; iter-&gt;first &lt;&lt; <span class="hljs-string">&quot;,&quot;</span> &lt;&lt; iter-&gt;second &lt;&lt; endl;<br>        ++iter;<br>    &#125;<br><br>    <span class="hljs-comment">//查找元素并输出+迭代器的使用</span><br>    <span class="hljs-keyword">auto</span> iterator = myMap.<span class="hljs-built_in">find</span>(<span class="hljs-number">2</span>);<span class="hljs-comment">//find()返回一个指向2的迭代器</span><br>    <span class="hljs-keyword">if</span> (iterator != myMap.<span class="hljs-built_in">end</span>())<br>        cout &lt;&lt; endl&lt;&lt; iterator-&gt;first &lt;&lt; <span class="hljs-string">&quot;,&quot;</span> &lt;&lt; iterator-&gt;second &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>注意：</p><ol><li><p>myMap[2]&#x3D;”李四”  若没有pair&lt;2,”李四”&gt; ，则直接插入；若key  2已经存在，则修改key  2对应的value为”李四”。</p></li><li><p>myMap.insert(make_pair(2,”王五”))，若myMap中没有pair&lt;int,string&gt;(2,”王五”)，则直接插入；若已经存在，则不再插入，也就是不修改，直接丢弃。</p></li><li><p>pair的构造函数<br>pair&lt;int,string&gt;(1,”李四”)<br>make_pair(1,”李四”)</p></li><li><p>在使用unordered_map统计字符、数字出现频率时，可直接使用++myMap[i]; 若出现频率减为0，则要手动删除这个pair，即  myMap.erase(key)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">if</span>(myMap[i]==<span class="hljs-number">0</span>)&#123;<br>    myMap.<span class="hljs-built_in">erase</span>(i);<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h4 id="遍历unordered-map的方法"><a href="#遍历unordered-map的方法" class="headerlink" title="遍历unordered_map的方法"></a>遍历unordered_map的方法</h4><p><strong>需要使用迭代器</strong></p><p>不是key和value，也不是.first 和.second   而是iter-&gt;first  和 iter-&gt;second</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">auto</span> iter = myMap.<span class="hljs-built_in">begin</span>();<span class="hljs-comment">//auto自动识别为迭代器类型unordered_map&lt;int,string&gt;::iterator</span><br><span class="hljs-keyword">while</span> (iter!= myMap.<span class="hljs-built_in">end</span>())<br>&#123;<br>    cout &lt;&lt; iter-&gt;first &lt;&lt; <span class="hljs-string">&quot;,&quot;</span> &lt;&lt; iter-&gt;second &lt;&lt; endl;<br>    ++iter;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="查找某一个元素并输出"><a href="#查找某一个元素并输出" class="headerlink" title="查找某一个元素并输出"></a>查找某一个元素并输出</h4><p>不要使用这种方式！！！！！！！！！！！</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">cout &lt;&lt; myMap[<span class="hljs-number">2</span>] &lt;&lt; endl;<br></code></pre></td></tr></table></figure><p>因为这样如果unordered_map中不存在key  2的话，就会手动插入一个空的字符串，会改变原来的map的</p><p>而如果是&lt;int,int&gt; 则会插入默认value0</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">unordered_map&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; map;<br>cout &lt;&lt; map[<span class="hljs-number">0</span>] &lt;&lt; endl;<span class="hljs-comment">// 0</span><br></code></pre></td></tr></table></figure><p>推荐使用迭代器</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//查找元素并输出+迭代器的使用</span><br><span class="hljs-keyword">auto</span> iterator = myMap.<span class="hljs-built_in">find</span>(<span class="hljs-number">2</span>);<span class="hljs-comment">//find()返回一个指向2的迭代器</span><br><span class="hljs-keyword">if</span> (iterator != myMap.<span class="hljs-built_in">end</span>())<br>    cout &lt;&lt; endl&lt;&lt; iterator-&gt;first &lt;&lt; <span class="hljs-string">&quot;,&quot;</span> &lt;&lt; iterator-&gt;second &lt;&lt; endl;<br></code></pre></td></tr></table></figure><h5 id=""><a href="#" class="headerlink" title=""></a></h5><h2 id="4-17"><a href="#4-17" class="headerlink" title="4&#x2F;17"></a>4&#x2F;17</h2><h3 id="尾随0的个数"><a href="#尾随0的个数" class="headerlink" title="尾随0的个数"></a>尾随0的个数</h3><p>重要结论：乘积尾随0的数量是所有乘数中因子2数量之和与因子5数量之和中的较小值。</p><p>在做乘法的过程中，尾随0的数量只会增加不会减少，因此我们应该让尽量多的数参与乘积运算。也就是说最优路径一定是从某个边界出发，拐个弯，再走到另一个边界，不会中途不走了或者不拐弯（这样参与运算的数不是尽量多的）。</p><p>因此先用前缀和维护每一行和每一列因子 2 与因子 5 的数量，再枚举拐点计算答案即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxTrailingZeros</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = grid.<span class="hljs-built_in">size</span>(), m = grid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">f2</span>(n + <span class="hljs-number">1</span>), <span class="hljs-built_in">g2</span>(n + <span class="hljs-number">1</span>), <span class="hljs-built_in">f5</span>(n + <span class="hljs-number">1</span>), <span class="hljs-built_in">g5</span>(n + <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= n; i++) f2[i] = g2[i] = f5[i] = g5[i] = <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(m + <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; j++) &#123;<br>            <span class="hljs-type">int</span> x = grid[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>];<br>            <span class="hljs-type">int</span> two = <span class="hljs-number">0</span>, five = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">while</span> (x % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>) two++, x /= <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">while</span> (x % <span class="hljs-number">5</span> == <span class="hljs-number">0</span>) five++, x /= <span class="hljs-number">5</span>;<br>            f2[i][j] = f2[i][j - <span class="hljs-number">1</span>] + two;<br>            g2[i][j] = g2[i - <span class="hljs-number">1</span>][j] + two;<br>            f5[i][j] = f5[i][j - <span class="hljs-number">1</span>] + five;<br>            g5[i][j] = g5[i - <span class="hljs-number">1</span>][j] + five;<br>        &#125;<br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; j++) &#123;<br>            <span class="hljs-comment">// 从左边出发，到上边结束</span><br>            ans = <span class="hljs-built_in">max</span>(ans, <span class="hljs-built_in">min</span>(f2[i][j] + g2[i - <span class="hljs-number">1</span>][j], f5[i][j] + g5[i - <span class="hljs-number">1</span>][j]));<br>            <span class="hljs-comment">// 从左边出发，到下边结束</span><br>            ans = <span class="hljs-built_in">max</span>(ans, <span class="hljs-built_in">min</span>(f2[i][j] + g2[n][j] - g2[i][j], f5[i][j] + g5[n][j] - g5[i][j]));<br>            <span class="hljs-comment">// 从右边出发，到上边结束</span><br>            ans = <span class="hljs-built_in">max</span>(ans, <span class="hljs-built_in">min</span>(f2[i][m] - f2[i][j] + g2[i][j], f5[i][m] - f5[i][j] + g5[i][j]));<br>            <span class="hljs-comment">// 从右边出发，到下边结束</span><br>            ans = <span class="hljs-built_in">max</span>(ans, <span class="hljs-built_in">min</span>(f2[i][m] - f2[i][j] + g2[n][j] - g2[i - <span class="hljs-number">1</span>][j], f5[i][m] - f5[i][j] + g5[n][j] - g5[i - <span class="hljs-number">1</span>][j]));<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="4-19"><a href="#4-19" class="headerlink" title="4&#x2F;19"></a>4&#x2F;19</h2><p>给一个字符串s和一个字符c，返回一个和字符串等长的数组，其中每一个数都表示该数与最近的字符c之间的距离。</p><p>问题可以转换成，对 s 的每个下标 i，求</p><p>s[i] 到其左侧最近的字符 c 的距离<br>s[i] 到其右侧最近的字符 c 的距离<br>这两者的最小值。</p><h2 id="4-24"><a href="#4-24" class="headerlink" title="4&#x2F;24"></a>4&#x2F;24</h2><h3 id="求一个点被几个区间覆盖"><a href="#求一个点被几个区间覆盖" class="headerlink" title="求一个点被几个区间覆盖"></a>求一个点被几个区间覆盖</h3><p>差分+离散化+排序</p><p>转化为区间修改，单点查询的题目，使用差分来解决；由于数据量很大，使用哈希表离散化。</p><p>对per进行排序，相当于一个预处理，这样就可以让时间复杂度从n^2降低到nlogn</p><p>灵佬 灵神代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">fullBloomFlowers</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; f, vector&lt;<span class="hljs-type">int</span>&gt;&amp; per)</span> </span>&#123;<br>        map&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; m;<br>        <span class="hljs-type">int</span> n = per.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">res</span><span class="hljs-params">(n,<span class="hljs-number">0</span>)</span></span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span>&amp; ff:f)&#123;<br>            <span class="hljs-type">int</span> start = ff[<span class="hljs-number">0</span>],end = ff[<span class="hljs-number">1</span>];<br>            m[start]++;<br>            m[end+<span class="hljs-number">1</span>]--;<br>        &#125; <br>        <span class="hljs-comment">// 对person的下标按照person值进行排序</span><br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">id</span><span class="hljs-params">(n)</span></span>;<br>        <span class="hljs-built_in">iota</span>(id.<span class="hljs-built_in">begin</span>(),id.<span class="hljs-built_in">end</span>(),<span class="hljs-number">0</span>);<br>        <span class="hljs-built_in">sort</span>(id.<span class="hljs-built_in">begin</span>(),id.<span class="hljs-built_in">end</span>(),[&amp;](<span class="hljs-type">int</span> i,<span class="hljs-type">int</span> j)&#123;<span class="hljs-keyword">return</span> per[i]&lt;per[j];&#125;);<br>        map&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;::iterator it = m.<span class="hljs-built_in">begin</span>();<br>        <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i:id)&#123;<br>            <span class="hljs-type">int</span> t = per[i];<br>            <span class="hljs-keyword">for</span>(;it!=m.<span class="hljs-built_in">end</span>() &amp;&amp; it-&gt;first&lt;=t;++it)&#123;<br>                sum+=it-&gt;second;<br>            &#125;<br>            res[i] = sum;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>注意骚操作：对person数组按照值进行排序，并返回排好序的person数组的下标，这些下标对应的值已经按照person的值排好序。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">id</span><span class="hljs-params">(n)</span></span>;<br><span class="hljs-built_in">iota</span>(id.<span class="hljs-built_in">begin</span>(), id.<span class="hljs-built_in">end</span>(), <span class="hljs-number">0</span>);<br><span class="hljs-built_in">sort</span>(id.<span class="hljs-built_in">begin</span>(), id.<span class="hljs-built_in">end</span>(), [&amp;](<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j) &#123; <span class="hljs-keyword">return</span> persons[i] &lt; persons[j]; &#125;);<br></code></pre></td></tr></table></figure><h3 id="sort排序的原理"><a href="#sort排序的原理" class="headerlink" title="sort排序的原理"></a>sort排序的原理</h3><p>原理是 cmp返回值为真时，第一个数字放前面</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(<span class="hljs-type">int</span> &amp;a,<span class="hljs-type">int</span> &amp;b)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> a&gt;b;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="lambda表达式"><a href="#lambda表达式" class="headerlink" title="lambda表达式"></a>lambda表达式</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">[ 捕获 ] ( 形参 ) -&gt; ret &#123; 函数体 &#125;;<br></code></pre></td></tr></table></figure><p>lambda表达式一般都是以方括号[]开头，有参数就使用()，无参就直接省略()即可，最后结束于{}，其中的ret表示返回类型。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">auto</span> atLambda = [] &#123;std::cout &lt;&lt; <span class="hljs-string">&quot;hello world&quot;</span> &lt;&lt; std::endl;&#125;;<br>    <span class="hljs-built_in">atLambda</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面定义了一个最简单的lambda表达式，没有参数。如果需要参数，那么就要像函数那样，放在圆括号里面，如果有返回值，返回类型则要放在-&gt;后面，也就是尾随返回类型，当然你也可以忽略返回类型，lambda会帮你自动推导出返回类型，下面看一个较为复杂的例子：</p><h3 id="assign-成员函数"><a href="#assign-成员函数" class="headerlink" title="assign()成员函数"></a>assign()成员函数</h3><p>优于for循环，好得多</p><p>区间成员函数优于与之对应的单元素成员函数。</p><p>erase()和insert()区间插入</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">a</span><span class="hljs-params">(<span class="hljs-number">1</span>,<span class="hljs-number">0</span>)</span></span>;<br>    vector&lt;<span class="hljs-type">int</span>&gt; b&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>&#125;;<br>    a.<span class="hljs-built_in">assign</span>(b.<span class="hljs-built_in">begin</span>(),b.<span class="hljs-built_in">end</span>());<span class="hljs-comment">//1 2 3 4 5</span><br><span class="hljs-comment">//    a.insert(a.end(),b.begin(),b.end());//0 1 2 3 4 5</span><br><span class="hljs-comment">//    a.insert(a.begin(),b.begin(),b.end());// 1 2 3 4 5 0</span><br>    a.<span class="hljs-built_in">erase</span>(a.<span class="hljs-built_in">begin</span>(),a.<span class="hljs-built_in">begin</span>()+<span class="hljs-number">2</span>);<span class="hljs-comment">//3 4 5</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i&lt;a.<span class="hljs-built_in">size</span>();++i)&#123;<br>        cout &lt;&lt; a[i] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4-25"><a href="#4-25" class="headerlink" title="4&#x2F;25"></a>4&#x2F;25</h2><p>a是已经排好序的序列，利用二分查找找出a中$a_i\leq k$ 的$a_i$ 的最小指针</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">lower_bound</span>(a,a+n,k);<br></code></pre></td></tr></table></figure><p>利用二分查找找出a中满足$a_i &gt; k$ 的$a_i$ 的最小指针</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">upper_bound</span>(a,a+n,k);<br></code></pre></td></tr></table></figure><p>于是，我们可以求出，在有序序列a中k的个数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">upper_bound</span>(a,a+n,k)-<span class="hljs-built_in">lower_bound</span>(a,a+n,k);<br></code></pre></td></tr></table></figure><h3 id="求划分数"><a href="#求划分数" class="headerlink" title="求划分数"></a>求划分数</h3><p>n个无区别的物品，将他们划分成<strong>不超过</strong>m组，求有多少种划分方法（对M取模）</p><p>这样想，考虑n的m划分$a_i(\sum_{i&#x3D;1}^m a_i&#x3D;n)$ 如果对于每个$i$ 都有$a_i&gt;0$ ，则$a_{i}-1$ 就对应了n-m的n划分。另外，如果存在$a_i&#x3D;0$，那么就对应了n的m-1划分。综上可以得出递推关系如下所示。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//</span><br><span class="hljs-comment">// Created by s&#x27;c on 2022/4/25.</span><br><span class="hljs-comment">//</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;bits/stdc++.h&quot;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> n,m,M;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MAX = <span class="hljs-number">1010</span>;<br><span class="hljs-type">int</span> dp[MAX][MAX];<span class="hljs-comment">//dp[i][j]表示j的i划分，把j划分成i份，有多少种划分方法</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>,&amp;n,&amp;m,&amp;M);<br>    dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i&lt;=m;++i)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;j&lt;=n;++j)&#123;<br>            <span class="hljs-keyword">if</span>(j&lt;i) dp[i][j] = dp[i<span class="hljs-number">-1</span>][j];<br>            <span class="hljs-keyword">else</span> dp[i][j] = (dp[i<span class="hljs-number">-1</span>][j] + dp[i][j-i])%M;<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,dp[m][n]);<br>&#125;<br></code></pre></td></tr></table></figure><p>若223 232 不算一组，则可以这样想    将j划分成i个，可以先取出k个，然后将剩下的j-k个分成i-1份，递推式如下</p><p>$dp[i][j] &#x3D; \sum_{k&#x3D;0}^j dp[i-1][j-k]$ </p><h2 id="4-28"><a href="#4-28" class="headerlink" title="4&#x2F;28"></a>4&#x2F;28</h2><h2 id="题目连接"><a href="#题目连接" class="headerlink" title="题目连接"></a>题目连接</h2><p><a href="https://www.papamelon.com/problem/225">https://www.papamelon.com/problem/225</a></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>用dp[i][j]表示从前i中物品中取出j个，一共有多少种取法<br>dp[i][j]: 考虑前 i 种物品中选出 j 个物品的方案数<br>将物品的种类从 1∼n 编号，答案则是：dp[n][m]</p><p>根据状态定义我们发现，每种物品可能取1，2，…a_i种可能。<br>接下来进行分类讨论：</p><ol><li>当$j&lt;&#x3D;a_i$时，$dp[i][j] &#x3D; dp[i-1][j]+dp[i-1][j-1]+…+dp[i-1][1]+dp[i-1][0]$</li><li>当$j&gt;a_i$时，$dp[i][j] &#x3D; dp[i-1][j]+dp[i-1][j-1]+…+dp[i-1][j-a_i]$</li></ol><p>设$b &#x3D; min(ai,j)$，则<br>$dp[i][j] &#x3D; dp[i-1][j]+dp[i-1][j-1]+…dp[i-1][j-b]$</p><p>但此时时间复杂度过高，每次求dp[i][j]都要遍历ai，这样复杂度为n*m*ai，一定会超时。考虑使用动态规划的递推思想优化。</p><h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><p>如何利用动态规划的递推思想呢？考虑对于$dp[i][j]$，若我们已知$dp[i][j-1]，$即$dp[i][j-1] &#x3D; dp[i-1][j-1]+dp[i-1][j-2]+…+dp[i-1][j-1-b]，b &#x3D; min(j-1,ai)$<br>此时还是要根据$j-1$与$a_i$的大小情况进行分类讨论</p><ol><li><p>$j-1&lt;&#x3D;a_i$时，$dp[i][j-1] &#x3D; dp[i-1][j-1]+dp[i-1][j-2]+…+dp[i-1][0]$，有$dp[i][j] &#x3D; dp[i][j-1]+dp[i-1][j]$</p></li><li><p>$j-1&gt;a_i$时，$dp[i][j-1] &#x3D; dp[i-1][j-1]+dp[i-1][j-2]+…+dp[i-1][j-ai]+dp[i-1][j-1-a_i]$，有$dp[i][j] &#x3D; dp[i][j-1]+dp[i-1][j]-dp[i-1][j-1-a_i]$</p><p>于是就得出了递推公式。</p></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//</span><br><span class="hljs-comment">// Created by s&#x27;c on 2022/4/28.</span><br><span class="hljs-comment">//</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;bits/stdc++.h&quot;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MAX = <span class="hljs-number">1010</span>;q` <br><span class="hljs-type">int</span> dp[MAX][MAX]=&#123;<span class="hljs-number">0</span>&#125;;<br><span class="hljs-type">int</span> a[MAX]=&#123;<span class="hljs-number">0</span>&#125;;<br><span class="hljs-type">int</span> M=<span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> n,m;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">tt</span><span class="hljs-params">()</span></span>&#123;<br>    cin&gt;&gt;n&gt;&gt;m&gt;&gt;M;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i&lt;=n;++i)&#123;<br>        cin&gt;&gt;a[i];<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i&lt;=n;++i)&#123;<br>        dp[i][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i&lt;=n;++i)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>;j&lt;=m;++j)&#123;<br>            <span class="hljs-keyword">if</span>(j<span class="hljs-number">-1</span>&lt;a[i])&#123;<br>                dp[i][j] = (dp[i][j<span class="hljs-number">-1</span>]+dp[i<span class="hljs-number">-1</span>][j])%M;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                dp[i][j] = (dp[i][j<span class="hljs-number">-1</span>]+dp[i<span class="hljs-number">-1</span>][j]-dp[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>-a[i]]+M)%M;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i&lt;=n;++i)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>;j&lt;=m;++j)&#123;<br>            cout &lt;&lt; dp[i][j] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>        &#125;<br>        cout &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,dp[n][m]);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">tt</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="注意-3"><a href="#注意-3" class="headerlink" title="注意"></a>注意</h3><ol><li>第一次写时，ai与dp[i][j]的对应关系没找好，注意ai是从0开始还是从1开始，dp[i][j]也要做相应的变化</li></ol><h2 id="题目连接226远征"><a href="#题目连接226远征" class="headerlink" title="题目连接226远征"></a>题目连接226远征</h2><p><a href="https://www.papamelon.com/problem/226">https://www.papamelon.com/problem/226</a></p><h4 id="思路讲解"><a href="#思路讲解" class="headerlink" title="思路讲解"></a>思路讲解</h4><p>本题也可采用贪心的思想去求解，只是为了求解方便，使用了优先队列数据结构。每次到加油站时，都要把加油站的油加光，这是贪心1；<br>另外，汽车不会加油，除非邮箱内的油不能支撑汽车到下一个加油站，这是贪心2.</p><p>另外，我们可以使用小技巧：每到一个加油站时，我们都默认获得了加油的资格，只是不把油加上，而是放到一个优先队列中（大顶堆）。<br>当需要加油的时候，就默认从优先队列中取出最大的，意思是在我到那个加油站的时候，已经加过油了。</p><p>失败条件：若当前邮箱里的油不能支撑汽车到下一个加油站了，但是优先队列已经空了，那么汽车不能到达终点，输出-1.</p><p>还有坑：</p><ol><li>第一遍做时，没有注意到给出的Ai是该加油站到终点的距离。</li><li>给出的加油站的距离可能没有排好序，需要重新排序。</li></ol><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//</span><br><span class="hljs-comment">// Created by s&#x27;c on 2022/4/28.</span><br><span class="hljs-comment">//</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;bits/stdc++.h&quot;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> N,L,P;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MAX = <span class="hljs-number">20010</span>;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span>&#123;<br>    vector&lt;pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;&gt; a;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;N);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i&lt;N;++i)&#123;<br>        <span class="hljs-type">int</span> t1,t2;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;t1,&amp;t2);<br>        a.<span class="hljs-built_in">emplace_back</span>(t1,t2);<br>    &#125;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;L,&amp;P);<br>    <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>,pos = <span class="hljs-number">0</span>,tank = P;<br><span class="hljs-comment">//    a[N] = L;</span><br><span class="hljs-comment">//    b[N] = 0;</span><br>    a.<span class="hljs-built_in">emplace_back</span>(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);<br>    <span class="hljs-built_in">sort</span>(a.<span class="hljs-built_in">begin</span>(),a.<span class="hljs-built_in">end</span>(),[&amp;](pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;&amp; a,pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;&amp; b)-&gt;<span class="hljs-type">bool</span> &#123;<span class="hljs-keyword">return</span> a.first&gt;b.first;&#125;);<br><span class="hljs-comment">//    for(int i = 0;i&lt;=N;++i)&#123;</span><br><span class="hljs-comment">//        cout &lt;&lt; &quot;loc=&quot; &lt;&lt; a[i].first &lt;&lt; &quot; &quot; &lt;&lt; &quot;you=&quot; &lt;&lt; a[i].second &lt;&lt; endl;</span><br><span class="hljs-comment">//    &#125;</span><br>    priority_queue&lt;<span class="hljs-type">int</span>&gt; maxHeap;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i&lt;=N;++i)&#123;<br>        <span class="hljs-type">int</span> loc = a[i].first;<br>        <span class="hljs-type">int</span> ll = a[i].second;<br>        <span class="hljs-type">int</span> d = L-loc-pos;<br>        <span class="hljs-keyword">while</span>(tank&lt;d)&#123;<br>            <span class="hljs-keyword">if</span>(maxHeap.<span class="hljs-built_in">empty</span>())&#123;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;-1\n&quot;</span>);<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>            <span class="hljs-type">int</span> add = maxHeap.<span class="hljs-built_in">top</span>();<br>            maxHeap.<span class="hljs-built_in">pop</span>();<br>            tank+=add;<br>            res++;<span class="hljs-comment">//加了一次油</span><br>        &#125;<br>        pos = L-loc;<br>        tank-=d;<br>        maxHeap.<span class="hljs-built_in">push</span>(ll);<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,res);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">solve</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="set查找集合中元素的方法"><a href="#set查找集合中元素的方法" class="headerlink" title="set查找集合中元素的方法"></a>set查找集合中元素的方法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//方法一：使用迭代器</span><br>set&lt;<span class="hljs-type">int</span>&gt;::iterator it = set.<span class="hljs-built_in">begin</span>();<br><span class="hljs-keyword">for</span>(;it!=set.<span class="hljs-built_in">end</span>();++it);<br><br><span class="hljs-comment">//方法二 使用count方法</span><br>set.<span class="hljs-built_in">count</span>(<span class="hljs-number">2</span>)&gt;<span class="hljs-number">0</span>  表明set中有元素<span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p>set是有序哈希表，相当于TreeSet，不能存放重复元素。</p><h3 id="map删除元素"><a href="#map删除元素" class="headerlink" title="map删除元素"></a>map删除元素</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">map&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; m;<br>m.<span class="hljs-built_in">erase</span>(key);<br></code></pre></td></tr></table></figure><h3 id="能存放重复值的multiset，重复键值的multimap"><a href="#能存放重复值的multiset，重复键值的multimap" class="headerlink" title="能存放重复值的multiset，重复键值的multimap"></a>能存放重复值的multiset，重复键值的multimap</h3><p>multiset还是有序的，multimap也还是有序的</p><h2 id="5-1"><a href="#5-1" class="headerlink" title="5&#x2F;1"></a>5&#x2F;1</h2><p>快速排序不稳定，想要稳定，就要用下面的代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// ca数组已经给出</span><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">id</span><span class="hljs-params">(n)</span></span>;<br><span class="hljs-built_in">iota</span>(id.<span class="hljs-built_in">begin</span>(),id.<span class="hljs-built_in">end</span>(),<span class="hljs-number">0</span>);<br><span class="hljs-built_in">sort</span>(id.<span class="hljs-built_in">begin</span>(),id.<span class="hljs-built_in">end</span>(),[&amp;](<span class="hljs-type">int</span> i,<span class="hljs-type">int</span> j)&#123;<span class="hljs-keyword">return</span> ca[i]==ca[j]?i&lt;j:ca[i]&lt;ca[j];&#125;);<br></code></pre></td></tr></table></figure><h3 id="周赛第四题"><a href="#周赛第四题" class="headerlink" title="周赛第四题"></a>周赛第四题</h3><p>字符串   计算贡献    dp   字符串的总引力</p><p><img src="https://cdn.jsdelivr.net/gh/dutsc/cloud-image/blog-img/202312052037678.png"></p><p><img src="https://cdn.jsdelivr.net/gh/dutsc/cloud-image/blog-img/202312052034202.png"></p><p>在字符串结尾添加一个新的字符，实时维护该字符上一次出现的下标；新字符对总引力值的贡献就是当前下标减去上一次出现的下标；若该字符还没有出现，则当前字符的贡献就是当前下标+1，+1的原因是考虑当前字符单独一个，也会贡献一个引力值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-title">appealSum</span><span class="hljs-params">(string s)</span> </span>&#123;<br>    <span class="hljs-type">int</span> n = s.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">loc</span><span class="hljs-params">(<span class="hljs-number">26</span>,<span class="hljs-number">-1</span>)</span></span>;<br>    ll sum = <span class="hljs-number">0</span>,res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i&lt;n;++i)&#123;<br>      <span class="hljs-type">int</span> c = s[i]-<span class="hljs-string">&#x27;a&#x27;</span>;<br>      <span class="hljs-keyword">if</span>(loc[c]==<span class="hljs-number">-1</span>)&#123;<br>        sum+=i+<span class="hljs-number">1</span>; <br>      &#125;<span class="hljs-keyword">else</span>&#123;<br>        sum+=i-loc[c];<br>      &#125;<br>      loc[c] = i;<br>      res+=sum;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="241并查集经典题"><a href="#241并查集经典题" class="headerlink" title="241并查集经典题"></a>241并查集经典题</h3><p>a吃b，b吃c，c吃a</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//</span><br><span class="hljs-comment">// Created by s&#x27;c on 2022/5/1.</span><br><span class="hljs-comment">//</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;bits/stdc++.h&quot;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MAXN = <span class="hljs-number">200000</span>;<br><span class="hljs-type">int</span> par[MAXN];<br><span class="hljs-type">int</span> ran[MAXN];<br><span class="hljs-type">int</span> N,K,a,b,c;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i&lt;=n;++i)&#123;<br>        par[i] = i;<br>        ran[i] = <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(x==par[x]) <span class="hljs-keyword">return</span> x;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> par[x]=<span class="hljs-built_in">find</span>(par[x]); <span class="hljs-comment">// 返回时更改节点的父节点为祖宗节点，就是路径压缩操作</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">unite</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span></span>&#123;<br>    <span class="hljs-type">int</span> fx = <span class="hljs-built_in">find</span>(x);<br>    <span class="hljs-type">int</span> fy = <span class="hljs-built_in">find</span>(y);<br>    <span class="hljs-keyword">if</span>(fx==fy) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-keyword">if</span>(ran[fx]&lt;ran[fy])&#123;<br>        par[fx] = fy;<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        par[fy] = fx;<br>        <span class="hljs-keyword">if</span>(ran[fx]==ran[fy]) ran[fx]++;  <span class="hljs-comment">// 这个优化有的题目会卡</span><br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin&gt;&gt;N&gt;&gt;K;<br>    <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">init</span>(<span class="hljs-number">3</span>*N);<br>    <span class="hljs-keyword">while</span>(K--&gt;<span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>,&amp;a,&amp;b,&amp;c);<br>        <span class="hljs-keyword">if</span>(b&gt;N||c&gt;N)&#123;<br>            res++;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(a==<span class="hljs-number">2</span> &amp;&amp; b==c)&#123;<br>            res++;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(a==<span class="hljs-number">1</span>)&#123; <span class="hljs-comment">// bc同一类</span><br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">find</span>(b)==<span class="hljs-built_in">find</span>(c+N) || <span class="hljs-built_in">find</span>(b)==<span class="hljs-built_in">find</span>(c+<span class="hljs-number">2</span>*N))&#123;<br>                res++;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-built_in">unite</span>(b,c);<br>            <span class="hljs-built_in">unite</span>(b+N,c+N);<br>            <span class="hljs-built_in">unite</span>(b+<span class="hljs-number">2</span>*N,c+<span class="hljs-number">2</span>*N);<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(a==<span class="hljs-number">2</span>)&#123;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">find</span>(b)==<span class="hljs-built_in">find</span>(c)||<span class="hljs-built_in">find</span>(b)==<span class="hljs-built_in">find</span>(c+N))&#123;<br>                res++;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-built_in">unite</span>(b+N,c);<br>            <span class="hljs-built_in">unite</span>(b+<span class="hljs-number">2</span>*N,c+N);<br>            <span class="hljs-built_in">unite</span>(b,c+<span class="hljs-number">2</span>*N);<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,res);<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="注意-4"><a href="#注意-4" class="headerlink" title="注意"></a>注意</h4><ol><li>必须要路径压缩，差距会非常大，即 find(x) 中 return par[x] &#x3D; find(par[x]);</li><li>可以进行rank优化，会更快一些</li></ol><h2 id="5-2"><a href="#5-2" class="headerlink" title="5&#x2F;2"></a>5&#x2F;2</h2><p>c++不要使用<strong>字符加字符串</strong>   ‘a’+”asdfa”  超级慢</p><h2 id="5-3"><a href="#5-3" class="headerlink" title="5&#x2F;3"></a>5&#x2F;3</h2><h3 id="二分图判定c-二着色问题"><a href="#二分图判定c-二着色问题" class="headerlink" title="二分图判定c++   二着色问题"></a>二分图判定c++   二着色问题</h3><p>问题连接</p><p><a href="https://www.papamelon.com/problem/242">https://www.papamelon.com/problem/242</a></p><p>学习的地方：</p><ol><li>以EOF结束输入的方法  <del>scanf();  因为</del>是按位取反，而EOF&#x3D;-1，补码表示是11111.</li><li>c++存图方式，虽然是最垃圾的，vector<int> G[MAX],若有权值或者其他信息，则</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">edge</span>&#123;<br>  <span class="hljs-type">int</span> to;<br>  <span class="hljs-type">int</span> cost;<br>  &#125;;<br>vector&lt;edge&gt; G[MAX];<br></code></pre></td></tr></table></figure><p>思路</p><p>创建一个邻接矩阵，一个color数组表示该节点被染成了什么颜色。由于只有两种颜色，故使用1与-1表示。</p><ol><li>dfs函数中，首先将节点染色，然后遍历该节点的邻接表，如果邻接节点染的颜色与本节点相同，则return false；如果邻接节点与本节点染色相反，则直接搜索下一个节点；如果邻接节点没有染色，<br>则将邻接节点染成相反的颜色。并且对dfs做判断，if(!dfs(下一个节点,-c)) return false;  之前也遇到过这个技巧，如果dfs返回true不要着急返回true，而是要判断所有的情况都return true才可以。</li><li>主函数中，由于给出的图可能不是联通图，故要使用for循环遍历一下，并判断color[i]有没有染色。</li></ol><p>代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c++">  <span class="hljs-comment">//</span><br><span class="hljs-comment">// Created by s&#x27;c on 2022/5/3.</span><br><span class="hljs-comment">//</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;bits/stdc++.h&quot;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MAX = <span class="hljs-number">1010</span>;<br><span class="hljs-type">int</span> n,x,y;<br>vector&lt;<span class="hljs-type">int</span>&gt; G[MAX];<br><span class="hljs-type">int</span> color[MAX]=&#123;<span class="hljs-number">0</span>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> k,<span class="hljs-type">int</span> c)</span></span>&#123;<br>    color[k] = c;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i&lt;G[k].<span class="hljs-built_in">size</span>();++i)&#123;<br>        <span class="hljs-type">int</span> to = G[k][i];<br>        <span class="hljs-keyword">if</span>(color[to]==c) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">if</span>(color[to]==<span class="hljs-number">0</span>)&#123; <span class="hljs-comment">//还没染色</span><br>            <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">dfs</span>(to,-c)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin&gt;&gt;n;<br>    <span class="hljs-keyword">while</span>(~<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;x,&amp;y))&#123;<br>        G[x].<span class="hljs-built_in">push_back</span>(y);<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i&lt;n;++i)&#123;<br>        <span class="hljs-keyword">if</span>(color[i]==<span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">dfs</span>(i,<span class="hljs-number">1</span>))&#123;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;No\n&quot;</span>);<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Yes\n&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="二维差分"><a href="#二维差分" class="headerlink" title="二维差分"></a>二维差分</h3><p><img src="C:/Users/s%27c/AppData/Roaming/Typora/typora-user-images/image-20220503100257497.png" alt="image-20220503100257497"></p><h2 id="5-8"><a href="#5-8" class="headerlink" title="5&#x2F;8"></a>5&#x2F;8</h2><p>带有剪枝的 <strong>状态dfs</strong></p><p>我的朴素代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">bool</span> used[<span class="hljs-number">105</span>][<span class="hljs-number">105</span>][<span class="hljs-number">210</span>]=&#123;<span class="hljs-number">0</span>&#125;;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">hasValidPath</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">char</span>&gt;&gt;&amp; grid)</span> </span>&#123;<br>        <span class="hljs-type">int</span> m = grid.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> n = grid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">if</span>(grid[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]==<span class="hljs-string">&#x27;)&#x27;</span> || grid[m<span class="hljs-number">-1</span>][n<span class="hljs-number">-1</span>]==<span class="hljs-string">&#x27;(&#x27;</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">dfs</span>(grid,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">dfs</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">char</span>&gt;&gt;&amp; grid,<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y,<span class="hljs-type">int</span> score)</span></span>&#123;<br>        <span class="hljs-type">int</span> m = grid.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> n = grid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">if</span>(score&gt;m-x+n-y<span class="hljs-number">-1</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        score += grid[x][y]==<span class="hljs-string">&#x27;(&#x27;</span>?<span class="hljs-number">1</span>:<span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">if</span>(score&lt;<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">if</span>(x==m<span class="hljs-number">-1</span> &amp;&amp; y==n<span class="hljs-number">-1</span>)&#123;<br>            <span class="hljs-keyword">if</span>(score==<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(used[x][y][score]) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        used[x][y][score] = <span class="hljs-literal">true</span>;<span class="hljs-comment">//此点的这个状态已经访问过</span><br>        <span class="hljs-keyword">if</span>(x+<span class="hljs-number">1</span>&lt;m)&#123;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">dfs</span>(grid,x+<span class="hljs-number">1</span>,y,score))&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(y+<span class="hljs-number">1</span>&lt;n)&#123;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">dfs</span>(grid,x,y+<span class="hljs-number">1</span>,score))&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>灵佬的带c++11特性的function函数代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">hasValidPath</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">char</span>&gt;&gt; &amp;grid)</span> </span>&#123;<br>        <span class="hljs-type">int</span> m = grid.<span class="hljs-built_in">size</span>(), n = grid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">if</span> ((m + n) % <span class="hljs-number">2</span> == <span class="hljs-number">0</span> || grid[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;)&#x27;</span> || grid[m - <span class="hljs-number">1</span>][n - <span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;(&#x27;</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">// 剪枝</span><br>        <span class="hljs-type">bool</span> vis[m][n][m + n]; <span class="hljs-built_in">memset</span>(vis, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(vis));<br>        function&lt;<span class="hljs-type">bool</span>(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>, <span class="hljs-type">int</span>)&gt; dfs = [&amp;](<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y, <span class="hljs-type">int</span> c) -&gt; <span class="hljs-type">bool</span> &#123;<br>            <span class="hljs-keyword">if</span> (c &gt; m - x + n - y - <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">// 剪枝：即使后面都是 &#x27;)&#x27; 也不能将 c 减为 0</span><br>            <span class="hljs-keyword">if</span> (x == m - <span class="hljs-number">1</span> &amp;&amp; y == n - <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> c == <span class="hljs-number">1</span>; <span class="hljs-comment">// 终点一定是 &#x27;)&#x27;</span><br>            <span class="hljs-keyword">if</span> (vis[x][y][c]) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">// 重复访问</span><br>            vis[x][y][c] = <span class="hljs-literal">true</span>;<br>            c += grid[x][y] == <span class="hljs-string">&#x27;(&#x27;</span> ? <span class="hljs-number">1</span> : <span class="hljs-number">-1</span>;<br>            <span class="hljs-keyword">return</span> c &gt;= <span class="hljs-number">0</span> &amp;&amp; (x &lt; m - <span class="hljs-number">1</span> &amp;&amp; <span class="hljs-built_in">dfs</span>(x + <span class="hljs-number">1</span>, y, c) || y &lt; n - <span class="hljs-number">1</span> &amp;&amp; <span class="hljs-built_in">dfs</span>(x, y + <span class="hljs-number">1</span>, c)); <span class="hljs-comment">// 往下或者往右</span><br>        &#125;;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">dfs</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="5-9"><a href="#5-9" class="headerlink" title="5&#x2F;9"></a>5&#x2F;9</h2><h3 id="prim算法思想"><a href="#prim算法思想" class="headerlink" title="prim算法思想"></a>prim算法思想</h3><p>一般使用邻接矩阵？？   邻接表的话，转换成邻接矩阵？？   <strong>还是要分析时间复杂度</strong></p><p>与dijkstra算法很类似，都是从某个顶点出发，不断添加边的算法</p><p>首先假设有一课只包含一个顶点v的树T，然后贪心地选取T和其他顶点之间相连地最小权值的边，并把它加入到T中，不断进行这个操作，就可以得到一课最小生成树了。</p><h3 id="Kruskal算法-使用并查集"><a href="#Kruskal算法-使用并查集" class="headerlink" title="Kruskal算法 使用并查集"></a>Kruskal算法 使用并查集</h3><p>Kruskal算法按照边的权值的顺序从小到大查看一遍，如果不产生边（重边也算在内），就把当前这条边加入到生成树中。</p><p>第一步就是对边排序   </p><p>第二步是遍历所有的边</p><h3 id="求到某个顶点v的次短路"><a href="#求到某个顶点v的次短路" class="headerlink" title="求到某个顶点v的次短路"></a>求到某个顶点v的次短路</h3><p>其实就是二选一</p><ol><li>到某个顶点u的最短路+u v之间的距离</li><li>到某个顶点u的次短路+ u v之间的距离</li></ol><p>因此要求的就是源点到每个顶点的最短路和次短路，分别用两个数组dis和dis2来表示</p><p>思路</p><ol><li>首先考虑该边能不能更新最短路，如果可以更新最短路就更新，把老的最短路放到次短路上（因为被更新就说明，原来的老的最短路已经不是最短路了，所以把它放到次短路上）；</li><li>若该边不能更新最短路，则考虑用该边更新次短路；若该边不能更新次短路，则不使用该边更新。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//</span><br><span class="hljs-comment">// Created by s&#x27;c on 2022/5/9.</span><br><span class="hljs-comment">//</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;bits/stdc++.h&quot;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; P;<br><span class="hljs-type">int</span> N,R;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MAX = <span class="hljs-number">0x3f3f3f3f</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> LEN =(<span class="hljs-type">int</span>)<span class="hljs-number">1e5</span>+<span class="hljs-number">10</span>;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">edge</span>&#123;<br>    <span class="hljs-type">int</span> to;<br>    <span class="hljs-type">int</span> cost;<br>&#125;;<br>vector&lt;edge&gt; G[LEN];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dijsktra</span><span class="hljs-params">(<span class="hljs-type">int</span> tt)</span></span>&#123;<br>    <span class="hljs-type">int</span> dist[<span class="hljs-number">5010</span>];<br>    <span class="hljs-type">int</span> dist2[<span class="hljs-number">5010</span>];<br>    priority_queue&lt;P,vector&lt;P&gt;,greater&lt;P&gt;&gt; que;<span class="hljs-comment">//按照边的权值从小到大排序</span><br>    <span class="hljs-built_in">memset</span>(dist,<span class="hljs-number">0x3f</span>,<span class="hljs-built_in">sizeof</span>(dist));<br>    <span class="hljs-built_in">memset</span>(dist2,<span class="hljs-number">0x3f</span>,<span class="hljs-built_in">sizeof</span>(dist2));<br>    dist[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br><span class="hljs-comment">//    dist2[1] = 0;</span><br>    que.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">P</span>(<span class="hljs-number">0</span>,<span class="hljs-number">1</span>));<br>    <span class="hljs-keyword">while</span>(!que.<span class="hljs-built_in">empty</span>())&#123;<br>        P p = que.<span class="hljs-built_in">top</span>();<br>        que.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-type">int</span> to = p.second;<br><span class="hljs-comment">//        if(dist2[to]&lt;p.first) continue;</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i&lt;G[to].<span class="hljs-built_in">size</span>();++i)&#123;<br>            <span class="hljs-type">int</span> toto = G[to][i].to;<br>            <span class="hljs-type">int</span> ccost = G[to][i].cost;<br>            <span class="hljs-type">int</span> temp = p.first+ccost;<span class="hljs-comment">// 注意这里不能写dist[to] 而必须要写p.first，因为此时最短和第二短都会入队，p.first不一定是最短的</span><br><span class="hljs-comment">//            cout &lt;&lt; &quot;p.first=&quot; &lt;&lt; p.first &lt;&lt; &quot; dist[to]=&quot; &lt;&lt; dist[to] &lt;&lt; endl;</span><br>            <span class="hljs-keyword">if</span>(dist[toto]&gt;temp)&#123;<br>                <span class="hljs-built_in">swap</span>(dist[toto],temp);<br>                que.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">make_pair</span>(dist[toto],toto));<br>            &#125;<br>            <span class="hljs-keyword">if</span>(temp&lt;dist2[toto] &amp;&amp; temp&gt;dist[toto])&#123;<br>                dist2[toto] = temp;<br>                que.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">make_pair</span>(dist2[toto],toto));<br>            &#125;<br>        &#125;<br>    &#125;<br><span class="hljs-comment">//    for(int i = 1;i&lt;=N;++i)&#123;</span><br><span class="hljs-comment">//        cout &lt;&lt; dist2[i] &lt;&lt; endl;</span><br><span class="hljs-comment">//    &#125;</span><br><span class="hljs-comment">//    cout &lt;&lt; &quot;N=&quot; &lt;&lt; N &lt;&lt; &quot; tt=&quot; &lt;&lt; tt &lt;&lt; endl;</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,dist2[tt]);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin&gt;&gt;N&gt;&gt;R;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i =<span class="hljs-number">0</span>;i&lt;R;++i)&#123;<br>        <span class="hljs-type">int</span> x,y,D;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>,&amp;x,&amp;y,&amp;D);<br>        edge e;<br>        e.to=y;<br>        e.cost=D;<br>        G[x].<span class="hljs-built_in">push_back</span>(e);<br>        edge e2;<br>        e2.cost=D;<br>        e2.to=x;<br>        G[y].<span class="hljs-built_in">push_back</span>(e2);<br>    &#125;<br><span class="hljs-comment">//    cout &lt;&lt; &quot;完成输入&quot; &lt;&lt; endl;</span><br>    <span class="hljs-built_in">dijsktra</span>(N);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="征兵亲密度-最小生成树"><a href="#征兵亲密度-最小生成树" class="headerlink" title="征兵亲密度 最小生成树"></a>征兵亲密度 最小生成树</h3><p>题目链接</p><p><a href="https://www.papamelon.com/problem/245">https://www.papamelon.com/problem/245</a></p><p>思路</p><p>可以将题目翻译成求最小生成树的问题</p><p>解释一下题意：招募每个人都要花钱，但是若女兵x和男兵y关系好，而且已经招募了其中一个，则招募另外一个的时候，就可以少花一些钱。可以想到的一种思路是，不考虑亲密度，招募所有人需要花费的钱为<br>10000*(N+M)，而考虑亲密度之后再减去相应的亲密度。为了使付的钱更少，也就是减去的亲密度更多，就需要找亲密度最大的情侣进行征兵。</p><p>若将亲密度转化为负数，则找最大亲密度，就相当于找最小的数，就可以利用最小生成树的克鲁斯卡尔算法解决这个问题。</p><p>注意，第一次写遇到的问题：</p><ol><li>使用边集数组存储所有的边，然后遍历所有的边，这样使用克鲁斯卡尔算法比窘方便。</li><li>一个关系不需要存储两遍。</li><li>由于男兵女兵都有编号为0，1，2…的人，而女兵有N个，所以不妨让男兵的编号为N+y，这样更方便用并查集解决问题。</li></ol><p>其实本质就是贪心的克鲁斯卡尔算法。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//</span><br><span class="hljs-comment">// Created by s&#x27;c on 2022/5/9.</span><br><span class="hljs-comment">//</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;bits/stdc++.h&quot;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-comment">//女N   男M</span><br><span class="hljs-type">int</span> T,N,M,R;<br><span class="hljs-type">int</span> x,y,d;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MAX = <span class="hljs-number">20010</span>;<br><span class="hljs-type">int</span> fa[MAX];<br><span class="hljs-type">int</span> rrank[MAX];<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">edge</span>&#123;<br>    <span class="hljs-type">int</span> from;<br>    <span class="hljs-type">int</span> to;<br>    <span class="hljs-type">int</span> cost;<br>&#125;;<br>vector&lt;edge&gt; relation;<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(<span class="hljs-type">const</span> edge&amp;e1,<span class="hljs-type">const</span> edge &amp;e2)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> e1.cost&lt;e2.cost;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i&lt;MAX;++i)&#123;<br>        fa[i] = i;<br>        rrank[i] = <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(x==fa[x]) <span class="hljs-keyword">return</span> x;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> fa[x]=<span class="hljs-built_in">find</span>(fa[x]);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span></span>&#123;<br>    <span class="hljs-type">int</span> fx = fa[x];<br>    <span class="hljs-type">int</span> fy = fa[y];<br>    <span class="hljs-keyword">if</span>(fx==fy) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-keyword">if</span>(rrank[fx]&lt;rrank[fy])&#123;<br>        fa[fx]=fy;<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        fa[fy]=fx;<br>        <span class="hljs-keyword">if</span>(rrank[fx]==rrank[fy])&#123;<br>            rrank[fx]++;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">same</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">find</span>(x)==<span class="hljs-built_in">find</span>(y);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin&gt;&gt;T;<br>    <span class="hljs-keyword">while</span>(T--&gt;<span class="hljs-number">0</span>)&#123;<br>        relation.<span class="hljs-built_in">clear</span>();<br>        <span class="hljs-built_in">init</span>();<span class="hljs-comment">//初始化并查集</span><br>        cin&gt;&gt;N&gt;&gt;M&gt;&gt;R;<br>        <span class="hljs-type">int</span> r = R;<br>        <span class="hljs-keyword">while</span>(R--&gt;<span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>,&amp;x,&amp;y,&amp;d);<br>            edge e1,e2;<br>            e1.from=x;<br>            e1.to=N+y;<br>            e1.cost=-d;<br>            relation.<span class="hljs-built_in">push_back</span>(e1);<br>        &#125;<br>        <span class="hljs-comment">//x   N+y</span><br>        <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// 把所有的边排序</span><br>        <span class="hljs-built_in">sort</span>(relation.<span class="hljs-built_in">begin</span>(),relation.<span class="hljs-built_in">end</span>(),cmp);<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i&lt;r;++i)&#123;<span class="hljs-comment">//遍历所有的边</span><br>            edge e = relation[i];<br>            <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">same</span>(e.from,e.to))&#123;<br>                <span class="hljs-built_in">merge</span>(e.from,e.to);<br>                res+=e.cost;<br>            &#125;<br>        &#125;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,<span class="hljs-number">10000</span>*(N+M)+res);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="5-10"><a href="#5-10" class="headerlink" title="5&#x2F;10"></a>5&#x2F;10</h2><h3 id="差分约束系统"><a href="#差分约束系统" class="headerlink" title="差分约束系统"></a>差分约束系统</h3><blockquote><p>构造一个有向图，跑SPFA</p></blockquote><p>使用图的思想求解不等式的一组可行解</p><p>$x_1-x_2&lt;3$ <strong>则从2到1连一条权值为3的边   终极源点是0  d1-d2&lt;3 d1指从0到1的边的最短距离</strong></p><p>从源点0到别的所有点可以连边，也可以不连，连就要都连成一样的数  <strong>类似一种基准</strong>  求出一种可行解即可，因为通常都不是只有一种解。 可以都初始化成0，因为这样就不用初始化答案数组了，省时省力</p><p>最终求从0到所有点的最短距离即可？?？</p><p>注意：</p><ol><li>第一次做本题时出错的原因是，建立源点时，源点0到每一个其他点的cost是0没错，但是到其他点的dist不应该是0，而应该是无穷大。因为还是求最短路的思想。</li></ol><p>洛谷差分约束系统模板题代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//</span><br><span class="hljs-comment">// Created by s&#x27;c on 2022/5/11.</span><br><span class="hljs-comment">//</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;bits/stdc++.h&quot;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> n,m;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">edge</span>&#123;<br>    <span class="hljs-type">int</span> to;<br>    <span class="hljs-type">int</span> cost;<br>&#125;;<br>vector&lt;edge&gt; G[<span class="hljs-number">5010</span>];<br>queue&lt;<span class="hljs-type">int</span>&gt; que;<br><span class="hljs-type">bool</span> used[<span class="hljs-number">5010</span>];<span class="hljs-comment">//是否在队中</span><br><span class="hljs-type">int</span> nums[<span class="hljs-number">5010</span>];<span class="hljs-comment">//入队次数</span><br><span class="hljs-type">int</span> dist[<span class="hljs-number">5010</span>]=&#123;<span class="hljs-number">0</span>&#125;;<span class="hljs-comment">// 到源点的最短距离</span><br><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">spfa</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) dist[i]=<span class="hljs-number">1e9</span>;<span class="hljs-comment">//最短路，初始值为inf</span><br>    dist[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i&lt;=n;++i)&#123;<br>        edge e;<br>        e.to = i;<br>        e.cost = <span class="hljs-number">0</span>;<br>        G[<span class="hljs-number">0</span>].<span class="hljs-built_in">push_back</span>(e);<br>    &#125;<br>    <span class="hljs-keyword">while</span>(m--&gt;<span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-type">int</span> a,b,y;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>,&amp;a,&amp;b,&amp;y);<br>        edge e;<br>        e.to = a;<br>        e.cost = y;<br>        G[b].<span class="hljs-built_in">push_back</span>(e);<br>    &#125;<br><br>    que.<span class="hljs-built_in">push</span>(<span class="hljs-number">0</span>);<br>    used[<span class="hljs-number">0</span>] = <span class="hljs-literal">true</span>;<br>    nums[<span class="hljs-number">0</span>]++;<br>    <span class="hljs-keyword">while</span>(!que.<span class="hljs-built_in">empty</span>())&#123;<br>        <span class="hljs-type">int</span> tt = que.<span class="hljs-built_in">front</span>();<br>        que.<span class="hljs-built_in">pop</span>();<br>        used[tt] = <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i&lt;G[tt].<span class="hljs-built_in">size</span>();++i)&#123;<br>            <span class="hljs-comment">//访问邻接表</span><br>            <span class="hljs-type">int</span> to = G[tt][i].to;<br>            <span class="hljs-type">int</span> cost = G[tt][i].cost;<br><span class="hljs-comment">//            cout &lt;&lt; &quot;访问邻接表了&quot; &lt;&lt; endl;</span><br><span class="hljs-comment">//            cout &lt;&lt; &quot;dist[to]=&quot; &lt;&lt; dist[to] &lt;&lt; &quot; cost=&quot; &lt;&lt; cost &lt;&lt; endl;</span><br>            <span class="hljs-keyword">if</span>(dist[to]&gt;dist[tt]+cost)&#123;<br>                dist[to] = dist[tt]+cost;<br><span class="hljs-comment">//                cout &lt;&lt; &quot;进行松弛操作了&quot; &lt;&lt; endl;</span><br>                <span class="hljs-keyword">if</span>(!used[to])&#123;<br>                    used[to] = <span class="hljs-literal">true</span>;<br>                    nums[to]++;<br>                    que.<span class="hljs-built_in">push</span>(to);<br>                    <span class="hljs-keyword">if</span>(nums[to]&gt;=n)&#123;<br>                        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;NO\n&quot;</span>);<br>                        <span class="hljs-keyword">return</span>;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br><br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i&lt;=n;++i)&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d%c&quot;</span>,dist[i],i==n?<span class="hljs-string">&#x27;\n&#x27;</span>:<span class="hljs-string">&#x27; &#x27;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin&gt;&gt;n&gt;&gt;m;<br>    <span class="hljs-built_in">spfa</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="5-13"><a href="#5-13" class="headerlink" title="5&#x2F;13"></a>5&#x2F;13</h2><h3 id="线段上的格点个数"><a href="#线段上的格点个数" class="headerlink" title="线段上的格点个数"></a>线段上的格点个数</h3><p>其实就是求最大公约数</p><p>$gcd(|x_1-x_2|,|y_1-y_2|)-1$</p><h3 id="区间筛法求素数"><a href="#区间筛法求素数" class="headerlink" title="区间筛法求素数"></a>区间筛法求素数</h3><p>之前我们了解过筛法求素数，现在我们思考一下，当面对某个区间$[a,b)$内的数求素数的个数时，要怎么求。</p><p>性质1： b以内最小质因数一定不超过$\sqrt(b)$ 。因此筛得$[2,\sqrt(b))$ 中质数的同时，也将其倍数从$[a,b)$ 中抹去。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//</span><br><span class="hljs-comment">// Created by s&#x27;c on 2022/5/13.</span><br><span class="hljs-comment">//</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;bits/stdc++.h&quot;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br>ll a,b;<br><span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br><span class="hljs-type">bool</span> is_prime[<span class="hljs-number">1000010</span>]=&#123;<span class="hljs-number">0</span>&#125;;<br><span class="hljs-type">int</span> primee[<span class="hljs-number">1000010</span>]=&#123;<span class="hljs-number">0</span>&#125;; <span class="hljs-comment">// [a,b) 区间内的数 是否是素数  下标0代表</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld%lld&quot;</span>,&amp;a,&amp;b);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>;<span class="hljs-number">1LL</span>*i*i&lt;b;++i)&#123;<br>        <span class="hljs-keyword">if</span>(!is_prime[i])&#123; <span class="hljs-comment">// 找到质数</span><br>            ll first = (a+i<span class="hljs-number">-1</span>)/i*i;<br>            <span class="hljs-keyword">for</span>(ll j = <span class="hljs-built_in">max</span>(<span class="hljs-number">2</span>*i*<span class="hljs-number">1LL</span>,first);j&lt;b;j+=i)&#123; <span class="hljs-comment">// 标记质数的倍数为合数</span><br>                <span class="hljs-type">int</span> id = (<span class="hljs-type">int</span>)(j-a);<br>                primee[id] = <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i&lt;(<span class="hljs-type">int</span>)(b-a);++i)&#123;<br>        <span class="hljs-keyword">if</span>(!primee[i]) res++;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,res);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="求大于a的第一个能被i整除的数"><a href="#求大于a的第一个能被i整除的数" class="headerlink" title="求大于a的第一个能被i整除的数"></a>求大于a的第一个能被i整除的数</h4><p>$\frac{a+i-1}{i} \times i$ </p><h2 id="5-14"><a href="#5-14" class="headerlink" title="5&#x2F;14"></a>5&#x2F;14</h2><h3 id="Carmichael-Numbers（卡迈克尔数）"><a href="#Carmichael-Numbers（卡迈克尔数）" class="headerlink" title="Carmichael Numbers（卡迈克尔数）"></a>Carmichael Numbers（卡迈克尔数）</h3><p>我们把对任意的$1&lt;x&lt;n$ 都有$x^n \equiv x(mod \quad n)$ 成立的<strong>合数</strong> n 称为Carmichael Numbers。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//</span><br><span class="hljs-comment">// Created by s&#x27;c on 2022/5/14.</span><br><span class="hljs-comment">//</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;bits/stdc++.h&quot;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> n;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br><span class="hljs-function">ll <span class="hljs-title">fastpow</span><span class="hljs-params">(ll a,ll b,ll mod)</span></span>&#123;<br>    ll res = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>(b&gt;<span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-keyword">if</span>(b%<span class="hljs-number">2</span>==<span class="hljs-number">1</span>)&#123;<br>            res = (res*a)%mod;<br>        &#125;<br>        a = (a*a)%mod;<br>        b = b&gt;&gt;<span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">is_prime</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>;i*i&lt;x;++i)&#123;<br>        <span class="hljs-keyword">if</span>(x%i==<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;n);<br>    <span class="hljs-keyword">while</span>(n!=<span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-type">bool</span> flag = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">is_prime</span>(n)) flag = <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> x = <span class="hljs-number">2</span>;flag &amp;&amp; x&lt;n;++x)&#123;<br>            ll t1 = <span class="hljs-built_in">fastpow</span>(x,n,n);<br>            <span class="hljs-keyword">if</span>(t1!=x*<span class="hljs-number">1LL</span>)&#123;<br>                flag = <span class="hljs-literal">false</span>;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(flag)&#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;The number %d is a Carmichael number.\n&quot;</span>,n);<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d is normal.\n&quot;</span>,n);<br>        &#125;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;n);<br>    &#125;<br><span class="hljs-comment">//cout &lt;&lt; fastpow(2,17,17) &lt;&lt; endl;</span><br><span class="hljs-comment">//cout &lt;&lt; fastpow(3,17,17) &lt;&lt; endl;</span><br><span class="hljs-comment">//cout &lt;&lt; fastpow(4,17,17) &lt;&lt; endl;</span><br><span class="hljs-comment">//cout &lt;&lt; fastpow(5,17,17) &lt;&lt; endl;</span><br><span class="hljs-comment">//cout &lt;&lt; fastpow(6,17,17) &lt;&lt; endl;</span><br><span class="hljs-comment">//cout &lt;&lt; fastpow(7,17,17) &lt;&lt; endl;</span><br><span class="hljs-comment">//cout &lt;&lt; fastpow(8,17,17) &lt;&lt; endl;</span><br><span class="hljs-comment">//cout &lt;&lt; fastpow(9,17,17) &lt;&lt; endl;</span><br><span class="hljs-comment">//cout &lt;&lt; fastpow(10,17,17) &lt;&lt; endl;</span><br><span class="hljs-comment">//cout &lt;&lt; fastpow(11,17,17) &lt;&lt; endl;</span><br><span class="hljs-comment">//cout &lt;&lt; fastpow(12,17,17) &lt;&lt; endl;</span><br><span class="hljs-comment">//cout &lt;&lt; fastpow(13,17,17) &lt;&lt; endl;</span><br><span class="hljs-comment">//cout &lt;&lt; fastpow(14,17,17) &lt;&lt; endl;</span><br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="往-ll-上加-int时，要格外注意"><a href="#往-ll-上加-int时，要格外注意" class="headerlink" title="往 ll 上加 int时，要格外注意"></a>往 ll 上加 int时，要格外注意</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++">ll res = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i&lt;n;++i)&#123;<br>    res+=<span class="hljs-number">1LL</span>*v1[i]*v2[n-i<span class="hljs-number">-1</span>];<br>&#125;<br></code></pre></td></tr></table></figure><ol><li><p><strong>必须$\times $ 1LL!!!!!!!!!!!!!</strong>      </p></li><li><p>在printf时，一定要  %lld   !!!!!!!!!!</p></li></ol><h3 id="疯狂矩阵"><a href="#疯狂矩阵" class="headerlink" title="疯狂矩阵"></a>疯狂矩阵</h3><p>题目连接</p><p><a href="https://www.papamelon.com/problem/254">https://www.papamelon.com/problem/254</a></p><p>主对角线：从左上，到右下<br>暂且考虑一下最后应该把哪一行交换到第1行。最后的第一行应该具有00…00或者10…00的形式。可以交换到第一行的行当然也可以交换到第2及以后的行。当有多个满足条件的行时，选择离第1行近的行对应的<br>最终费用要小。这点可以证明。</p><p>注意</p><ol><li>需要先预处理出 <strong>每一行内最后一个1的位置，0 - n-1</strong></li><li><strong>在交换时，不要交换实际矩阵的值，而是要交换lasto数组的值。</strong>因为在交换的过程中用不到实际矩阵。如果要交换实际矩阵，则每次交换后还要重新预处理lasto数组，白白增加了复杂度。</li></ol><p>代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//</span><br><span class="hljs-comment">// Created by s&#x27;c on 2022/5/14.</span><br><span class="hljs-comment">//</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;bits/stdc++.h&quot;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> T,n;<br><span class="hljs-type">int</span> g[<span class="hljs-number">45</span>][<span class="hljs-number">45</span>];<br><span class="hljs-type">int</span> lasto[<span class="hljs-number">45</span>];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;T);<br>    <span class="hljs-type">int</span> index = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>(index&lt;=T)&#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;n);<br>        <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i&lt;n;++i)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;j&lt;n;++j)&#123;<br>                <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;g[i][j]);<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 预处理每一行最后一个1的位置</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i&lt;n;++i)&#123;<br>            <span class="hljs-type">int</span> pos = <span class="hljs-number">-1</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;j&lt;n;++j)&#123;<br>                <span class="hljs-keyword">if</span>(g[i][j]==<span class="hljs-number">1</span>)&#123;<br>                    pos = j;<br>                &#125;<br>            &#125;<br>            lasto[i] = pos;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i&lt;n;++i)&#123;<br>            <span class="hljs-type">int</span> pos = <span class="hljs-number">-1</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = i;j&lt;n;++j)&#123;<br>                <span class="hljs-keyword">if</span>(lasto[j]&lt;=i)&#123;<br>                    pos = j;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>            <span class="hljs-comment">//交换</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = pos;j&gt;i;--j)&#123;<br>                <span class="hljs-built_in">swap</span>(lasto[j],lasto[j<span class="hljs-number">-1</span>]);<br>                res++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Case #%d: %d\n&quot;</span>,index,res);<br>        index++;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="5-15"><a href="#5-15" class="headerlink" title="5&#x2F;15"></a>5&#x2F;15</h2><h3 id="已知三角形三个顶点，求面积"><a href="#已知三角形三个顶点，求面积" class="headerlink" title="已知三角形三个顶点，求面积"></a>已知三角形三个顶点，求面积</h3><p><img src="https://cdn.jsdelivr.net/gh/dutsc/cloud-image/blog-img/202312052037913.png"></p><p>注意加绝对值 </p><h3 id="注意数量级"><a href="#注意数量级" class="headerlink" title="注意数量级"></a>注意数量级</h3><p>$2 \times 10^5$ 意思是 2后面有5个0</p><h2 id="5-27"><a href="#5-27" class="headerlink" title="5&#x2F;27"></a>5&#x2F;27</h2><h3 id="小数二分"><a href="#小数二分" class="headerlink" title="小数二分"></a>小数二分</h3><p>通常使用二分法，check函数O(n),二分O(logn) 总体O(nlog n)</p><p>问题连接</p><p><a href="https://www.papamelon.com/problem/258">https://www.papamelon.com/problem/258</a></p><p>思路</p><p>常规二分法的思路，使用二分检查结果，check函数复杂度为O(n)。</p><p>注意</p><ol><li>选择左右边界时，左边界选取0.0（因为有可能k&gt;长度最大的L），右边界选取最长的绳子的长度。</li><li>double类型在二分的时候，不存在+1的概念，每次都是以mid为边界。</li><li>循环结束条件变为循环100次，1次循环可以把区间范围缩小一半，100次循环则可以达到10^(-30)的精度范围，精度范围基本上没有问题。</li></ol><p>另外，也可以设置终止条件为(r-l)&gt;EPS这样，指定一个区间的大小。这种情况下，如果EPS取的太小，就有可能因为浮点小数精度的原因导致陷入死循环，需要额外注意。 </p><p>代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//</span><br><span class="hljs-comment">// Created by s&#x27;c on 2022/5/27.</span><br><span class="hljs-comment">//</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;bits/stdc++.h&quot;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> n,k;<br><span class="hljs-type">double</span> mmax = <span class="hljs-number">1.0</span>;<br><span class="hljs-type">double</span> a[<span class="hljs-number">100005</span>];<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(<span class="hljs-type">double</span> mid)</span></span>&#123;<br>    <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i&lt;n;++i)&#123;<br>        res+=(<span class="hljs-type">int</span>)(a[i]/mid);<br>    &#125;<br>    <span class="hljs-keyword">return</span> res&gt;=k;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;n,&amp;k);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i&lt;n;++i)&#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lf&quot;</span>,&amp;a[i]);<br>        mmax = <span class="hljs-built_in">max</span>(mmax,a[i]);<br>    &#125;<br>    <span class="hljs-type">double</span> l = <span class="hljs-number">0.0</span>,r = mmax;<br>    <span class="hljs-type">int</span> index = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(index++&lt;<span class="hljs-number">100</span>)&#123;<br>        <span class="hljs-type">double</span> mid = (r+l)/<span class="hljs-number">2.0</span>;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">check</span>(mid)) l = mid;<br>        <span class="hljs-keyword">else</span> r = mid;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%.2f&quot;</span>,<span class="hljs-built_in">floor</span>(r*<span class="hljs-number">100</span>)/<span class="hljs-number">100</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="最大化最小值问题"><a href="#最大化最小值问题" class="headerlink" title="最大化最小值问题"></a>最大化最小值问题</h3><h3 id="最小化最大值问题（"><a href="#最小化最大值问题（" class="headerlink" title="最小化最大值问题（"></a>最小化最大值问题（</h3><h2 id="6-8"><a href="#6-8" class="headerlink" title="6&#x2F;8"></a>6&#x2F;8</h2><h3 id="最大化平均值问题"><a href="#最大化平均值问题" class="headerlink" title="最大化平均值问题"></a>最大化平均值问题</h3><p>每个物品的重量为$w_i$ 价值为$v_i$  从中选出k个物品使得单位重量的价值最大。   <strong>并不是选择单位重量价值最大的物品，从高到低</strong> </p><h3 id="c-自定义优先队列排序"><a href="#c-自定义优先队列排序" class="headerlink" title="c++自定义优先队列排序"></a>c++自定义优先队列排序</h3><ul><li><p>优先队列排序时，建议使用仿函数 在定义的时候使用struct  重载()函数执行符    而且在写仿函数的时候不加()</p></li><li><p>sort自定义排序时，可以使用仿函数（struct，重写()函数执行符），也可以使用普通函数（bool cmp()），使用仿函数必须加()，使用普通函数bool cmp不用加()</p></li></ul><p>&#x3D;&#x3D;推荐使用仿函数&#x3D;&#x3D;</p><p><strong>使用仿函数自定义优先队列实例</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//</span><br><span class="hljs-comment">// Created by s&#x27;c on 2022/6/8.</span><br><span class="hljs-comment">//</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;queue&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;iostream&quot;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;P;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">cmp</span>&#123;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">const</span> pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; &amp;p1,<span class="hljs-type">const</span> pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; &amp;p2)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(p1.second*<span class="hljs-number">1.0</span>/p1.first&lt;=p2.second*<span class="hljs-number">1.0</span>/p2.first) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">cmp_sort</span>&#123;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp; o1,<span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp; o2)</span></span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">abs</span>(o1)&lt;<span class="hljs-built_in">abs</span>(o2);<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">cmp_sort2</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span>&amp; o1,<span class="hljs-type">const</span> <span class="hljs-type">int</span>&amp; o2)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">abs</span>(o1)&lt;<span class="hljs-built_in">abs</span>(o2);<br>&#125;<br><br>priority_queue&lt;pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;,vector&lt;pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;&gt;, cmp&gt; que;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-function">P <span class="hljs-title">p1</span><span class="hljs-params">(<span class="hljs-number">2</span>,<span class="hljs-number">2</span>)</span>,<span class="hljs-title">p2</span><span class="hljs-params">(<span class="hljs-number">5</span>,<span class="hljs-number">3</span>)</span>,<span class="hljs-title">p3</span><span class="hljs-params">(<span class="hljs-number">2</span>,<span class="hljs-number">1</span>)</span></span>;<br>    que.<span class="hljs-built_in">push</span>(p1);<br>    que.<span class="hljs-built_in">push</span>(p2);<br>    que.<span class="hljs-built_in">push</span>(p3);<br>    <span class="hljs-keyword">while</span>(!que.<span class="hljs-built_in">empty</span>())<br>    &#123;<br>        P p = que.<span class="hljs-built_in">top</span>();<br>        cout &lt;&lt; p.first &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; p.second &lt;&lt; endl;<br>        que.<span class="hljs-built_in">pop</span>();<br>    &#125;<br>    vector&lt;<span class="hljs-type">int</span>&gt; a;<br>    a.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">-3</span>);<br>    a.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">3</span>);<br>    a.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">36</span>);<br>    a.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">53</span>);<br>    a.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">322</span>);<br>    a.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">-93</span>);<br>    a.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-built_in">sort</span>(a.<span class="hljs-built_in">begin</span>(),a.<span class="hljs-built_in">end</span>(),cmp_sort2);<br>    <span class="hljs-comment">// sort(a.begin(),a.end(),cmp_sort()); 与之等价</span><br>    <span class="hljs-comment">// sort(a.begin(),a.end(),[](int a,int b)-&gt; bool&#123;return abs(a)&lt;abs(b);&#125;); 也可以使用labmda表达式</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> i:a)&#123;<br>        cout &lt;&lt; i &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    <br>&#125; <br><span class="hljs-comment">/*</span><br><span class="hljs-comment">2 2</span><br><span class="hljs-comment">5 3</span><br><span class="hljs-comment">2 1</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><h2 id="6-9"><a href="#6-9" class="headerlink" title="6&#x2F;9"></a>6&#x2F;9</h2><h3 id="尺取法"><a href="#尺取法" class="headerlink" title="尺取法"></a>尺取法</h3><p>使用尺取法时，while循环的判断条件不要是r&lt;n（右下标小于总数），这样会造成最右边的情况还没有处理，就跳出循环了。</p><p>较好的处理方式是：最外层是一个无限循环 break出循环的条件是：确保所有的情况已经处理完毕</p><h2 id="7-27"><a href="#7-27" class="headerlink" title="7&#x2F;27"></a>7&#x2F;27</h2><p>矩形之间的嵌套关系是一个典型的二元关系，二元关系可以用图来建模。</p><p>嵌套矩形：求DAG图中不固定起点的最长路径</p><h2 id="10-2"><a href="#10-2" class="headerlink" title="10&#x2F;2"></a>10&#x2F;2</h2><p>把一个数最低位的0变成1  <code>n|(n+1)</code></p><p>把一个数最低位的1变成0  <code>n&amp;(n-1)</code></p><h2 id="11-28-1"><a href="#11-28-1" class="headerlink" title="11&#x2F;28"></a>11&#x2F;28</h2><ol><li><p>反转链表  递归   双指针</p></li><li><p>topk 优先队列  快速排序</p></li><li><p>快速排序避免有序情况，可以首先花费o(N)将数组shuffle一下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Arrays;<br><span class="hljs-keyword">import</span> java.util.Random;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Created by 燃烧杯 on 2018/5/12.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ArrayUtils</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">Random</span> <span class="hljs-variable">rand</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Random</span>();<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-keyword">void</span> <span class="hljs-title function_">swap</span><span class="hljs-params">(T[] a, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span>&#123;<br>        <span class="hljs-type">T</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> a[i];<br>        a[i] = a[j];<br>        a[j] = temp;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-keyword">void</span> <span class="hljs-title function_">shuffle</span><span class="hljs-params">(T[] arr)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">length</span> <span class="hljs-operator">=</span> arr.length;<br>        <span class="hljs-keyword">for</span> ( <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> length; i &gt; <span class="hljs-number">0</span>; i-- )&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">randInd</span> <span class="hljs-operator">=</span> rand.nextInt(i);<br>            swap(arr, randInd, i - <span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        Integer[] arr = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>&#125;;<br>        shuffle(arr);<br>        System.out.println(Arrays.toString(arr));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h2 id="11-29-1"><a href="#11-29-1" class="headerlink" title="11&#x2F;29"></a>11&#x2F;29</h2><ol><li><p>实现LRU   哈希表+双向链表，手写双向链表</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">LRUCache</span> &#123;<br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">LinkedNode</span>&#123;<br>        <span class="hljs-type">int</span> key;<br>        <span class="hljs-type">int</span> val;<br>        LinkedNode pre;<br>        LinkedNode next;<br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">LinkedNode</span><span class="hljs-params">(<span class="hljs-type">int</span> _key,<span class="hljs-type">int</span> _val)</span>&#123;<br>            <span class="hljs-built_in">this</span>.key = _key;<br>            <span class="hljs-built_in">this</span>.val = _val;<br>            <span class="hljs-built_in">this</span>.pre = <span class="hljs-literal">null</span>;<br>            <span class="hljs-built_in">this</span>.next = <span class="hljs-literal">null</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-type">int</span> size;<br>    <span class="hljs-type">int</span> capacity;<br>    Map&lt;Integer,LinkedNode&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>    LinkedNode head;<br>    LinkedNode tail;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">LRUCache</span><span class="hljs-params">(<span class="hljs-type">int</span> c)</span> &#123;<br>        capacity = c;<br>        size = <span class="hljs-number">0</span>;<br>        head = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedNode</span>(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);<br>        tail = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedNode</span>(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);<br>        head.next = tail;<br>        tail.pre = head;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">get</span><span class="hljs-params">(<span class="hljs-type">int</span> key)</span> &#123;<br>        <span class="hljs-keyword">if</span>(map.get(key)!=<span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-comment">//存在 返回关键字的值</span><br>            <span class="hljs-comment">// 将该节点移到双向链表头部</span><br>            <span class="hljs-type">LinkedNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> map.get(key);<br>            moveToHead(node);<br>            <span class="hljs-keyword">return</span> node.val;<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-comment">// 不存在 返回-1</span><br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">put</span><span class="hljs-params">(<span class="hljs-type">int</span> key, <span class="hljs-type">int</span> value)</span> &#123;<br>        <span class="hljs-keyword">if</span>(map.get(key)!=<span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-comment">// 存在 更新值 </span><br>            <span class="hljs-comment">// 将该节点移到双向链表头部</span><br>            <span class="hljs-type">LinkedNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> map.get(key);<br>            node.val = value;<br>            moveToHead(node);<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-comment">// 不存在 直接插入</span><br>            <span class="hljs-comment">// 移到头部</span><br>            <span class="hljs-comment">// 容量超过，则删除尾部节点</span><br>            <span class="hljs-type">LinkedNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedNode</span>(key,value);<br>            map.put(key,node);<br>            addToHead(node);<br>            size++;<br>            <span class="hljs-keyword">if</span>(size&gt;capacity)&#123;<br>                <span class="hljs-type">LinkedNode</span> <span class="hljs-variable">myTail</span> <span class="hljs-operator">=</span> removeTail();<br>                map.remove(myTail.key);<br>                size--;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">moveToHead</span><span class="hljs-params">(LinkedNode node)</span>&#123;<br>        <span class="hljs-comment">// 删除该节点</span><br>        removeNode(node);<br>        <span class="hljs-comment">// 在头部插入该节点</span><br>        addToHead(node);<br>    &#125;<br>    <span class="hljs-keyword">public</span> LinkedNode <span class="hljs-title function_">removeNode</span><span class="hljs-params">(LinkedNode node)</span>&#123;<br>        node.pre.next = node.next;<br>        node.next.pre = node.pre;<br>        <span class="hljs-keyword">return</span> node;<span class="hljs-comment">// ?????</span><br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addToHead</span><span class="hljs-params">(LinkedNode node)</span>&#123;<br>        node.next = head.next;<br>        node.pre = head;<br>        head.next = node;<br>        node.next.pre = node;<br>    &#125;<br>    <span class="hljs-keyword">public</span> LinkedNode <span class="hljs-title function_">removeTail</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-comment">// 要返回删除的节点，因为程序中要删除map中的键值对</span><br>        <span class="hljs-type">LinkedNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> tail.pre;<br>        node.pre.next = tail;<br>        tail.pre = node.pre;<br>        <span class="hljs-keyword">return</span> node;  <br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your LRUCache object will be instantiated and called as such:</span><br><span class="hljs-comment"> * LRUCache obj = new LRUCache(capacity);</span><br><span class="hljs-comment"> * int param_1 = obj.get(key);</span><br><span class="hljs-comment"> * obj.put(key,value);</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure></li></ol><h2 id="12-2"><a href="#12-2" class="headerlink" title="12&#x2F;2"></a>12&#x2F;2</h2><h3 id="红黑树原理"><a href="#红黑树原理" class="headerlink" title="红黑树原理"></a>红黑树原理</h3><ol><li>（根属性）红黑树根节点必须是黑色</li><li>红色节点的孩子必须是黑色的。也就是说，不能由连续的红色节点；两个黑色的节点可以连接一起，也就是说，黑色节点的孩子可以是黑色（红属性）</li><li>红黑树把null作为叶子节点，AVL树不算null节点。（黑属性），任意一个节点，到它的叶子节点的所有路径，包含相同数目的黑色节点。</li><li>整棵红黑树的高度不超过 $2 log_2(n+1)$，n为节点个数</li></ol><p>黑色高度（black height）：从一个节点到他的叶子，经过的黑色节点数目，就叫做它的黑色高度</p><h4 id="红黑树插入情景"><a href="#红黑树插入情景" class="headerlink" title="红黑树插入情景"></a>红黑树插入情景</h4><blockquote><p>插入节点必须是红色节点</p></blockquote><ol><li><p>所插入的红黑树为空节点，则直接插入，并将红色节点染黑。</p></li><li><p>所插入的节点key已经存在，则将插入节点的value赋值给存在的节点，进行节点值更新。</p></li><li><p>所插入的节点的父节点是黑色，则直接插入即可。</p></li><li><p>所插入的节点的父节点是红色，</p><ol><li><p>情景4.1 叔叔节点存在且为红节点</p><p>将所插入节点称为x，则x的爸爸是红色。根据红黑树的性质（根节点一定是黑色），x一定存在一个爷爷节点，且爷爷节点是黑色。</p><p>处理步骤：</p><ol><li>将x的爸爸和叔叔节点改为黑色</li><li>将x的爷爷节点改成红色</li><li>将x的爷爷节点设置为当前节点，进行后续处理</li></ol><p>可以看到，如果x的爷爷节点的父节点是黑色，那么无需再做任何处理；但是如果x的爷爷节点是红色，则需要将x的爷爷节点设为当前节点，继续尽心插入操作自平衡处理，直到平衡为止。</p></li><li><p>情景4.2 叔叔节点不存在 或者叔叔节点为黑色节点，并且插入节点的父节点（P）是祖父节点（PP）的左子节点</p><ol><li>情景4.2.1 插入节点x是父节点（P）的左子节点  （<strong>LL双红</strong>）<ol><li>将父节点P染黑，祖父节点PP染红</li><li>将祖父节点右旋</li></ol></li><li>情景4.2.2 插入节点x是父节点（P）的右子节点（<strong>LR双红</strong>）<ol><li>将父节点P左旋</li><li>处理<strong>LL双红</strong>的情况</li></ol></li></ol></li><li><p>情景4.3 叔叔节点不存在或为黑色节点，并且插入节点的父亲节点P是祖父节点PP的右子节点</p><ol><li>情景4.3.1 新插入节点x是父节点P的右子节点（<strong>RR双红</strong>）<ol><li>将插入节点x的父亲节点染黑，祖父节点PP染红</li><li>然后将祖父节点左旋</li></ol></li><li>情景4.3.2 新插入节点x是父节点P的左子节点（<strong>RL双红</strong>）<ol><li>将父节点P右旋</li><li>处理<strong>RR双红</strong>的情况</li></ol></li></ol></li></ol></li></ol><h2 id="12-7"><a href="#12-7" class="headerlink" title="12&#x2F;7"></a>12&#x2F;7</h2><h3 id="删除链表"><a href="#删除链表" class="headerlink" title="删除链表"></a>删除链表</h3><ol><li>一般来讲，需要删除头节点，创建一个dummy node 头节点是比较合适的。<ul><li>不需要删除头节点的题目，就没有必要创建dummy node</li></ul></li><li>删除链表中的节点，一般需要定位到目标节点的上一个节点<ul><li>但若不能定位到上一个节点，脑筋急转弯，将下一个节点的值复制到本届点，然后删除下一个节点（保证目标节点不是尾节点）</li></ul></li></ol><h2 id="12-8"><a href="#12-8" class="headerlink" title="12&#x2F;8"></a>12&#x2F;8</h2><ol><li><p>JDK1.7源码中，求大于等于一个数的最小2次幂</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">8</span>;<br><span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> (ans-<span class="hljs-number">1</span>)&lt;&lt;<span class="hljs-number">1</span>;<br>i |= i&gt;&gt;<span class="hljs-number">1</span>;<br>i |= i&gt;&gt;<span class="hljs-number">2</span>;<br>i |= i&gt;&gt;<span class="hljs-number">4</span>;<br>i |= i&gt;&gt;<span class="hljs-number">8</span>;<br>i |= i&gt;&gt;<span class="hljs-number">16</span>;<br><span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> i - (i&gt;&gt;&gt;<span class="hljs-number">1</span>);<br><br>System.out.println(res);  <span class="hljs-comment">//8</span><br></code></pre></td></tr></table></figure></li></ol><h2 id="12-10"><a href="#12-10" class="headerlink" title="12&#x2F;10"></a>12&#x2F;10</h2><p>赋值语句</p><p>A&#x3D;B   <strong>A有了新的值 是B</strong></p><h2 id="3-13-1"><a href="#3-13-1" class="headerlink" title="3&#x2F;13"></a>3&#x2F;13</h2><p>分割字串：相邻元素之间加逗号</p>]]></content>
    
    
    
    <tags>
      
      <tag>学习记录</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Docker学习笔记</title>
    <link href="/2023/12/05/Docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2023/12/05/Docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h1><h2 id="一些前置知识"><a href="#一些前置知识" class="headerlink" title="一些前置知识"></a>一些前置知识</h2><h3 id="安装docker"><a href="#安装docker" class="headerlink" title="安装docker"></a>安装docker</h3><h3 id="chroot"><a href="#chroot" class="headerlink" title="chroot"></a>chroot</h3><p>是在Unix和 Linux系统的一个操作,针对正在运作的软件行程和它的子进程,改变它外显的根目录。一个运行在这个环境下,经由chroot设置根目录的程序,它不能够对这个指定根目录之外的文件进行访问动作,不能读取,也不能更改它的内容。</p><h3 id="容器技术原理"><a href="#容器技术原理" class="headerlink" title="容器技术原理"></a>容器技术原理</h3><ul><li><p>chroot</p></li><li><p>namespace：主机名，网络，PID等资源的隔离</p><p>Namespace对内核资源进行隔离，使得容器中的进程都可以在单独的命名空间中运行并且只可以访问当前容器命名空间的资源。</p><p>Namespace可以隔离进程ID、主机名、用户ID、文件名、网络访问和进程间通信等相关资源</p><p>docker主要用到以下五种命名空间：</p><ul><li>pid namespace：隔离进程ID</li><li>net namespace：隔离网络接口</li><li>mnt namespace：文件系统挂载点隔离</li><li>ipc namespace：信号量，消息队列和共享内存的隔离</li><li>uts namespace：主机名和域名的隔离</li></ul></li><li><p>cgroup：对进程或进程组做资源的限制</p><p>cgroup是一种Linux内核功能，可以限制和隔离进程的资源使用情况（CPU，内存，磁盘IO，网络等）</p></li><li><p>联合文件系统：用于镜像构建和容器运行环境</p><p>又叫UnionFS，是一种通过创建文件层进程操作的文件系统。常用的联合文件系统有AUFS、Overlay和Devicemapper等</p></li></ul><p>问题：容器技术在Docker出现之前一直没有爆发的根本原因？？</p><h3 id="镜像，容器，仓库"><a href="#镜像，容器，仓库" class="headerlink" title="镜像，容器，仓库"></a>镜像，容器，仓库</h3><ul><li><p>镜像：是一个只读的 Docker容器模板，包含启动容器所需要的所有文件系统结构和内容。</p><p>镜像是一个特殊的文件系统，它提供了容器运行时所需的程序，软件库，资源，配置等静态数据。镜像不包含任何动态数据，镜像内容在构建后不会被改变。</p></li><li><p>容器：容器是镜像的运行实体。容器的本质是主机上运行的一个进程，但是容器有自己的命名空间隔离和资源限制。在容器内部，无法看到主机上的进程，环境变量，网络等信息。</p></li><li><p>仓库：是存储和分发Docker镜像的地方</p><ul><li>公共镜像仓库：</li><li>私有镜像仓库</li></ul><p>注册服务器是用来存放仓库的实际服务器，仓库可以被理解为一个具体的项目或者目录</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/dutsc/cloud-image/blog-img/202312051629203.png" alt="容器-镜像-仓库"></p><p><img src="https://cdn.jsdelivr.net/gh/dutsc/cloud-image/blog-img/202312051630235.png" alt="注册服务器与仓库"></p><h4 id="往仓库中推送镜像"><a href="#往仓库中推送镜像" class="headerlink" title="往仓库中推送镜像"></a>往仓库中推送镜像</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker login<br><br><span class="hljs-comment"># 输入用户名和密码</span><br><br><span class="hljs-comment"># 将本地镜像重命名，只有这样才能推送成功</span><br>docker tag busybox dutsc/busybox<br>docker push dutsc/busybox<br></code></pre></td></tr></table></figure><h4 id="搭建私有镜像仓库"><a href="#搭建私有镜像仓库" class="headerlink" title="搭建私有镜像仓库"></a>搭建私有镜像仓库</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker run -d -p 5000:5000 --name registry registry:2.7<br></code></pre></td></tr></table></figure><p>这时，我们就有了一个私有的镜像仓库，ip为localhost，端口号为5000</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker tag busybox localhost:5000/busybox<br><br>docker push localhost:5000/busybox<br></code></pre></td></tr></table></figure><h4 id="构建外部可以访问的镜像仓库"><a href="#构建外部可以访问的镜像仓库" class="headerlink" title="构建外部可以访问的镜像仓库"></a>构建外部可以访问的镜像仓库</h4><p><img src="https://cdn.jsdelivr.net/gh/dutsc/cloud-image/blog-img/202312051633629.png"></p><p><img src="https://cdn.jsdelivr.net/gh/dutsc/cloud-image/blog-img/202312051632401.png"></p><p><img src="https://cdn.jsdelivr.net/gh/dutsc/cloud-image/blog-img/202312051634422.png"></p><p><img src="https://cdn.jsdelivr.net/gh/dutsc/cloud-image/blog-img/202312051634252.png"></p><p><img src="https://cdn.jsdelivr.net/gh/dutsc/cloud-image/blog-img/202312051634260.png"></p><h3 id="OCI"><a href="#OCI" class="headerlink" title="OCI"></a>OCI</h3><p>全称 open container Initiative  开放容器标准，是一个轻量级，开放的治理结构</p><ul><li>容器运行时标准：runtime spec</li><li>容器镜像标准：image spec</li></ul><h3 id="docker架构"><a href="#docker架构" class="headerlink" title="docker架构"></a>docker架构</h3><p><img src="https://cdn.jsdelivr.net/gh/dutsc/cloud-image/blog-img/202312051634352.png"></p><p>docker客户端与服务器端通信方式：</p><ul><li>在同一台机器上通过Unix套接字通信</li><li>通过网络连接远程通信</li></ul><h4 id="docker客户端"><a href="#docker客户端" class="headerlink" title="docker客户端"></a>docker客户端</h4><ul><li>docker命令是docker用户与docker客户端进行交互的主要方式</li><li>使用直接请求REST API的方式与docker服务端交互</li><li>使用各种语言的SDK与docker服务端交互</li></ul><h4 id="docker服务端"><a href="#docker服务端" class="headerlink" title="docker服务端"></a>docker服务端</h4><ul><li>docker服务端是Docker所有后台服务的总称</li><li>dockerd负责响应和处理来自Docker客户端的请求，然后将客户端的请求转化为Docker的具体操作</li></ul><p><img src="https://cdn.jsdelivr.net/gh/dutsc/cloud-image/blog-img/202312051634870.png"></p><h3 id="docker重要组件"><a href="#docker重要组件" class="headerlink" title="docker重要组件"></a>docker重要组件</h3><ul><li>runC：用来运行容器的轻量级工具，是真正用来运行容器的</li><li>containerd：通过container-shim启动并管理runC。containerd真正管理了容器的生命周期。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/dutsc/cloud-image/blog-img/202312051634646.png" alt="docker服务端架构"></p><p>dockerd通过gRPC与containerd通信</p><h4 id="一个实例"><a href="#一个实例" class="headerlink" title="一个实例"></a>一个实例</h4><p><img src="https://cdn.jsdelivr.net/gh/dutsc/cloud-image/blog-img/202312051634850.png"></p><p><img src="https://cdn.jsdelivr.net/gh/dutsc/cloud-image/blog-img/202312051635858.png"></p><p><img src="https://cdn.jsdelivr.net/gh/dutsc/cloud-image/blog-img/202312051635324.png"></p><p>dockerd启动时，containerd就随之启动了，dockerd与containerd一直存在。当执行docker run命令时， containerd会创建containerd-shim充当垫片进程，然后启动容器的真正进程。</p><h3 id="镜像操作"><a href="#镜像操作" class="headerlink" title="镜像操作"></a>镜像操作</h3><p><img src="https://cdn.jsdelivr.net/gh/dutsc/cloud-image/blog-img/202312051635232.png"></p><p>查看镜像，并过滤出busybox镜像：<code>docker iamges |grep busybox</code></p><h2 id="经验"><a href="#经验" class="headerlink" title="经验"></a>经验</h2><h3 id="默认网络配置"><a href="#默认网络配置" class="headerlink" title="默认网络配置"></a>默认网络配置</h3><p>docker若使用默认网络配置bridge，重启一次容器会重新分配ip地址</p><h3 id="跨宿主机通信"><a href="#跨宿主机通信" class="headerlink" title="跨宿主机通信"></a>跨宿主机通信</h3><p>需要在Docker主机上添加静态路由????</p><h3 id="查看docker容器的ip地址"><a href="#查看docker容器的ip地址" class="headerlink" title="查看docker容器的ip地址"></a>查看docker容器的ip地址</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker inspect -f &#x27;&#123;&#123;range .NetworkSettings.Networks&#125;&#125;&#123;&#123;.IPAddress&#125;&#125;&#123;&#123;end&#125;&#125;&#x27; 容器号/容器名称<br></code></pre></td></tr></table></figure><p>这样得到的结果与在docker中使用ifconfig命令得到的结果是一样的</p><h4 id="查看所有容器的ip地址"><a href="#查看所有容器的ip地址" class="headerlink" title="查看所有容器的ip地址"></a>查看所有容器的ip地址</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker inspect $(docker ps -q ) \<br>--format=&#x27;&#123;&#123; printf &quot;%-50s&quot; .Name&#125;&#125; &#123;&#123;range .NetworkSettings.Networks&#125;&#125;&#123;&#123;.IPAddress&#125;&#125; &#123;&#123;end&#125;&#125;&#x27;<br></code></pre></td></tr></table></figure><h4 id="docker的ip重启后会发生变化"><a href="#docker的ip重启后会发生变化" class="headerlink" title="docker的ip重启后会发生变化"></a>docker的ip重启后会发生变化</h4><p>在docker中，重启后ip是会变的；docker默认采用bridge连接，启动容器的时候会按照顺序来获取对应ip地址，这就导致容器每次重启后ip都会发生变化。</p><h3 id="创建自定义网络解决IP不固定的问题"><a href="#创建自定义网络解决IP不固定的问题" class="headerlink" title="创建自定义网络解决IP不固定的问题"></a>创建自定义网络解决IP不固定的问题</h3><ol><li><p>创建自定义网络，指定ip网段</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker network create --subnet=172.20.0.0/16 netsc<br><br>(base) sc@NSL-1:/etc/docker$ docker network ls<br>NETWORK ID     NAME      DRIVER    SCOPE<br>2076afc0f56f   bridge    bridge    local<br>1f5f0288ece5   host      host      local<br>4bc4edf2b20a   netsc     bridge    local<br>fed48795e6f5   none      null      local<br></code></pre></td></tr></table></figure></li><li><p>创建容器时，–net参数采用netsc即可，同时记得配置–ip参数，这样容器重启时其ip也不会变化。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker run -it --net netsc --ip 172.20.0.101 --gpus &#x27;device=0&#x27; --name torch0 -v /data/sc:/data fa50f7fed43a<br></code></pre></td></tr></table></figure></li></ol><h3 id="–net"><a href="#–net" class="headerlink" title="–net"></a>–net</h3><h4 id="host"><a href="#host" class="headerlink" title="host"></a>host</h4><p>WARNING: Published ports are discarded when using host network mode</p><p>使用主机网络模式时，run容器时使用的端口映射将被丢弃</p><p>相当于VMware 中的桥接模式，与宿主机在同一个网络中，但是没有独立IP地址</p><p>　　Docker 使用了Linux 的Namespace 技术来进行资源隔离，如 PID Namespace 隔离进程，Mount Namespace 隔离文件系统，Network Namespace 隔离网络等。一个Network Namespace 提供了一份独立的网络环境，包括网卡，路由，iptable 规则等都与其他Network Namespace 隔离。一个Docker 容器一般会分配一个独立的Network Namespace。</p><p>　　但是如果启动容器的时候使用host 模式，那么这个容器将不会获得一个独立的Network Namespace ，而是和宿主机共用一个Network Namespace 。容器将不会虚拟出自己的网卡，配置自己的IP等，而是使用宿主机的IP和端口范围。此时容器不再拥有隔离的、独立的网络栈。不拥有端口资源。</p><h4 id="bridge"><a href="#bridge" class="headerlink" title="bridge"></a>bridge</h4><p><img src="https://cdn.jsdelivr.net/gh/dutsc/cloud-image/blog-img/202312051651602.png"></p><p>单独容器中的应用通过桥接网络互相通讯，也就是图中的mybridge，在服务器中是docker0，功能类似于一个物理交换机。</p><h2 id="镜像命令"><a href="#镜像命令" class="headerlink" title="镜像命令"></a>镜像命令</h2><p><code>docker search hello-world</code>: 在远程仓库查找有没有hello-world这个镜像</p><p><code>docker images</code> :    -a  列出所有镜像信息      -q  只列出镜像ID</p><p><code>docker pull 镜像名字 [:TAG]</code> :  从rep拉取镜像</p><p><code>docker system df</code> :  查看镜像、容器、数据卷所占的空间</p><p><code>docker rmi 镜像名字</code> : 删除    -f  强制删除   可以删除多个镜像  加多个镜像名字或者ID   可以带上:TAG</p><p>虚悬镜像 repository仓库名和tag都是&lt; none &gt; 的镜像叫做虚悬镜像</p><h2 id="容器是什么"><a href="#容器是什么" class="headerlink" title="容器是什么"></a>容器是什么</h2><p>容器是基于镜像创建的可运行实例，并且单独存在。一个镜像可以创建出多个容器。</p><p><img src="https://cdn.jsdelivr.net/gh/dutsc/cloud-image/blog-img/202312051651140.png"></p><p>创建容器实际上是在镜像层上创建一个容器层，可读写，允许修改镜像的整个副本。</p><p>容器是在镜像的只读层上创建了可写层，并且容器中的进程属于运行状态，容器是真正的应用载体。</p><h3 id="容器的生命周期"><a href="#容器的生命周期" class="headerlink" title="容器的生命周期"></a>容器的生命周期</h3><p><img src="https://cdn.jsdelivr.net/gh/dutsc/cloud-image/blog-img/202312051651313.png"></p><p><img src="https://cdn.jsdelivr.net/gh/dutsc/cloud-image/blog-img/202312051651765.png"></p><h3 id="docker-run之后Docker的操作"><a href="#docker-run之后Docker的操作" class="headerlink" title="docker run之后Docker的操作"></a>docker run之后Docker的操作</h3><p><code>docker run -it --name busybox busybox</code></p><ol><li>Docker会检查本地是否存在busybox镜像</li><li>使用busybox镜像创建并启动一个容器</li><li>分配文件系统，并在镜像只读层外创建一个读写层</li><li>从Docker IP池中分配一个IP给容器</li><li>执行用户的启动命令运行镜像</li></ol><p>对容器来说，杀死容器中的主进程，则容器也会被杀死。</p><p>问题：</p><p>&#x3D;&#x3D;为什么容器的文件系统要设计成写时复制，而不是每一个容器都单独拷贝一份镜像文件？&#x3D;&#x3D;</p><h2 id="容器命令"><a href="#容器命令" class="headerlink" title="容器命令"></a>容器命令</h2><blockquote><p>在Docker中，使用run来生成一个一个的容器实例</p></blockquote><h3 id="新建-启动容器"><a href="#新建-启动容器" class="headerlink" title="新建+启动容器"></a>新建+启动容器</h3><p>docker run -it -name tfsc –gpus all -p 8089:22 -shm-size 32g  </p><p><code>docker run [OPTIONS] IMAGE [COMMAND][ARG...]</code>:</p><p><code>[OPTIONS]</code>说明：</p><ol><li>–name&#x3D;”容器名字” </li><li>-d: 后台运行容器并返回容器ID，也即启动守护式容器</li><li>-i：以交互式模是与你虚拟狗让其，通常与-t同时使用</li><li>-t：为容器重新分配一个伪输入终端，通常与-i同时使用<br>也即启动交互式容器（前台有伪终端，等待交互）</li><li>-P  -p 端口分配<br><img src="https://cdn.jsdelivr.net/gh/dutsc/cloud-image/blog-img/202312051651305.png"></li></ol><p>&#x3D;&#x3D;<code>docker run -it ubuntu /bin/bash</code>&#x3D;&#x3D; : 启动一个ubuntu镜像实例化的容器</p><p><code>docker run -it --name=shenchen ubuntu bash</code>: 命名容器</p><p><code>docker run -it --name=&quot;sc&quot; --gpus all --shm-size 32g registry.baidubce.com/paddlepaddle/paddle:2.3.2-gpu-cuda11.2-cudnn8 /bin/bash</code></p><p>镜像名称:TAG 放在最后，&#x2F;bin&#x2F;bash之前</p><h3 id="重命名容器"><a href="#重命名容器" class="headerlink" title="重命名容器"></a>重命名容器</h3><p><code>docker rename 旧容器名 新容器名</code></p><h3 id="列出当前所有运行的容器"><a href="#列出当前所有运行的容器" class="headerlink" title="列出当前所有运行的容器"></a>列出当前所有运行的容器</h3><p><code>docker ps [OPTIONS]</code>  : 列出当前所有正在运行的容器实例</p><p><code>[OPTIONS]</code>:</p><ol><li>-a：列出当前所有正在运行的容器，和运行过的容器</li><li>-l：显示最近创建的容器</li><li>-n：显示最近n个创建的容器</li><li>-q：静默模式，只显示容器编号</li></ol><h3 id="退出容器"><a href="#退出容器" class="headerlink" title="退出容器"></a>退出容器</h3><p><code>exit</code>:  run进去，exit退出，容器停止</p><p><code>ctrl+p+q</code>:  容器不停止</p><h3 id="启动已经停止运行的容器"><a href="#启动已经停止运行的容器" class="headerlink" title="启动已经停止运行的容器"></a>启动已经停止运行的容器</h3><p><code>docker start 容器ID或者容器名字</code></p><h3 id="重启容器"><a href="#重启容器" class="headerlink" title="重启容器"></a>重启容器</h3><p><code>docker restart 容器ID或者容器名</code></p><h3 id="停止容器"><a href="#停止容器" class="headerlink" title="停止容器"></a>停止容器</h3><p><code>docker stop 容器ID或容器名 [-t|--time[=10]]</code></p><ul><li>该命令首先会向运行中的容器发送SIGTERM（软件终止信号）信号。如果容器内1号接受并能够处理SIGTERM，则等待1号进程处理完毕并退出。</li><li>如果等待一段时间后，容器仍然没有退出，则会发送SIGKILL（杀死进程）强制中止容器。</li></ul><h3 id="强制停止容器"><a href="#强制停止容器" class="headerlink" title="强制停止容器"></a>强制停止容器</h3><p><code>docker kill 容器ID或容器名</code></p><h3 id="删除已停止的容器"><a href="#删除已停止的容器" class="headerlink" title="删除已停止的容器"></a>删除已停止的容器</h3><p><code>docker rm 容器ID</code></p><p>&#x3D;&#x3D;注意：rmi删的是镜像image，rm删的是容器container&#x3D;&#x3D;</p><p><code>rm -f</code> 强制删除  </p><p>一次性删除多个容器：<img src="https://cdn.jsdelivr.net/gh/dutsc/cloud-image/blog-img/202312051651344.png"></p><p>| xargs     管道参数：docker ps -a -q的命令结果可以直接作为docker rm 的输入参数</p><p>如何重新进入活动状态下的容器？</p><h3 id="启动守护式容器"><a href="#启动守护式容器" class="headerlink" title="启动守护式容器"></a>启动守护式容器</h3><p><code>docker run -d 镜像</code>  : 守护式容器</p><p>&#x3D;&#x3D;but&#x3D;&#x3D; docker容器后台运行，就必须有一个前台进程。最佳解决方案：将你要运行的程序以前台进程的形式运行。</p><p><img src="https://cdn.jsdelivr.net/gh/dutsc/cloud-image/blog-img/202312051651048.png"></p><p>使用 docker run -d redis </p><p>​         docker ps        redis不会退出，而是会正常显示，因为redis有服务器功能，ubuntu直接退出，因为ubuntu只是操作系统</p><h3 id="查看容器日志"><a href="#查看容器日志" class="headerlink" title="查看容器日志"></a>查看容器日志</h3><p><code>docker logs 容器号/容器名</code></p><h3 id="查看容器内的运行进程"><a href="#查看容器内的运行进程" class="headerlink" title="查看容器内的运行进程"></a>查看容器内的运行进程</h3><p><code>docker top 容器号</code></p><h3 id="查看容器内部细节"><a href="#查看容器内部细节" class="headerlink" title="查看容器内部细节"></a>查看容器内部细节</h3><p><code>docker inspect 容器ID</code></p><h3 id="进入正在运行的容器并以命令行交互"><a href="#进入正在运行的容器并以命令行交互" class="headerlink" title="&#x3D;&#x3D;进入正在运行的容器并以命令行交互&#x3D;&#x3D;"></a>&#x3D;&#x3D;进入正在运行的容器并以命令行交互&#x3D;&#x3D;</h3><p><code>docker exec -it 容器ID /bin/bash</code></p><p><code>docker attach 容器ID</code> ：注意:同时使用docker attach命令同时在多个终端运行时，所有的终端窗口将同步显<br>示相同内容，当某个命令行窗口的命令阻塞时，其它命令行窗口同样也无法操作。</p><p><code>esenter</code></p><p>区别：</p><ol><li>attach 直接进入容器启动命令的终端，不会启动新的进程，用exit退出，会导致容器的停止</li><li>exec是在容器中打开新的终端，并且可以启动新的进程，用exit退出，不会导致容器终止。每个窗口都是独立且相互不干扰的。</li></ol><h3 id="从容器内拷贝文件到主机上"><a href="#从容器内拷贝文件到主机上" class="headerlink" title="从容器内拷贝文件到主机上"></a>从容器内拷贝文件到主机上</h3><p>容器——&gt; 主机</p><p><code>docker cp 容器ID:容器内路径 目的主机路径</code></p><h3 id="导入和导出容器"><a href="#导入和导出容器" class="headerlink" title="导入和导出容器"></a>导入和导出容器</h3><p>export导出容器的内容留作一个tar归档文件[对应import命令]</p><p>import从tar包中的内容创建一个新的文件系统再导入为镜像[对应export]</p><p><code>docker export 容器ID &gt; 文件名.tar</code>      默认导出到当前目录下面，相当于把整个容器打成了一个tar包，备份了整个容器</p><p><code>cat 文件名.tar | docker import -镜像用户/镜像名:镜像版本号</code> </p><p><code>docker import [OPTIONS] file|URL [REPOSITORY[:TAG]]</code></p><p>执行完docker import之后，会变成本地镜像，最后使用docker run启动该镜像</p><p>例子</p><p><code>docker import busybox.tar busybox:test</code></p><h3 id="提交容器为镜像"><a href="#提交容器为镜像" class="headerlink" title="提交容器为镜像"></a>提交容器为镜像</h3><p><code>docker commit dd53ea4c2f2b ubuntu:ssh</code></p><h2 id="镜像"><a href="#镜像" class="headerlink" title="镜像"></a>镜像</h2><blockquote><p>镜像是分层的</p></blockquote><h3 id="UnionFS联合文件系统"><a href="#UnionFS联合文件系统" class="headerlink" title="UnionFS联合文件系统"></a><strong>UnionFS联合文件系统</strong></h3><p>Union文件系统〈UnionFS)是一种分层、轻量级并且高性能的文件系统，它支持对文件系统的修改作为一次提交来一层层的叠加，同时可以将不同目录挂载到同一个虚拟文件系统下(unite several directories into a single virtual filesystem)。Union文件系统是Docker镜像的基础。镜像可以通过分层来进行继承，基于基础镜像（没有父镜像），可以制作各种具体的应用镜像。</p><h3 id="docker镜像加载原理"><a href="#docker镜像加载原理" class="headerlink" title="docker镜像加载原理"></a>docker镜像加载原理</h3><p>docker的镜像实际上由一层一层的文件系统组成，这种层级的文件系统UnionFS。<br>bootfs(boot file system)主要包含bootioader和kernel, bootoader主要是引导加载kernel, Linux刚启动时会加载bootfs文件系统，在Docker镜像的最底层是引导文件系统bootfs。这一层与我们典型的LinuxUnix系统是一样的，包含boot加载器和内核。当boot加载完成之后整个内核就都在内存中了，此时内存的使用权已由bootfs转交给内核，此时系统也会卸载bootfs。rootfs (root fle system)，在bootfs之上。包含的就是典型Linux系统中的&#x2F;dev, &#x2F;proc, &#x2F;bin, letc等标准目录和文件。rootfs就是各种不同的操作系统发行版，比如Ubuntu，Centos等等。</p><h3 id="镜像的实现原理"><a href="#镜像的实现原理" class="headerlink" title="镜像的实现原理"></a>镜像的实现原理</h3><p>Docker镜像是由一系列镜像层（layer）组成的，每一层代表了镜像构建过程中的一次提交。</p><p><img src="https://cdn.jsdelivr.net/gh/dutsc/cloud-image/blog-img/202312051651706.png"></p><p><img src="https://cdn.jsdelivr.net/gh/dutsc/cloud-image/blog-img/202312051651456.png"></p><p><img src="https://cdn.jsdelivr.net/gh/dutsc/cloud-image/blog-img/202312051651203.png"></p><p><img src="https://cdn.jsdelivr.net/gh/dutsc/cloud-image/blog-img/202312051651890.png"></p><ul><li><p>Dockerfile的每一行命令都生成了一个镜像层，每一层的diff文件夹下只存放了增量数据。分层的结构使得docker镜像非常轻量，每一层根据镜像的内容都有一个唯一的ID。</p></li><li><p>&#x3D;&#x3D;当不同的镜像之间有相同的镜像层时，便可以实现不同的镜像层之间共享镜像层的效果&#x3D;&#x3D;</p></li></ul><p>总结：</p><ul><li><p>Docker镜像是静态的分层管理的文件组合，镜像底层的实现依赖于联合文件系统UnionFS。</p></li><li><p>镜像是由一系列的镜像层(layer）组成，每一层代表了镜像构建过程中的一次提交，当需要修改镜像内的某个文件时，只需要在当前镜像层的基础上新建一个镜像层,并且只存放修改过的文件内容。</p></li></ul><h3 id="构建镜像"><a href="#构建镜像" class="headerlink" title="构建镜像"></a>构建镜像</h3><h4 id="docker-commit"><a href="#docker-commit" class="headerlink" title="docker commit"></a>docker commit</h4><blockquote><p>从运行中的容器提交为镜像</p></blockquote><p><code>docker commit</code>: 提交容器副本使之成为一个新的镜像</p><p><code>docker commit -m=: “提交的描述信息”  -a=&quot;作者&quot; 容器ID 要创建的目标镜像名:[标签名]</code> </p><p><code>touch test.txt &amp;&amp; echo &quot;I love Docker&quot;&gt;test.txt</code></p><h4 id="docker-build"><a href="#docker-build" class="headerlink" title="docker build"></a>docker build</h4><blockquote><p>从Dockerfile构建镜像</p></blockquote><h3 id="docker-save"><a href="#docker-save" class="headerlink" title="docker save"></a>docker save</h3><p><code>docker save -o hosttorch.tar 7e420a6c07e4</code> </p><p>将某个镜像打包成tar包，并使用xfpt传输到其他服务器使用。</p><h3 id="docker-load"><a href="#docker-load" class="headerlink" title="docker load"></a>docker load</h3><h3 id="docker-port"><a href="#docker-port" class="headerlink" title="docker port"></a>docker port</h3><p>使用<code>docker port 容器号/容器名</code> 来查看容器端口的绑定情况</p><h3 id="docker-pull"><a href="#docker-pull" class="headerlink" title="docker pull"></a>docker pull</h3><p>使用该命令往dockerhub上传镜像时，必须保证镜像的名称和dockerhub中创建的仓库名称相同，否则无法上传,出现 <code>denied: requested access to the resource is denied</code> 错误</p><p>若不相同，采用docker tag命令更改镜像名称</p><h3 id="docker-tag"><a href="#docker-tag" class="headerlink" title="docker tag"></a>docker tag</h3><p><code>docker tag 老名称 新名称</code></p><p>新名称要加上用户名dutsc&#x2F;</p><p>重命名之后，只是改了一个名称而已，新镜像的image iD与原来的镜像是一样的。</p><h3 id="终止GPU中运行的程序"><a href="#终止GPU中运行的程序" class="headerlink" title="终止GPU中运行的程序"></a>终止GPU中运行的程序</h3><ol><li>使用nvidia-smi查看运行的进程号</li><li>使用kill -9 PID  就可以杀死进程了</li></ol><h3 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h3><blockquote><p>构建docker镜像的一个配置文件，说明了docker镜像应该如何构建</p><p>Dockerfile包含了用户所有的构建命令</p></blockquote><p>使用时，必须在文件夹下创建一个文件，名称叫&#x3D;&#x3D;Dockerfile&#x3D;&#x3D; ，而且只能叫这个名字，不能叫别的名字。</p><h4 id="Dockerfile的优点"><a href="#Dockerfile的优点" class="headerlink" title="Dockerfile的优点"></a>Dockerfile的优点</h4><ul><li>易与版本化管理，纯文本文件</li><li>过程可追溯</li><li>屏蔽构建环境异构</li></ul><h4 id="Dockerfile的特点"><a href="#Dockerfile的特点" class="headerlink" title="Dockerfile的特点"></a>Dockerfile的特点</h4><ol><li>Dockerfile的每一行命令都会生成一个独立的镜像层，并且拥有唯一的ID</li><li>Dockerfile的命令是完全透明的，通过查看Dockerfile的内容，可以知道镜像是如何一步步构建的。</li><li>Dockerfile是纯文本的，方便跟随代码一起放在代码仓库并作版本管理。</li></ol><h4 id="Docker常用指令"><a href="#Docker常用指令" class="headerlink" title="Docker常用指令"></a>Docker常用指令</h4><p><img src="https://cdn.jsdelivr.net/gh/dutsc/cloud-image/blog-img/202312051651236.png"></p><p>一个Dockerfile的实例</p><p><img src="https://cdn.jsdelivr.net/gh/dutsc/cloud-image/blog-img/202312051652004.png"></p><p>构建镜像的命令 <code>docker  build </code></p><p>下面介绍最常用的五个指令</p><h4 id="from"><a href="#from" class="headerlink" title="from"></a>from</h4><blockquote><p>指定当前镜像是基于哪个镜像</p></blockquote><h4 id="workdir"><a href="#workdir" class="headerlink" title="workdir"></a>workdir</h4><blockquote><p>指定进入之后的工作目录</p></blockquote><h4 id="copy"><a href="#copy" class="headerlink" title="copy"></a>copy</h4><blockquote><p>把当前服务器上的某个文件或者目录复制到容器中</p></blockquote><h4 id="run"><a href="#run" class="headerlink" title="run"></a>run</h4><blockquote><p>在起来的容器中运行命令</p></blockquote><h4 id="cmd"><a href="#cmd" class="headerlink" title="cmd"></a>cmd</h4><blockquote><p>可以写&#x2F;bin&#x2F;bash</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/dutsc/cloud-image/blog-img/202312051652183.png"></p><h4 id="expose"><a href="#expose" class="headerlink" title="expose"></a>expose</h4><blockquote><p>暴露的端口是什么</p></blockquote><h4 id="volume"><a href="#volume" class="headerlink" title="volume"></a>volume</h4><blockquote><p>指定被映射的文件夹</p></blockquote><p>在docker run的时候可以指定服务器中映射的文件夹</p><p><img src="https://cdn.jsdelivr.net/gh/dutsc/cloud-image/blog-img/202312051652011.png"></p><h4 id="env"><a href="#env" class="headerlink" title="env"></a>env</h4><p>直接指定当前容器的环境变量</p><p>也可以在docker run中通过-e指定环境变量</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">env</span> A=<span class="hljs-number">10</span><br><span class="hljs-keyword">env</span> A <span class="hljs-number">10</span><br></code></pre></td></tr></table></figure><p>注意与arg的区别：env是建立系统的环境变量，从构建（build）到运行都有效；但是arg只在构建时有效，运行时无效。</p><h4 id="arg"><a href="#arg" class="headerlink" title="arg"></a>arg</h4><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">arg</span> B <span class="hljs-number">10</span> <span class="hljs-comment"># 这里其实是B的默认值是10</span><br></code></pre></td></tr></table></figure><p>可以在run容器时使用<code>--build-arg B=11</code> 来修改B的值，</p><h4 id="label"><a href="#label" class="headerlink" title="label"></a>label</h4><blockquote><p>用来指定元数据信息</p></blockquote><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">label</span><span class="language-bash"> k=<span class="hljs-string">&quot;v&quot;</span> k1=<span class="hljs-string">&quot;v1&quot;</span></span><br></code></pre></td></tr></table></figure><p>只是作为镜像的一个标识，并没有实质性的作用，在使用<code>docker inspect 镜像名</code> 时标识镜像，没有实质性的作用。</p><h4 id="onbuild"><a href="#onbuild" class="headerlink" title="onbuild"></a>onbuild</h4><blockquote><p>onbuild是指当前镜像构建的时候不会执行，基于当前镜像的镜像构建的时候才会执行。</p></blockquote><p><code>onbuild</code>后面加的参数可以是dockerfile中的其他任意参数</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">onbuild</span> <span class="hljs-keyword">env</span> C=<span class="hljs-number">100</span><br></code></pre></td></tr></table></figure><h4 id="stopsignal"><a href="#stopsignal" class="headerlink" title="stopsignal"></a>stopsignal</h4><blockquote><p>当前构建的容器用什么样的信号能够使其停止。一般不常用</p></blockquote><h4 id="healthcheck"><a href="#healthcheck" class="headerlink" title="healthcheck"></a>healthcheck</h4><blockquote><p>用来检查容器健康状态的一些配置，很少用到，不讲</p></blockquote><h4 id="shell"><a href="#shell" class="headerlink" title="shell"></a>shell</h4><blockquote><p>指定当前构建的镜像使用什么shell，一般linux默认&#x2F;bin&#x2F;sh win使用cmd</p></blockquote><h4 id="Dockerfile书写原则"><a href="#Dockerfile书写原则" class="headerlink" title="Dockerfile书写原则"></a>Dockerfile书写原则</h4><ol><li><p>单一职责：由于容器的本质是进程，一个容器代表一个进程，因此不同的功能应用应该尽量拆分成不同的容器，每个容器只负责单一业务进程。</p></li><li><p>提供注释信息</p></li><li><p>保持容器最小化：应该避免安装无用的软件包</p></li><li><p>合理选择基础镜像：容器的核心是应用，只要基础镜像能够满足应用的环境即可。例如：一个java类型的应用，运行时只需要JRE，并不需要JDK，因此容器只安装JRE即可。</p></li><li><p>使用.dockerignore文件忽略一些不需要构建的文件</p><p><img src="https://cdn.jsdelivr.net/gh/dutsc/cloud-image/blog-img/202312051652552.png"></p></li><li><p>尽量使用构建缓存</p><p><img src="https://cdn.jsdelivr.net/gh/dutsc/cloud-image/blog-img/202312051652528.png"></p><p>因此，基于docker构建时的缓存特性，我们可以把不轻易改变的指令放在Dockerfile前面，而可能经常改变的指令放在Dockerfile末尾，</p></li><li><p>正确设置时区。</p><p><img src="https://cdn.jsdelivr.net/gh/dutsc/cloud-image/blog-img/202312051652861.png"></p></li><li><p>使用国内软件园加快镜像构建速度</p></li><li><p>最小化镜像层数</p><p><img src="https://cdn.jsdelivr.net/gh/dutsc/cloud-image/blog-img/202312051652592.png"></p></li></ol><h4 id="Dockerfile指令书写建议"><a href="#Dockerfile指令书写建议" class="headerlink" title="Dockerfile指令书写建议"></a>Dockerfile指令书写建议</h4><ul><li><p>RUN：RUN指令在执行时将会生成一个新的镜像层并且执行RUN指令后面的内容</p><ul><li><p>当RUN指令后面跟的内容比较复杂时，建议使用反斜杠\结尾并换行</p></li><li><p>RUN指令后面的内容尽量按照字母顺序排序，提高可读性</p><p>一个示例</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">FROM</span> centos:<span class="hljs-number">7</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> yum install -y automake \</span><br><span class="language-bash">curl \</span><br><span class="language-bash">python \</span><br><span class="language-bash">vim</span><br></code></pre></td></tr></table></figure></li></ul></li><li><p>CMD\ENTRYPOINT</p><ul><li><p>相同点</p><ul><li><p>两者后面都跟JSON参数 </p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">CMD</span><span class="language-bash">/ENTRYPOINT [<span class="hljs-string">&quot;command&quot;</span>,<span class="hljs-string">&quot;param&quot;</span>]</span><br></code></pre></td></tr></table></figure></li><li><p>跟shell指令  shell模式</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">CMD</span><span class="language-bash">/ENTRYPOINT <span class="hljs-built_in">command</span> param</span><br></code></pre></td></tr></table></figure></li></ul></li><li><p>不同点</p><ul><li>Dockerfile中如果使用了ENTRYPOINT指令，启动Docker容器时需要使用–entrypoint 参数才能覆盖Dockerfile中的ENTRYPOINT指令，而使用CMD设置的命令则可以被docker run后面的参数直接覆盖</li><li>ENTRYPOINT指令可以结合CMD指令使用，也可以单独使用，而CMD指令只能单独使用</li></ul></li><li><p>什么时候使用CMD，什么时候使用ENTRYPOINT呢？</p><p>希望镜像足够灵活，推荐使用CMD指令；如果镜像只执行单一的程序，并且不希望用户在执行docker run时覆盖默认程序，建议使用ENTRYPOINT</p></li><li><p>无论使用CMD还是ENTRYPOINT，都尽量使用exec</p></li></ul></li><li><p>ADD\COPY，功能类似，都是从外部往容器内添加文件</p><ul><li><p>COPY指令只支持基本的文件和文件夹拷贝功能</p></li><li><p>ADD支持更多文件来源类型，比如自动提取tar包，并且支持源文件为URL格式。</p></li><li><p>日常使用中，应该使用哪个指令添加文件呢？</p><p>推荐使用COPY指令，因为它更加透明，更容易使用缓存，有效减少容器体积</p><p>希望使用ADD指令添加URL文件时，应避免使用</p><p><img src="https://cdn.jsdelivr.net/gh/dutsc/cloud-image/blog-img/202312051652423.png"></p><p>下面是推荐写法</p><p><img src="https://cdn.jsdelivr.net/gh/dutsc/cloud-image/blog-img/202312051652042.png"></p></li></ul></li><li><p>推荐使用WORKDIR指定容器的工作路径，因为这样能够使容器的工作过程更加清晰明了。应该尽量避免使用<code>RUN cd /work/path &amp;&amp; do some work</code> 这样的指令</p></li></ul><p>问题：当需要编写编译型语言（Go，Java）的Dockerfile时，如何分离编译环境和运行环境使得镜像体积尽可能小呢？</p><h2 id="Docker安全"><a href="#Docker安全" class="headerlink" title="Docker安全"></a>Docker安全</h2><blockquote><p>基于内核的弱隔离系统如何保障安全性？</p></blockquote><p>Docker是基于Linux内核的Namespace技术实现资源隔离的，所有的容器都共享宿主机的内核。容器比虚拟机的安全性弱多了。</p><p>下图展示容器与虚拟机的区别：</p><p><img src="https://cdn.jsdelivr.net/gh/dutsc/cloud-image/blog-img/202312051652292.png"></p><ul><li>虚拟机：通过管理系统模拟出CPU，内存，网络等硬件，然后在这些模拟的硬件上创建客户内核和操作系统。好处：虚拟机有自己的内核和操作系统，并且硬件都是通过虚拟机管理系统模拟出来的，用户程序无法直接使用到主机的操作系统和硬件资源。</li><li>容器：通过Linux的namespace技术实现了进程，设备，网络以及文件系统的隔离，然后再通过cgroup对CPU，内存等资源进行限制，最终实现了容器之间相互不受影响。因为容器的隔离性仅仅依靠内核提供，因此，容器的隔离性也远弱于虚拟机。</li></ul><h3 id="Docker存在的安全问题"><a href="#Docker存在的安全问题" class="headerlink" title="Docker存在的安全问题"></a>Docker存在的安全问题</h3><p><a href="https://docs.docker.com/engine/security/non-events/">https://docs.docker.com/engine/security/non-events/</a></p><p>Docker是一种容器引擎，也会存在一些容器漏洞；比如权限提升，信息泄露等等。</p><h3 id="镜像安全"><a href="#镜像安全" class="headerlink" title="镜像安全"></a>镜像安全</h3><ul><li>镜像软件存在漏洞</li><li>仓库漏洞</li><li>用户程序漏洞</li></ul><p>尽管目前Namespace已经提供了非常多的资源隔离类型，但是仍有部分关键内容没有被完全隔离，其中包括一些系统的关键性目录（如&#x2F;sys,&#x2F;proc等）</p><p>由于同一宿主机上的所有容器共享主机内核，攻击者可以使用一些手段导致内核崩溃，进而导致主机宕机，影响主机上的其他服务。</p><h4 id="保障镜像安全"><a href="#保障镜像安全" class="headerlink" title="保障镜像安全"></a>保障镜像安全</h4><ul><li>在私有仓库中  安装镜像安全扫描组件，对上传的镜像进行检查</li><li>拉去镜像是从受信任的仓库中拉取，并且与镜像仓库通信一定要使用htps协议</li></ul><h3 id="UserNamespace"><a href="#UserNamespace" class="headerlink" title="UserNamespace"></a>UserNamespace</h3><p>主要是用来容器内用户和主机的用户隔离的</p><p>Docker1.10版本开始，使用UserNamespace做用户隔离，实现了容器中的root用户映射到主机上的非root用户</p><h3 id="加强内核安全和管理"><a href="#加强内核安全和管理" class="headerlink" title="加强内核安全和管理"></a>加强内核安全和管理</h3><ul><li><p>宿主机及时升级内核漏洞</p></li><li><p>使用Capabilities划分权限</p><ul><li>在虚拟机内可以赋予用户所有的权限，例如设置cron定时任务，操作内核模块，配置网络等权限</li><li>容器需要针对每一项Capabilities更细粒度控制权限</li><li>大多数情况下，容器不需要主机的root权限，Docker默认情况下也不开启额外特权</li><li>在执行docker run命令启动容器时，如非特殊可控情况，–privileged参数不允许设置为true</li><li>其他特殊权限可以使用–cap-add参数，根据使用场景适当添加相应的权限</li></ul></li><li><p>使用安全加固组件</p><blockquote><p>以下三种组件可以控制容器内部对系统内核的访问</p></blockquote><ul><li>SELinux：是Linux的一个内核安全模块，提供了安全访问的策略机制，通过设置SELinux策略可以实现某些进程允许访问某些文件。</li><li>AppArmor：是Linux的内核安全模块，AppArmor可以控制到用户程序的访问权限</li><li>GRSecurity：是一个对内核的安全扩展,可通过智能访问控制，提供内存破坏防御，文件系统增强等多种防御形式。</li></ul></li><li><p>资源限制</p><blockquote><p>docker run命令时资源限制的参数</p></blockquote><ul><li><code>--cpu</code>：限制cpu配额</li><li><code>-m</code> ：限制内存配额</li><li><code>--pids-limit</code>：限制容器PID个数</li></ul><p>启动一个1核2G的容器，并且限制在容器内最多只能创建1000个PID</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker run --cpu 1 -m 2048m --pids-limit=1000 busybox sh<br></code></pre></td></tr></table></figure><p>这样即便容器的程序有漏洞，也不会导致主机的资源被耗尽，最大限度降低安全风险</p></li><li><p>使用安全容器</p><blockquote><p>兼顾轻便  与 安全</p></blockquote><p>安全容器中的每个容器都运行在一个单独的微型虚拟机中，拥有独立的操作系统和内核，并且有虚拟化层的安全隔离</p><p>Kata Container只有一个精简版的Guest Kernel运行着容器本身的应用，并且通过减少不必要的内存，尽量共享可以共享的内存来进一步减少内存的开销。</p><p>Kata Container实现了OCI规范，可以直接使用Docker的镜像启动Kata容器具有开销更小、秒级启动、安全隔离等许多优点。</p></li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><img src="https://cdn.jsdelivr.net/gh/dutsc/cloud-image/blog-img/202312051652568.png"></p><p>&#x3D;&#x3D;问题&#x3D;&#x3D;</p><p>除了Kata container之外，是否还知道其他的安全容器解决方案？</p><h2 id="容器监控"><a href="#容器监控" class="headerlink" title="容器监控"></a>容器监控</h2><p>容器监控的解决方案</p><ul><li>docker stats命令   缺点：只能获取本机数据，无法获取历史化监控数据，没有可视化展示面板</li><li>开源解决方案：sysdig，cAdvisor，Prometheus等</li></ul><h3 id="cAdvisor"><a href="#cAdvisor" class="headerlink" title="cAdvisor"></a>cAdvisor</h3><p>采集机器上所有运行的容器信息，提供基础的查询界面和HTTP接口</p><h3 id="启动cAdvisor"><a href="#启动cAdvisor" class="headerlink" title="启动cAdvisor"></a>启动cAdvisor</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker run \<br>--volume=/:/rootfs:ro \<br>--volume=/var/run:/var/run:ro \ --volume=/sys:/sys:ro \<br>--volume=/var/lib/docker/:/var/lib/docker:ro \--volume=/dev/disk/:/dev/disk:ro \<br>--publish=10299:8080 \<br>--detach=<span class="hljs-literal">true</span> \<br>--name=cadvisor \--privileged \<br>--device=/dev/kmsg \<br>google/cadvisor:latest<br></code></pre></td></tr></table></figure><h3 id="监控原理"><a href="#监控原理" class="headerlink" title="监控原理"></a>监控原理</h3><ul><li><p>Docker是基于Namespace，Cgroups和联合文件系统实现的。</p></li><li><p>Cgroups不仅可以用于容器资源的的限制，还可以提供容器的资源使用率</p></li><li><p>Cgroups的工作目录&#x2F;sys&#x2F;fs&#x2F;cgroup 下包含了Cgroups的所有内容  &#x3D;&#x3D;容器监控的数据来自cgroups&#x3D;&#x3D;</p></li></ul><p>&#x3D;&#x3D;容器的监控原理其实就是定时读取Linux主机上的相关文件并展示给用户&#x3D;&#x3D;</p><h4 id="监控memory"><a href="#监控memory" class="headerlink" title="监控memory"></a>监控memory</h4><ol><li><code>/sys/fs/cgroup/memory/docker/容器ID</code>目录下存在某个容器的内存监控文件</li><li>比如  <code>memory.limit_in_bytes </code>文件 存放了该容器限制的内存大小 单位bytes</li></ol><h4 id="监控网络"><a href="#监控网络" class="headerlink" title="监控网络"></a>监控网络</h4><p>查看容器的PID  使用<code>docker inspect</code>命令        容器的PID为容器在主机上运行的进程ID</p><p><code>docker inspect busybox |grep Pid</code></p><ol><li><code>/proc/容器PID/net/dev</code> 文件记录了容器内每一个网卡的流量接收和发送情况，以及错误数，丢包数等信息。可见容器的监控数据都是定时从这里读取并展示的。</li></ol><p>&#x3D;&#x3D;在大规模容器集群当中，cAdvisor有什么明显的不足吗&#x3D;&#x3D;</p><h2 id="Namespace"><a href="#Namespace" class="headerlink" title="Namespace"></a>Namespace</h2><p>Namespace 是 Linux内核的一项功能，该功能对内核资源进行分区，以使一组进程看到一组资源，而另一组进程看到另一组资源。Namespace的工作方式通过为一组资源和进程设置相同的Namespace而起作用，但是这些Namespace 引用了不同的资源。资源可能存在于多个Namespace中。这些资源可以是进程ID、主机名、用户ID、文件名、与网络访问相关的名称和进程间通信。</p><p>八种namespace</p><table><thead><tr><th>Namespace 名称</th><th>作用</th><th>Linux内核版本</th></tr></thead><tbody><tr><td>Mount(mnt)</td><td><strong>隔离挂载点</strong>：隔离不同的进程或进程组看到的挂载点。实现容器内只能看到自己的挂载信息，在容器内的挂载操作不会影响主机的挂载目录</td><td>2.4.19</td></tr><tr><td>Process ID(pid)</td><td>隔离进程ID</td><td>2.6.24</td></tr><tr><td>Network(net)</td><td>隔离网络设备，端口号等</td><td>2.6.29</td></tr><tr><td>Interprocess Communication(ipc)</td><td><strong>隔离System V IPC和POSIX message queues：</strong>PID Namespace和IPC Namespace一起使用可以实现同一IPC Namespace内的进程彼此可以通信，不同IPC Namespace的进程却不能通信</td><td>2.6.19</td></tr><tr><td>UTS Namespace(uts)</td><td><strong>隔离主机名和域名：</strong> 允许每个UTS namespace拥有一个独立的主机名</td><td>2.6.19</td></tr><tr><td>User Namespace(user)</td><td>隔离用户和用户组</td><td>3.8</td></tr><tr><td>Control group(cgroup) Namespace</td><td>隔离Cgroups根目录</td><td>4.6</td></tr><tr><td>Time Namespace</td><td>隔离系统时间</td><td>5.6</td></tr></tbody></table><p>docker只实现了前六种，后两种没实现</p><h3 id="unshare"><a href="#unshare" class="headerlink" title="unshare"></a>unshare</h3><p><code>unshare</code>: 是util-linux工具包中的一个工具，可以实现创建并访问不同类型的Namespace</p><p><code>ls -l /proc/self/ns</code> 查看当前进程的Namespace信息</p><h4 id="unshare的选项"><a href="#unshare的选项" class="headerlink" title="unshare的选项"></a>unshare的选项</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs bash">(1)-i, --ipc<br><br> unshare the IPC namespace.<br><br>(2)-m, --mount<br><br> Unshare the mount namespace.<br><br>(3)-n, --net<br><br> Unshare the network namespace.<br><br>(4) -p, --pid<br><br>Unshare the pid namespace.  See also the --fork and --mount-proc options.<br><br>(5)-u, --uts<br><br> Unshare the UTS namespace.<br><br>(6) -U, --user<br><br>Unshare the user namespace.<br><br>(7)-f, --fork<br><br>Fork the specified program as a child process of unshare rather than running it directly.  This is useful when creating a new pid namespace.<br><br>(8)--mount-proc[=mountpoint]<br><br>Just  before running the program, mount the proc filesystem at mountpoint (default is /proc).  This is useful when creating a new pid namespace.  It also implies creating a new mount names‐pace since the /proc mount would otherwise mess up existing programs on the system.  The new proc filesystem is explicitly mounted as private (by MS_PRIVATE|MS_REC).<br><br>(9)-r, --map-root-user<br><br>Run the program only after the current effective user and group IDs have been mapped to the superuser UID and GID <span class="hljs-keyword">in</span> the newly created user namespace.  This  makes  it  possible  to  conve‐niently  gain  capabilities  needed  to  manage various aspects of the newly created namespaces (such as configuring interfaces <span class="hljs-keyword">in</span> the network namespace or mounting filesystems <span class="hljs-keyword">in</span> the mount namespace) even when run unprivileged. As a mere convenience feature, it does not support more sophisticated use cases, such as mapping multiple ranges  of  UIDs  and  GIDs.  This  option  implies --setgroups=deny.<br><br>(10) --propagation private|shared|slave|unchanged<br><br>Recursively  sets mount propagation flag <span class="hljs-keyword">in</span> the new mount namespace. The default is to <span class="hljs-built_in">set</span> the propagation to private, this feature is possible to <span class="hljs-built_in">disable</span> by unchanged argument. The options        is silently ignored when mount namespace (--mount) is not requested.<br><br>(11)--setgroups allow|deny<br><br>Allow or deny setgroups(2) syscall <span class="hljs-keyword">in</span> user namespaces.<br><br>setgroups(2) is only callable with CAP_SETGID and CAP_SETGID <span class="hljs-keyword">in</span> a user namespace (since Linux 3.19) does not give you permission to call setgroups(2) <span class="hljs-keyword">until</span> after GID map has been  <span class="hljs-built_in">set</span>.  The GID map is writable by root when setgroups(2) is enabled and GID map becomes writable by unprivileged processes when setgroups(2) is permanently disabled.<br><br>(12) -V, --version<br><br>Display version information and <span class="hljs-built_in">exit</span>.<br><br>(13)-h, --<span class="hljs-built_in">help</span><br><br>Display <span class="hljs-built_in">help</span> text and <span class="hljs-built_in">exit</span>.<br></code></pre></td></tr></table></figure><h3 id="mount-namespace"><a href="#mount-namespace" class="headerlink" title="mount namespace"></a>mount namespace</h3><p>创建一个bash进程并新建一个mount namespace</p><p><code>sudo unshare --mount --fork /bin/bash</code></p><p>使用unshare命令可以新建Mount Namespace，并且在新建的Mount Namespace内mount是和外部完全隔离的。</p><p>它可以用来隔离不同的进程或进程组看到的挂载点。通俗地说，就是可以实现在不同的进程中看到不同的挂载目录。</p><p>执行完上述<code>unshare</code>命令后，这时我们已经在主机上创建了一个新的 Mount Namespace，并且当前命令行窗口加入了新创建的 Mount Namespace。下面我通过一个例子来验证下，在独立的 Mount Namespace 内创建挂载目录是不影响主机的挂载目录的。</p><p>首先在 &#x2F;tmp 目录下创建一个目录。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">[root@centos7 centos]<span class="hljs-comment"># mkdir /tmp/tmpfs</span><br></code></pre></td></tr></table></figure><p>创建好目录后使用 mount 命令挂载一个 tmpfs 类型的目录。命令如下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">[root@centos7 centos]<span class="hljs-comment"># mount -t tmpfs -o size=20m tmpfs /tmp/tmpfs</span><br></code></pre></td></tr></table></figure><p>然后使用 df 命令查看一下已经挂载的目录信息：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">[root@centos7 centos]<span class="hljs-comment"># df -h</span><br></code></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sh">Filesystem   Size Used Avail Use% Mounted on<br>/dev/vda1    500G 1.4G 499G  1% /<br>devtmpfs     16G   0  16G  0% /dev<br>tmpfs      16G   0  16G  0% /dev/shm<br>tmpfs      16G   0  16G  0% /sys/fs/cgroup<br>tmpfs      16G  57M  16G  1% /run<br>tmpfs      3.2G   0 3.2G  0% /run/user/1000<br>tmpfs      20M   0  20M  0% /tmp/tmpfs<br></code></pre></td></tr></table></figure><p>可以看到 <code>/tmp/tmpfs</code> 目录已经被正确挂载。为了验证主机上并没有挂载此目录，我们新打开一个命令行窗口，同样执行 df 命令查看主机的挂载信息：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sh">[centos@centos7 ~]$ <span class="hljs-built_in">df</span> -h<br>Filesystem   Size Used Avail Use% Mounted on<br>devtmpfs     16G   0  16G  0% /dev<br>tmpfs      16G   0  16G  0% /dev/shm<br>tmpfs      16G  57M  16G  1% /run<br>tmpfs      16G   0  16G  0% /sys/fs/cgroup<br>/dev/vda1    500G 1.4G 499G  1% /<br>tmpfs      3.2G   0 3.2G  0% /run/user/1000<br></code></pre></td></tr></table></figure><p>通过上面输出可以看到主机上并没有挂载<code> /tmp/tmpfs</code>，可见我们独立的 Mount Namespace 中执行 mount 操作并不会影响主机。</p><p>为了进一步验证我们的想法，我们继续在当前命令行窗口查看一下当前进程的 Namespace 信息，命令如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">[root@centos7 centos]<span class="hljs-comment"># ls -l /proc/self/ns/</span><br>total 0<br>lrwxrwxrwx. 1 root root 0 Sep 4 08:20 ipc -&gt; ipc:[4026531839]<br>lrwxrwxrwx. 1 root root 0 Sep 4 08:20 mnt -&gt; mnt:[4026532239]<br>lrwxrwxrwx. 1 root root 0 Sep 4 08:20 net -&gt; net:[4026531956]<br>lrwxrwxrwx. 1 root root 0 Sep 4 08:20 pid -&gt; pid:[4026531836]<br>lrwxrwxrwx. 1 root root 0 Sep 4 08:20 user -&gt; user:[4026531837]<br>lrwxrwxrwx. 1 root root 0 Sep 4 08:20 uts -&gt; uts:[4026531838]<br></code></pre></td></tr></table></figure><p>然后新打开一个命令行窗口，使用相同的命令查看一下主机上的 Namespace 信息：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sh">[centos@centos7 ~]$ <span class="hljs-built_in">ls</span> -l /proc/self/ns/<br>total 0<br>lrwxrwxrwx. 1 centos centos 0 Sep 4 08:20 ipc -&gt; ipc:[4026531839]<br>lrwxrwxrwx. 1 centos centos 0 Sep 4 08:20 mnt -&gt; mnt:[4026531840]<br>lrwxrwxrwx. 1 centos centos 0 Sep 4 08:20 net -&gt; net:[4026531956]<br>lrwxrwxrwx. 1 centos centos 0 Sep 4 08:20 pid -&gt; pid:[4026531836]<br>lrwxrwxrwx. 1 centos centos 0 Sep 4 08:20 user -&gt; user:[4026531837]<br>lrwxrwxrwx. 1 centos centos 0 Sep 4 08:20 uts -&gt; uts:[4026531838]<br></code></pre></td></tr></table></figure><p>通过对比两次命令的输出结果，我们可以看到，除了 Mount Namespace 的 ID 值不一样外，其他Namespace 的 ID 值均一致。</p><p>通过以上结果我们可以得出结论，使用 unshare 命令可以新建 Mount Namespace，并且在新建的 Mount Namespace 内 mount 是和外部完全隔离的。</p><h3 id="PID-namespace"><a href="#PID-namespace" class="headerlink" title="PID namespace"></a>PID namespace</h3><p>通过PID namespace实现隔离进程，在不同的PID namespace内，进程可以拥有相同的PID号。</p><p>创建一个bash进程，并新建一个PID namespace</p><p><code>sudo unshare --pid --fork --mount-proc /bin/bash</code></p><p><code>ps aux</code>  查看当前进程的所有信息</p><p><img src="https://cdn.jsdelivr.net/gh/dutsc/cloud-image/blog-img/202312051652365.png"></p><p>通过上述命令输出结果可以看到当前 Namespace 下 bash 为 1 号进程，而且我们也看不到主机上的其他进程信息。</p><h3 id="UTS-namespace"><a href="#UTS-namespace" class="headerlink" title="UTS namespace"></a>UTS namespace</h3><p><code>hostname</code>  查看主机名</p><p><img src="https://cdn.jsdelivr.net/gh/dutsc/cloud-image/blog-img/202312051652194.png"></p><p><code>hostname -b</code> 临时修改主机名</p><h4 id="容器场景中的UTS-namespace"><a href="#容器场景中的UTS-namespace" class="headerlink" title="容器场景中的UTS namespace"></a>容器场景中的UTS namespace</h4><p>容器场景下，由于实现了uts_namespace，获取当前utsname时，都是获取当前上下文进程的所在的uts命名空间中的utsname来实现的，如下：</p><p><img src="https://cdn.jsdelivr.net/gh/dutsc/cloud-image/blog-img/202312051652489.png" alt="https://gitee.com/dutsc/cloud-images/raw/master/images/202212052202485.png"></p><p>每一个进程都有一个属于自己的uts命名空间。多个进程可共享这个命名空间 。</p><p>创建容器时，通过CLONE_UTSNS来指定一个新的命名空间。待容器中的init进程创建子进程时，<strong>子进程复制其父进程的uts命名空间</strong>。这样做到了再一个容器中的所有进程共享一个uts命名空间，从而其相应的utsname信息也是共享一份的。</p><h3 id="IPC-namespace"><a href="#IPC-namespace" class="headerlink" title="IPC namespace"></a>IPC namespace</h3><blockquote><p>在单独的IPC namespace中创建的系统通信队列，在主机中无法看到</p></blockquote><p><code>sudo unshare --ipc --fork /bin/bash</code></p><p><code>ipcs -q</code> 查看系统间通信队列列表</p><p><code>ipcmk -Q</code> 创建系统间通信队列</p><h3 id="User-namespace"><a href="#User-namespace" class="headerlink" title="User namespace"></a>User namespace</h3><blockquote><p>使用User Namespace可以实现进程在容器内拥有root权限，而在主机上却只是普通用户</p></blockquote><p>User Namespace 主要是用来隔离用户和用户组的。一个比较典型的应用场景就是在主机上以非 root 用户运行的进程可以在一个单独的 User Namespace 中映射成 root 用户。使用 User Namespace 可以实现进程在容器内拥有 root 权限，而在主机上却只是普通用户。</p><p>User Namesapce 的创建是可以不使用 root 权限的。下面我们以普通用户的身份创建一个 User Namespace，命令如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ unshare -user -r bash<br></code></pre></td></tr></table></figure><p>创建一个user namespace</p><p>CentOS7 默认允许创建的 User Namespace 为 0，如果执行上述命令失败（ unshare 命令返回的错误为 unshare: unshare failed: Invalid argument ），需要使用以下命令修改系统允许创建的 User Namespace 数量，命令为：echo 65535 &gt; &#x2F;proc&#x2F;sys&#x2F;user&#x2F;max_user_namespaces，然后再次尝试创建 User Namespace。</p><p><code>id</code>  查看当前的用户信息</p><p>在隔离的user namespace中，并不能获得主机的root权限</p><h3 id="Net-namespace"><a href="#Net-namespace" class="headerlink" title="Net namespace"></a>Net namespace</h3><p>Net Namespace 可以让每个进程拥有自己独立的IP地址，端口和网卡信息例如主机IP地址为172.16.4.1，容器内可以设置独立的IP地址为192.168.1.1。</p><p>同样用实例验证，我们首先使用 ip a 命令查看一下主机上的网络信息：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ ip a<br><br>1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000<br>  <span class="hljs-built_in">link</span>/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00<br>  inet 127.0.0.1/8 scope host lo<br>  valid_lft forever preferred_lft forever<br>  inet6 ::1/128 scope host<br>  valid_lft forever preferred_lft forever<br><br>2: eth0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP group default qlen 1000<br>  <span class="hljs-built_in">link</span>/ether 02:11:b0:14:01:0c brd ff:ff:ff:ff:ff:ff<br>  inet 172.20.1.11/24 brd 172.20.1.255 scope global dynamic eth0<br>  valid_lft 86063337sec preferred_lft 86063337sec<br>  inet6 fe80::11:b0ff:fe14:10c/64 scope <span class="hljs-built_in">link</span><br>  valid_lft forever preferred_lft forever<br><br>3: docker0: &lt;NO-CARRIER,BROADCAST,MULTICAST,UP&gt; mtu 1500 qdisc noqueue state DOWN group default<br>  <span class="hljs-built_in">link</span>/ether 02:42:82:8d:a0:<span class="hljs-built_in">df</span> brd ff:ff:ff:ff:ff:ff<br>  inet 172.17.0.1/16 scope global docker0<br>  valid_lft forever preferred_lft forever<br>  inet6 fe80::42:82ff:fe8d:a0df/64 scope <span class="hljs-built_in">link</span><br>  valid_lft forever preferred_lft forever<br></code></pre></td></tr></table></figure><p>然后我们使用以下命令创建一个 Net Namespace：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">unshare --net --fork /bin/bash<br></code></pre></td></tr></table></figure><p>同样的我们使用 ip a 命令查看一下网络信息：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">[root@centos7 centos]<span class="hljs-comment"># ip a</span><br>1: lo: &lt;LOOPBACK&gt; mtu 65536 qdisc noop state DOWN group default qlen 1000<br><span class="hljs-built_in">link</span>/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00<br></code></pre></td></tr></table></figure><p>可以看到，宿主机上有 lo、eth0、docker0 等网络设备，而我们新建的 Net Namespace 内则与主机上的网络设备不同。</p><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><ul><li><p>Linux内核从2002年2.4.19版本开始加入了Mount Namespace内核3.8版本加入了User Namespace为容器提供了足够的支持功能。</p></li><li><p>当Docker新建一个容器时，会创建这六种Namespace，然后将容器中的进程加入这些Namespace之中</p></li></ul><p><strong>没有namespace 就没有docker容器</strong></p><p>Namespace是 Linux内核的一个特性，可以实现在同一主机系统中对进程ID、主机名、用户ID、文件名、网络和进程间通信等资源的隔离</p><h2 id="Cgroups"><a href="#Cgroups" class="headerlink" title="Cgroups"></a>Cgroups</h2><blockquote><p>cgroups机制实现资源限制</p></blockquote><p>虽然有了namespace，使得不同容器之间看不到相互的资源，但是容器内的进程依然可以使用主机的CPU 内存等资源 。如何限制一个容器资源的使用？？？使用Cgroups</p><p>cgroups(全称: control groups)，是Linux内核的一个功能，可以实现限制进程或者进程组的资源(如CPU、内存、磁盘IO等)。</p><h3 id="核心功能"><a href="#核心功能" class="headerlink" title="核心功能"></a>核心功能</h3><ul><li>资源限制：限制资源使用量</li><li>优先级控制：不同的组可以有不同的资源使用优先级</li><li>审计：计算控制组的资源使用情况</li><li>控制：控制进程的挂起或恢复</li></ul><h3 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h3><ul><li><p><strong>子系统  subsystem</strong>：是一个内核的组件，一个子系统代表一类资源调度控制器</p><ul><li>内存子系统可以限制内存的使用量</li><li>cpu子系统可以限制cpu的使用时间</li></ul><p><strong>是真正实现某类资源限制的基础</strong></p></li><li><p>控制组  cgroups ：表示一组进程和一组带有参数的子系统的关联关系</p><ul><li>一个进程使用cpu子系统来限制cpu的使用时间，则这个进程和cpu子系统的关联关系成为控制组</li></ul></li><li><p>层级树  hierarchy ：是由一系列控制组按照树状结构排列组成的，子控制组默认拥有父控制组的属性。</p><ul><li>比如系统中定义了控制组c1，限制cpu可以使用1核；另外一个控制组c2，想实现限制cpu使用1核，同时实现内存使用2G，那么c2就可以直接继承c1，无需重复定义CPU资源限制。</li></ul></li></ul><p><code>sudo mount -t cgroups</code>  查看挂载的cgroups子系统信息</p><p>以cpu子系统为例，查看限制cpu使用的情况</p><h3 id="查看meory内存使用情况"><a href="#查看meory内存使用情况" class="headerlink" title="查看meory内存使用情况"></a>查看meory内存使用情况</h3><ol><li><p>在memory子系统下创建cgroup测试文件夹</p><p><code>/sys/fs/cgroup/memory/mydocker</code> 里面会自动创建一些内存限制使用文件</p></li><li><p>对内存限制使用为1G</p><p><code>echo 1073741824&gt;memory.limit_in_bytes</code></p></li><li><p>创建进程 加入Cgroup</p><p><code>echo $$&gt;tasks</code> 把当前shell进程ID写入tasks文件内</p></li><li><p>执行内存测试工具 memtester 1500M 1</p><p>当tasks中的进程内存使用超过1G时，会被cgroups杀死</p></li></ol><h3 id="docker是如何使用cgroups的"><a href="#docker是如何使用cgroups的" class="headerlink" title="docker是如何使用cgroups的"></a>docker是如何使用cgroups的</h3><p>docker创建容器时，docker会根据启动容器的参数，在对应的cgroups子系统下，创建以容器ID为名称的目录，然后根据容器启动时设置的资源限制参数，修改对应的cgroups子系统资源限制文件，从而达到资源限制的效果。</p><p>&#x3D;&#x3D;注意&#x3D;&#x3D;</p><p>cgroups虽然能实现资源的限制，但不保证资源的使用</p><h3 id="sys-fs-cgroup目录下各文件夹含义"><a href="#sys-fs-cgroup目录下各文件夹含义" class="headerlink" title="/sys/fs/cgroup目录下各文件夹含义"></a><code>/sys/fs/cgroup</code>目录下各文件夹含义</h3><ul><li>blkio对块设备的 IO 进行限制</li><li>cpu限制 CPU 时间片的分配，与 cpuacct 挂载在同一目录</li><li>cpuacct生成 cgroup 中的任务占用 CPU 资源的报告，与 cpu 挂载在同一目录</li><li>cpuset给 cgroup 中的任务分配独立的 CPU(多处理器系统) 和内存节点</li><li>devices允许或禁止 cgroup 中的任务访问设备</li><li>freezer暂停&#x2F;恢复 cgroup 中的任务</li><li>hugetlb限制使用的内存页数量</li><li>memory对 cgroup 中的任务的可用内存进行限制，并自动生成资源占用报告</li><li>net_cls使用等级识别符（classid）标记网络数据包，这让 Linux 流量控制器（tc 指令）可以识别来自特定 </li><li>cgroup 任务的数据包，并进行网络限制</li><li>net_prio允许基于 cgroup 设置网络流量(netowork traffic)的优先级</li><li>perf_event允许使用 perf 工具来监控 cgroup</li><li>pids限制任务的数量</li><li>rdma限制进程对rdma和ib资源的使用。rdma作为host-offload、host-bypass技术，使低延迟、高带宽的直接内存到内存的数据通信成为可能。ib为新一代网络协议</li><li>systemdsystemd 提供了 cgroups 的使用和管理接口，在系统的开机阶段，systemd 会把支持的 controllers (subsystem 子系统)挂载到默认的 &#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F; 目录下面</li></ul><h2 id="docker组件剖析"><a href="#docker组件剖析" class="headerlink" title="docker组件剖析"></a>docker组件剖析</h2><p><img src="https://cdn.jsdelivr.net/gh/dutsc/cloud-image/blog-img/202312051652448.png"></p><p>客户端与服务端默认通信方式：Unix套接字</p><ul><li>docker相关的组件<ul><li>docker：二进制文件，负责发送docker操作请求</li><li>dockerd：docker服务端的后台常驻进程，用来接收客户端发送的请求</li><li>docker-init：docker run时采用–init参数启动，回收docker内的进程，在业务进程没有进程回收功能时十分有用 </li><li>docker-proxy：做端口映射，底层依赖于iptables实现</li></ul></li><li>containerd相关的组件<ul><li>containerd：负责管理容器的生命周期</li><li>containerd-shim：containerd-shim的意思是垫片，主要作用是将containerd和真正的容器进程解耦。使用containerd-shim 作为容器进程的父进程，从而实现重启containerd不影响已经启动的容器进程。</li><li>ctr：ctr实际上是containerd-ctr，是containerd的客户端，主要用来开发和调试在没有dockerd的环境中，ctr可以直接向containerd守护进程发送操作容器的请求。</li></ul></li><li>容器运行时组件runc</li></ul><p>总结：</p><table><thead><tr><th>组件分类</th><th>组件名称</th><th>作用剖析</th></tr></thead><tbody><tr><td>docker相关组件</td><td>docker</td><td>Docker的客户端,负责发送Docker操作请求</td></tr><tr><td>docker相关组件</td><td>dockerd</td><td>Docker服务端入口，负责接收客户端请求并返回请求结果</td></tr><tr><td>docker相关组件</td><td>docker-init</td><td>当业务主进程没有进程回收能力时，docker-int可以作为容器的1号进程,负责管理容器内子进程</td></tr><tr><td>docker相关组件</td><td>docker-proxy</td><td>用来做Docker的网络实现，通过设置iptables规则使得访问到主机的流量可以被顺利转发到容器中</td></tr><tr><td>containerd相关组件</td><td>containerd</td><td>负责管理容器的生命周期，通过接收dockerd的请求，执行启动或者销毁容器操作</td></tr><tr><td>containerd相关组件</td><td>containerd-shim</td><td>将containerd和真正的容器进程解耦，使用containerd-shim 作为容器进程的父进程，可以实现重启containerd不影响已经启动的容器进程</td></tr><tr><td>containerd相关组件</td><td>ctr</td><td>containerd的客户端，可以直接向containerd发送容器操作请求，主要用来开发和调试</td></tr><tr><td>容器运行时组件</td><td>runc</td><td>通过调用Namespace、cgroups等系统接口，实现容器的创建和销毁</td></tr></tbody></table><h2 id="docker网络"><a href="#docker网络" class="headerlink" title="docker网络"></a>docker网络</h2><p>CNM（container network model） 是docker发布的容器网络标准，只要满足CNM接口的网络方案都可以接入到docker容器网络</p><h3 id="CNM"><a href="#CNM" class="headerlink" title="CNM"></a>CNM</h3><ul><li>沙箱</li><li>接入点</li><li>网络</li></ul><h3 id="Libnetwork"><a href="#Libnetwork" class="headerlink" title="Libnetwork"></a>Libnetwork</h3><p>是CNM的官方实现，是启动容器时为docker容器提供网络接入功能的插件</p><p><code>route -n</code>  查看路由信息</p><h4 id="Libnetwork工作流程"><a href="#Libnetwork工作流程" class="headerlink" title="Libnetwork工作流程"></a>Libnetwork工作流程</h4><ol><li>Docker通过调用libnetwork.New函数来创建NetworkController实例</li><li>通过调用NewNetwork函数创建指定名称和类型的Network</li><li>通过调用CreateEndpoint来创建接入点（Endpoint）</li><li>调用NewSandbos来创建容器沙箱，主要是初始化Namespace相关的资源</li><li>调用Endpoint的join函数将沙箱和网络接入点关联起来</li></ol><h4 id="LIbnetwork常见的网络模式"><a href="#LIbnetwork常见的网络模式" class="headerlink" title="LIbnetwork常见的网络模式"></a>LIbnetwork常见的网络模式</h4><table><thead><tr><th>Libnetwork常见的网络模式</th><th>作用</th><th>业务场景</th></tr></thead><tbody><tr><td>null空网络模式</td><td>不提供任何容器网络</td><td>处理一些保密数据,出于安全考虑,需要一个隔离的网络环境执行一些纯计算任务</td></tr><tr><td>bridge桥接模式</td><td>使得容器和容器之间网络可以互通</td><td>容器需要实现网络通信或者提供网络服务</td></tr><tr><td>host主机网络模式</td><td>让容器内的程序可以使用到主机的网络</td><td>容器需要控制主机网络或者用主机网络提供服务</td></tr><tr><td>container网络模式</td><td>将两个容器放到同一网络空间中，可以直接通过localhost本地访问</td><td>两个容器之间需要直接通过localhost通信,一般用于网络接管或代理场景</td></tr></tbody></table><h2 id="数据存储：卷（volume）"><a href="#数据存储：卷（volume）" class="headerlink" title="数据存储：卷（volume）"></a>数据存储：卷（volume）</h2><p>前面我已经介绍过，容器技术使用了 rootfs 机制和 Mount Namespace，构建出了一个同宿主机完全隔离开的文件系统环境。这时候，我们就需要考虑这样两个问题：</p><p>容器里进程新建的文件，怎么才能让宿主机获取到？<br>宿主机上的文件和目录，怎么才能让容器里的进程访问到？<br>这正是 Docker Volume 要解决的问题：Volume 机制，允许你将宿主机上指定的目录或者文件，挂载到容器里面进行读取和修改操作。</p><p>在 Docker 项目里，它支持两种 Volume 声明方式，可以把宿主机目录挂载进容器的 &#x2F;test 目录当中：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker run -v /test ...   $ docker run -v /home:/test ...<br></code></pre></td></tr></table></figure><p>而这两种声明方式的本质，实际上是相同的：都是把一个宿主机的目录挂载进了容器的 &#x2F;test 目录。<br>只不过，在第一种情况下，由于你并没有显示声明宿主机目录，那么 Docker 就会默认在宿主机上创建一个临时目录 &#x2F;var&#x2F;lib&#x2F;docker&#x2F;volumes&#x2F;[VOLUME_ID]&#x2F;_data，然后把它挂载到容器的 &#x2F;test 目录上。而在第二种情况下，Docker 就直接把宿主机的 &#x2F;home 目录挂载到容器的 &#x2F;test 目录上。</p><h3 id="绑定挂载"><a href="#绑定挂载" class="headerlink" title="绑定挂载"></a>绑定挂载</h3><p>那么，Docker 又是如何做到把一个宿主机上的目录或者文件，挂载到容器里面去呢？难道又是 Mount Namespace 的黑科技吗？</p><p>实际上，并不需要这么麻烦。</p><p>当容器进程被创建之后，尽管开启了 Mount Namespace，但是在它执行 chroot(或者 pivot_root)之前，容器进程一直可以看到宿主机上的整个文件系统。</p><p>而宿主机上的文件系统，也自然包括了我们要使用的容器镜像。这个镜像的各个层，保存在 <code>/var/lib/docker/aufs/diff</code> 目录下，在容器进程启动后，它们会被联合挂载在<code> /var/lib/docker/aufs/mnt/</code> 目录中，这样容器所需的 rootfs 就准备好了。</p><p>所以，我们只需要在 rootfs 准备好之后，在执行 chroot 之前，把 Volume 指定的宿主机目录(比如<code>/home</code>目录)，挂载到指定的容器目录(比如 &#x2F;test 目录)在宿主机上对应的目录(即 <code>/var/lib/docker/aufs/mnt/[可读写层 ID]/test</code>)上，这个 Volume 的挂载工作就完成了。</p><p>更重要的是，由于执行这个挂载操作时，“容器进程”已经创建了，也就意味着此时 Mount Namespace 已经开启了。所以，这个挂载事件只在这个容器里可见。你在宿主机上，是看不见容器内部的这个挂载点的。这就保证了容器的隔离性不会被 Volume 打破。</p><blockquote><p>注意：这里提到的 “ 容器进程 “，是 Docker 创建的一个容器初始化进程 (dockerinit)，而不是应用进程 (ENTRYPOINT + CMD)。dockerinit 会负责完成根目录的准备、挂载设备和目录、配置 hostname 等一系列需要在容器内进行的初始化操作。最后，它通过 <code>execv()</code> 系统调用，让应用进程取代自己，成为容器里的 PID&#x3D;1 的进程。</p></blockquote><p>而这里要使用到的挂载技术，就是 Linux 的绑定挂载(bind mount)机制。它的主要作用就是，允许你将一个目录或者文件，而不是整个设备，挂载到一个指定的目录上。并且，这时你在该挂载点上进行的任何操作，只是发生在被挂载的目录或者文件上，而原挂载点的内容则会被隐藏起来且不受影响。<br>其实，如果你了解 Linux 内核的话，就会明白，绑定挂载实际上是一个 inode 替换的过程。在 Linux 操作系统中，inode 可以理解为存放文件内容的“对象”，而 dentry，也叫目录项，就是访问这个 inode 所使用的“指针”。</p><p><img src="https://cdn.jsdelivr.net/gh/dutsc/cloud-image/blog-img/202312051654497.png"></p><p>正如上图所示，<code>mount --bind /home /test</code>，会将 &#x2F;home 挂载到 &#x2F;test 上。其实相当于将<code>/test</code>的 dentry，重定向到了 <code>/home</code> 的 inode。这样当我们修改 &#x2F;test 目录时，实际修改的是<code>/home</code>目录的 inode。这也就是为何，一旦执行 umount 命令，<code>/test</code> 目录原先的内容就会恢复：因为修改真正发生在的，是 <code>/home</code> 目录里。</p><p>所以，在一个正确的时机，进行一次绑定挂载，Docker 就可以成功地将一个宿主机上的目录或文件，不动声色地挂载到容器中。</p><p>这样，进程在容器里对这个<code>/test</code>目录进行的所有操作<strong>，都实际发生在宿主机的对应目录</strong>(比如，<code>/home</code>，或者 <code>/var/lib/docker/volumes/[VOLUME_ID]/_data</code>)里，<strong>而不会影响容器镜像的内容</strong>。</p><p>那么，这个<code> /test</code> 目录里的内容，既然挂载在容器 rootfs 的可读写层，它会不会被 docker commit 提交掉呢？</p><p>也不会。</p><p>这个原因其实我们前面已经提到过。容器的镜像操作，比如 docker commit，都是发生在宿主机空间的。而由于 Mount Namespace 的隔离作用，宿主机并不知道这个绑定挂载的存在。所以，在宿主机看来，容器中可读写层的 <code>/test </code>目录(<code>/var/lib/docker/aufs/mnt/[可读写层 ID]/test</code>)，始终是空的。</p><p>不过，由于 Docker 一开始还是要创建 <code>/test </code>这个目录作为挂载点，所以执行了 docker commit 之后，你会发现新产生的镜像里，会多出来一个空的 <code>/test</code> 目录。毕竟，新建目录操作，又不是挂载操作，Mount Namespace 对它可起不到“障眼法”的作用。</p><h3 id="验证绑定挂载"><a href="#验证绑定挂载" class="headerlink" title="验证绑定挂载"></a>验证绑定挂载</h3><p>结合以上的讲解，我们现在来亲自验证一下：</p><p>首先，启动一个 helloworld 容器，给它声明一个 Volume，挂载在容器里的 <code>/test </code>目录上：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker run -d -v /test helloworld <br>cf53b766fa6f<br></code></pre></td></tr></table></figure><p>容器启动之后，我们来查看一下这个 Volume 的 ID：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker volume <span class="hljs-built_in">ls</span><br>DRIVER              VOLUME NAME    <br><span class="hljs-built_in">local</span>               cb1c2f7221fa9b0971cc35f68aa1034824755ac44a034c0c0a1dd318838d3a6d<br></code></pre></td></tr></table></figure><p>然后，使用这个 ID，可以找到它在 Docker 工作目录下的 volumes 路径：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">ls</span> /var/lib/docker/volumes/cb1c2f7221fa/_data/<br></code></pre></td></tr></table></figure><p>这个 _data 文件夹，就是这个容器的 Volume 在宿主机上对应的临时目录了。</p><p>接下来，我们在容器的 Volume 里，添加一个文件 text.txt：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker <span class="hljs-built_in">exec</span> -it cf53b766fa6f /bin/shcd <span class="hljs-built_in">test</span>/touch text.txt<br></code></pre></td></tr></table></figure><p>这时，我们再回到宿主机，就会发现 text.txt 已经出现在了宿主机上对应的临时目录里：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">ls</span> /var/lib/docker/volumes/cb1c2f7221fa/_data/text.txt<br></code></pre></td></tr></table></figure><p>可是，如果你在宿主机上查看该容器的可读写层，虽然可以看到这个 &#x2F;test 目录，但其内容是空的(关于如何找到这个 AuFS 文件系统的路径，请参考我上一次分享的内容)：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">ls</span> /var/lib/docker/aufs/mnt/6780d0778b8a/test<br></code></pre></td></tr></table></figure><p>可以确认，容器 Volume 里的信息，并不会被 docker commit 提交掉；但这个挂载点目录 &#x2F;test 本身，则会出现在新的镜像当中。</p><p>以上内容，就是 Docker Volume 的核心原理了。</p><h3 id="使用volume"><a href="#使用volume" class="headerlink" title="使用volume"></a>使用volume</h3><p>使用<code>docker volume ls</code> 查看已经存在的volumes</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker volume <span class="hljs-built_in">ls</span><br></code></pre></td></tr></table></figure><p>创建一个新的volume</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker volume create myvolume <br></code></pre></td></tr></table></figure><p>默认创建在<code>/var/lib/docker/volume/</code>目录下</p><p>创建容器时使用该目录进行挂载</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker run -it --mount <span class="hljs-built_in">source</span>=myvolume,target=/mydata busybox sh<br></code></pre></td></tr></table></figure><p>这样就将新建的容器busybox中的<code>/mydata</code> 目录挂载到了目录<code>/var/lib/docker/volume/myvolume/_data</code>下，在<code>mydata</code>中的操作其实都是在<code>_data</code>中的操作。可以验证，在容器中的<code>/mydata</code>目录下创建一个<code>test.txt</code>文件，在主机中的<code>_data</code> 目录下也会出现test.txt文件。</p><p>即时将<code>busybox</code> 容器删除，<code>_data</code> 目录下的文件也不会消失，再创建一个同样的容器，也挂载该目录，在新创建的容器中依然可以观察到test.txt文件。</p><p>采用卷（volume），可以很好地实现容器之间的业务共享，比如一个nginx服务容器的日志，需要另外一个单独的日志解析程序来处理，这就需要共享日志文件的存储目录。这也是一个很典型的应用场景。</p><p><code>--volume-from + [已经启动的容器名]</code> 参数，可以实现启动run  新的容器时，挂载已经存在的容器的卷。</p><h2 id="文件存储：AUFS"><a href="#文件存储：AUFS" class="headerlink" title="文件存储：AUFS"></a>文件存储：AUFS</h2><blockquote><p>ubuntu  Debain</p><p>写时复制：在容器中，只有需要修改某个文件时，才会把文件从镜像层复制到容器层。而不会去修改镜像层的文件内容。</p></blockquote><p>我们知道，Docker 主要是基于 Namespace、cgroups 和联合文件系统这三大核心技术实现的。前面的课时我详细讲解了 Namespace 和 cgroups 的相关原理，那么你知道联合文件系统是什么吗？它的原理又是什么呢？<br>首先我们来了解一下什么是联合文件系统。</p><p>什么是联合文件系统</p><p>联合文件系统(Union File System，Unionfs)是一种分层的轻量级文件系统，它可以把多个目录内容联合挂载到同一目录下，从而形成一个单一的文件系统，这种特性可以让使用者像是使用一个目录一样使用联合文件系统。<br>那联合文件系统对于 Docker 是一个怎样的存在呢？它可以说是 Docker 镜像和容器的基础，因为它可以使 Docker 可以把镜像做成分层的结构，从而使得镜像的每一层可以被共享。例如两个业务镜像都是基于 CentOS 7 镜像构建的，那么这两个业务镜像在物理机上只需要存储一次 CentOS 7 这个基础镜像即可，从而节省大量存储空间。</p><p>说到这儿，你有没有发现，联合文件系统只是一个概念，真正实现联合文件系统才是关键，那如何实现呢？其实实现方案有很多，Docker 中最常用的联合文件系统有三种：AUFS、Devicemapper 和 OverlayFS。</p><p>今天我主要讲解 Docker 中最常用的联合文件系统里的 AUFS，为什么呢？因为 AUFS 是 Docker 最早使用的文件系统驱动，多用于 Ubuntu 和 Debian 系统中。在 Docker 早期，OverlayFS 和 Devicemapper 相对不够成熟，AUFS 是最早也是最稳定的文件系统驱动。 Devicemapper 和 OverlayFS 联合文件系统。</p><p>接下来，我们就看看如何配置 Docker 的 AUFS 模式.</p><h3 id="如何配置-Docker-的-AUFS-模式"><a href="#如何配置-Docker-的-AUFS-模式" class="headerlink" title="如何配置 Docker 的 AUFS 模式"></a>如何配置 Docker 的 AUFS 模式</h3><p>AUFS 目前并未被合并到 Linux 内核主线，因此只有 Ubuntu 和 Debian 等少数操作系统支持 AUFS。你可以使用以下命令查看你的系统是否支持 AUFS：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ grep aufs /proc/filesystemsnodev <br>aufs<br></code></pre></td></tr></table></figure><p>执行以上命令后，如果输出结果包含aufs，则代表当前操作系统支持 AUFS。AUFS 推荐在 Ubuntu 或 Debian 操作系统下使用，如果你想要在 CentOS 等操作系统下使用 AUFS，需要单独安装 AUFS 模块(生产环境不推荐在 CentOS 下使用 AUFS，如果你想在 CentOS 下安装 AUFS 用于研究和测试，可以参考这个链接)，安装完成后使用上述命令输出结果中有aufs即可。</p><p>当确认完操作系统支持 AUFS 后，你就可以配置 Docker 的启动参数了。</p><p>先在 <code>/etc/docker </code>下新建 <code>daemon.json </code>文件，并写入以下内容：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">&#123;  <span class="hljs-string">&quot;storage-driver&quot;</span>: <span class="hljs-string">&quot;aufs&quot;</span>&#125;<br></code></pre></td></tr></table></figure><p>然后使用以下命令重启 Docker：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ sudo systemctl restart docker<br></code></pre></td></tr></table></figure><p>Docker 重启以后使用<code>docker info</code>命令即可查看配置是否生效：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ sudo docker info<br>Client: Debug Mode: falseServer: Containers: 0  Running: 0  Paused: 0  Stopped: 0 Images: 1 Server Version: 19.03.12 Storage Driver: aufs  Root Dir: /var/lib/docker/aufs  Backing Filesystem: extfs  Dirs: 1  Dirperm1 Supported: <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p>可以看到 Storage Driver 已经变为 aufs，证明配置已经生效，配置生效后就可以使用 AUFS 为 Docker 提供联合文件系统了。<br>配置好 Docker 的 AUFS 联合文件系统后，你一定很好奇 AUFS 到底是如何工作的呢？下面我带你详细学习一下 AUFS 的工作原理。</p><h3 id="AUFS-工作原理"><a href="#AUFS-工作原理" class="headerlink" title="AUFS 工作原理"></a>AUFS 工作原理</h3><p>AUFS 是如何存储文件的？</p><p>AUFS 是联合文件系统，意味着它在主机上使用多层目录存储，每一个目录在 AUFS 中都叫作分支，而在 Docker 中则称之为层(layer)，但最终呈现给用户的则是一个普通单层的文件系统，我们把多层以单一层的方式呈现出来的过程叫作联合挂载。</p><p><img src="https://cdn.jsdelivr.net/gh/dutsc/cloud-image/blog-img/202312051654532.png"></p><p>如上图，每一个镜像层和容器层都是<code>/var/lib/docker</code>下的一个子目录，镜像层和容器层都在 <code>aufs/diff </code>目录下，每一层的目录名称是镜像或容器的 ID 值，联合挂载点在<code>aufs/mnt</code>目录下，<strong>mnt 目录是真正的容器工作目录。</strong></p><p>下面我们针对 aufs 文件夹下的各目录结构，在创建容器前后的变化做详细讲述。<br>当一个镜像未生成容器时，AUFS 的存储结构如下。</p><ul><li>diff 文件夹：存储镜像内容，每一层都存储在以镜像层 ID 命名的子文件夹中。</li><li>layers 文件夹：存储镜像层关系的元数据，在 diff 文件夹下的每个镜像层在这里都会有一个文件，文件的内容为该层镜像的父级镜像的 ID。</li><li>mnt 文件夹：联合挂载点目录，未生成容器时，该目录为空。</li></ul><p>当一个镜像已经生成容器时，AUFS 存储结构会发生如下变化。</p><ul><li><p>diff 文件夹：当容器运行时，会在 diff 目录下生成容器层。</p></li><li><p>layers 文件夹：增加容器层相关的元数据。</p></li><li><p>mnt 文件夹：容器的联合挂载点，这和容器中看到的文件内容一致。</p></li></ul><p>以上便是 AUFS 的工作原理，那你知道容器的在工作过程中是如何使用 AUFS 的吗？</p><h3 id="AUFS-对文件的操作"><a href="#AUFS-对文件的操作" class="headerlink" title="AUFS 对文件的操作"></a>AUFS 对文件的操作</h3><p>AUFS 的工作过程中对文件的操作分为<strong>读取文件</strong>和<strong>修改文件</strong>。下面我们分别来看下 AUFS 对于不同的文件操作是如何工作的。</p><ol><li>读取文件<br>当我们在容器中读取文件时，可能会有以下场景。</li></ol><ul><li><p>文件在容器层中存在时：当文件存在于容器层时，直接从容器层读取。</p></li><li><p>当文件在容器层中不存在时：当容器运行时需要读取某个文件，如果容器层中不存在时，则从镜像层查找该文件，然后读取文件内容。</p></li><li><p>文件既存在于镜像层，又存在于容器层：当我们读取的文件既存在于镜像层，又存在于容器层时，将会从容器层读取该文件。</p></li></ul><ol start="2"><li>修改文件或目录</li></ol><p>  AUFS 对文件的修改采用的是<strong>写时复制</strong>的工作机制，这种工作机制可以最大程度节省存储空间。具体的文件操作机制如下。</p><ul><li><p>第一次修改文件：当我们第一次在容器中修改某个文件时，<strong>AUFS 会触发写时复制操作，AUFS 首先从镜像层复制文件到容器层，然后再执行对应的修改操作。</strong></p><blockquote><p>AUFS 写时复制的操作将会复制整个文件，如果文件过大，将会大大降低文件系统的性能，因此当我们有大量文件需要被修改时，AUFS 可能会出现明显的延迟。好在，写时复制操作只在第一次修改文件时触发，对日常使用没有太大影响。</p></blockquote></li><li><p>删除文件或目录：当文件或目录被删除时，AUFS 并不会真正从镜像中删除它，因为镜像层是只读的，AUFS 会创建一个特殊的文件或文件夹，这种特殊的文件或文件夹会阻止容器的访问。</p></li></ul><h3 id="AUFS-演示"><a href="#AUFS-演示" class="headerlink" title="AUFS 演示"></a>AUFS 演示</h3><h4 id="准备演示目录和文件"><a href="#准备演示目录和文件" class="headerlink" title="准备演示目录和文件"></a>准备演示目录和文件</h4><p>首先我们在 &#x2F;tmp 目录下创建 aufs 目录：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">cd</span> /tmp<br>$ <span class="hljs-built_in">mkdir</span> aufs<br></code></pre></td></tr></table></figure><p>准备挂载点目录：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">/tmp$ <span class="hljs-built_in">cd</span> aufs<br>/tmp/aufs$ <span class="hljs-built_in">mkdir</span> mnt<br></code></pre></td></tr></table></figure><p>接下来准备容器层内容：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">## 创建镜像层目录</span><br>/tmp/aufs$ <span class="hljs-built_in">mkdir</span> container1<br><span class="hljs-comment">## 在镜像层目录下准备一个文件</span><br>/tmp/aufs$ <span class="hljs-built_in">echo</span> Hello, Container layer! &gt; container1/container1.txt<br></code></pre></td></tr></table></figure><p>最后准备镜像层内容：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">## 创建两个镜像层目录</span><br>/tmp/aufs$ <span class="hljs-built_in">mkdir</span> image1 &amp;&amp; <span class="hljs-built_in">mkdir</span> image2<br><span class="hljs-comment">## 分别写入数据</span><br>/tmp/aufs$ <span class="hljs-built_in">echo</span> Hello, Image layer1! &gt; image1/image1.txt<br>/tmp/aufs$ <span class="hljs-built_in">echo</span> Hello, Image layer2! &gt; image2/image2.txt<br></code></pre></td></tr></table></figure><p>准备好的目录和文件结构如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash">/tmp/aufs$ tree.<br>.<br>|-- container1<br>|  `-- container1.txt<br>|-- image1<br>|  `-- image1.txt<br>|-- image2<br>|  `-- image2.txt<br>`-- mnt<br>4 directories, 3 files<br></code></pre></td></tr></table></figure><h4 id="创建-AUFS-联合文件系统"><a href="#创建-AUFS-联合文件系统" class="headerlink" title="创建 AUFS 联合文件系统"></a>创建 AUFS 联合文件系统</h4><p>使用 mount 命令可以创建 AUFS 类型的文件系统，命令如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">/tmp/aufs$ sudo mount -t aufs -o <br><span class="hljs-built_in">dirs</span>=./container1:./image2:./image1  none ./mnt<br></code></pre></td></tr></table></figure><p>mount 命令创建 AUFS 类型文件系统时，这里要注意，dirs 参数第一个冒号默认为读写权限，后面的目录均为只读权限，与 Docker 容器使用 AUFS 的模式一致。</p><p>执行完上述命令后，mnt 变成了 AUFS 的联合挂载目录，我们可以使用 mount 命令查看一下已经创建的 AUFS 文件系统：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">/tmp/aufs$ mount -t aufs<br>none on /tmp/aufs/mnt <span class="hljs-built_in">type</span> aufs (rw,relatime,si=4174b83d649ffb7c)<br></code></pre></td></tr></table></figure><p>我们每创建一个 AUFS 文件系统，AUFS 都会为我们生成一个 ID，这个 ID 在<code>/sys/fs/aufs/</code>会创建对应的目录，在这个 ID 的目录下可以查看文件挂载的权限。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">tmp/aufs$ <span class="hljs-built_in">cat</span> /sys/fs/aufs/si_4174b83d649ffb7c/*<br>/tmp/aufs/container1=rw<br>/tmp/aufs/image2=ro<br>/tmp/aufs/image1=ro<br>64<br>65<br>66<br></code></pre></td></tr></table></figure><p>可以看到 container1 目录的权限为 rw(代表可读写)，image1 和 image2 的权限为 ro(代表只读)。<br>为了验证 mnt 目录下可以看到 container1、image1 和 image2 目录下的所有内容，我们使用 ls 命令查看一下 mnt 目录：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">/tmp/aufs$ <span class="hljs-built_in">ls</span> -l mnt/<br>total 12<br>-rw-rw-r-- 1 ubuntu ubuntu 24 Sep  9 16:55 container1.txt<br>-rw-rw-r-- 1 ubuntu ubuntu 21 Sep  9 16:59 image1.txt<br>-rw-rw-r-- 1 ubuntu ubuntu 21 Sep  9 16:59 image2.txt<br></code></pre></td></tr></table></figure><p>可以看到 mnt 目录下已经出现了我们准备的所有镜像层和容器层的文件。下面让我们来验证一下 AUFS 的写时复制。</p><h4 id="验证-AUFS-的写时复制"><a href="#验证-AUFS-的写时复制" class="headerlink" title="验证 AUFS 的写时复制"></a>验证 AUFS 的写时复制</h4><p>AUFS 的写时复制是指在容器中，只有需要修改某个文件时，才会把文件从镜像层复制到容器层，下面我们通过修改联合挂载目录 mnt 下的内容来验证下这个过程。</p><p>我们使用以下命令修改 mnt 目录下的 image1.txt 文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">/tmp/aufs$ <span class="hljs-built_in">echo</span> Hello, Image layer1 changed! &gt; mnt/image1.txt<br></code></pre></td></tr></table></figure><p>然后我们查看下<code> image1/image1.txt</code> 文件内容：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">/tmp/aufs$ <span class="hljs-built_in">cat</span> image1/image1.txt<br>Hello, Image layer1!<br></code></pre></td></tr></table></figure><p>发现“镜像层”的 image1.txt 文件并未被修改。</p><p>然后我们查看一下”容器层”对应的 image1.txt 文件内容：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">/tmp/aufs$ <span class="hljs-built_in">ls</span> -l container1/<br>total 8<br>-rw-rw-r-- 1 ubuntu ubuntu 24 Sep  9 16:55 container1.txt<br>-rw-rw-r-- 1 ubuntu ubuntu 29 Sep  9 17:21 image1.txt<br><span class="hljs-comment">## 查看文件内容</span><br>/tmp/aufs$ <span class="hljs-built_in">cat</span> container1/image1.txt<br>Hello, Image layer1 changed!<br></code></pre></td></tr></table></figure><p>发现 AUFS 在“容器层”自动创建了 image1.txt 文件，并且内容为我们刚才写入的内容。至此，我们完成了 AUFS 写时复制的验证。<strong>我们在第一次修改镜像内某个文件时，AUFS 会复制这个文件到容器层，然后在容器层对该文件进行修改操作，这就是 AUFS 最典型的特性写时复制。</strong></p><p><strong>AUFS为什么一直没有进入Linux内核主线？</strong>    可读性太差。。</p><h2 id="文件存储驱动：Devicemapper"><a href="#文件存储驱动：Devicemapper" class="headerlink" title="文件存储驱动：Devicemapper"></a>文件存储驱动：Devicemapper</h2><blockquote><p>CentOS</p></blockquote><p>前面学习了什么是联合文件系统，以及 AUFS 的工作原理和配置。我们知道 AUFS 并不在 Linux 内核主干中，所以如果你的操作系统是 CentOS，就不推荐使用 AUFS 作为 Docker 的联合文件系统了。</p><p>那在 CentOS 系统中，我们怎么实现镜像和容器的分层结构呢？我们通常使用 Devicemapper 作为 Docker 的联合文件系统。</p><h3 id="什么是-Devicemapper"><a href="#什么是-Devicemapper" class="headerlink" title="什么是 Devicemapper"></a>什么是 Devicemapper</h3><ul><li><p>Devicemapper 是 Linux 内核提供的框架，从 Linux 内核 2.6.9 版本开始引入，Devicemapper 与 AUFS 不同，<strong>AUFS 是一种文件系统，而Devicemapper 是一种映射块设备的技术框架</strong>。</p></li><li><p><strong>Devicemapper 提供了一种将物理块设备映射到虚拟块设备的机制</strong>，目前 Linux 下比较流行的 LVM (Logical Volume Manager 是 Linux 下对磁盘分区进行管理的一种机制)和软件磁盘阵列(将多个较小的磁盘整合成为一个较大的磁盘设备用于扩大磁盘存储和提供数据可用性)都是基于 Devicemapper 机制实现的。</p></li></ul><p>那么 Devicemapper 究竟是如何实现的呢？下面我们首先来了解一下它的关键技术。</p><h3 id="Devicemapper-的关键技术"><a href="#Devicemapper-的关键技术" class="headerlink" title="Devicemapper 的关键技术"></a>Devicemapper 的关键技术</h3><p>Devicemapper 将主要的工作部分分为<strong>用户空间</strong>和<strong>内核空间</strong>。</p><ul><li>用户空间负责配置具体的设备映射策略与相关的内核空间控制逻辑，例如逻辑设备 dma 如何与物理设备 sda 相关联，怎么建立逻辑设备和物理设备的映射关系等。</li><li>内核空间则负责用户空间配置的关联关系实现，例如当 IO 请求到达虚拟设备 dm a 时，内核空间负责接管 IO 请求，然后处理和过滤这些 IO 请求并转发到具体的物理设备 sda 上。</li></ul><p>这个架构类似于 C&#x2F;S (客户端&#x2F;服务区)架构的工作模式，客户端负责具体的规则定义和配置下发，服务端根据客户端配置的规则来执行具体的处理任务。</p><h3 id="Devicemapper-的工作机制主要围绕三个核心概念"><a href="#Devicemapper-的工作机制主要围绕三个核心概念" class="headerlink" title="Devicemapper 的工作机制主要围绕三个核心概念"></a>Devicemapper 的工作机制主要围绕三个核心概念</h3><ul><li>映射设备(mapped device)：即对外提供的逻辑设备，它是由 Devicemapper 模拟的一个虚拟设备，并不是真正存在于宿主机上的物理设备。</li><li>目标设备(target device)：目标设备是映射设备对应的物理设备或者物理设备的某一个逻辑分段，是真正存在于物理机上的设备。</li><li>映射表(map table)：映射表记录了映射设备到目标设备的映射关系，它记录了映射设备在目标设备的起始地址、范围和目标设备的类型等变量。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/dutsc/cloud-image/blog-img/202312051654918.png"></p><p>Devicemapper 三个核心概念之间的关系如图 ，<strong>映射设备通过映射表关联到具体的物理目标设备</strong>。事实上，映射设备不仅可以通过映射表关联到物理目标设备，也可以关联到虚拟目标设备，然后虚拟目标设备再通过映射表关联到物理目标设备。</p><p>Devicemapper 在内核中通过很多模块化的映射驱动(target driver)插件实现了对真正 IO 请求的拦截、过滤和转发工作，比如 Raid、软件加密、瘦供给(Thin Provisioning)等。其中瘦供给模块是 Docker 使用 Devicemapper 技术框架中非常重要的模块，下面我们来详细了解下**瘦供给(Thin Provisioning)**。</p><h3 id="瘦供给-Thin-Provisioning"><a href="#瘦供给-Thin-Provisioning" class="headerlink" title="瘦供给(Thin Provisioning)"></a>瘦供给(Thin Provisioning)</h3><p>瘦供给的意思是<strong>动态分配</strong>，这跟传统的固定分配不一样。传统的固定分配是无论我们用多少都一次性分配一个较大的空间，这样可能导致空间浪费。而瘦供给是我们需要多少磁盘空间，存储驱动就帮我们分配多少磁盘空间。</p><p>这种分配机制就好比我们一群人围着一个大锅吃饭，负责分配食物的人每次都给你一点分量，当你感觉食物不够时再去申请食物，而当你吃饱了就不需要再去申请食物了，从而避免了食物的浪费，节约的食物可以分配给更多需要的人。</p><p>那么，你知道 Docker 是如何使用瘦供给来做到像 AUFS 那样分层存储文件的吗？答案就是： <strong>Docker 使用了瘦供给的快照(snapshot)技术</strong>。</p><h4 id="什么是快照-snapshot-技术"><a href="#什么是快照-snapshot-技术" class="headerlink" title="什么是快照(snapshot)技术"></a>什么是快照(snapshot)技术</h4><p>这是全球网络存储工业协会 SNIA(StorageNetworking Industry Association)对快照(Snapshot)的定义：</p><blockquote><p>关于指定数据集合的一个完全可用拷贝，该拷贝包括相应数据在某个时间点(拷贝开始的时间点)的映像。快照可以是其所表示的数据的一个副本，也可以是数据的一个复制品。</p></blockquote><p>简单来说，快照是数据在某一个时间点的存储状态。快照的主要作用是对数据进行备份，当存储设备发生故障时，可以使用已经备份的快照将数据恢复到某一个时间点，而 Docker 中的数据分层存储也是基于快照实现的。</p><p>以上便是实现 Devicemapper 的关键技术，那 Docker 究竟是如何使用 Devicemapper 实现存储数据和镜像分层共享的呢？</p><h3 id="Devicemapper-是如何数据存储的"><a href="#Devicemapper-是如何数据存储的" class="headerlink" title="Devicemapper 是如何数据存储的"></a>Devicemapper 是如何数据存储的</h3><p>当 Docker 使用 Devicemapper 作为文件存储驱动时，Docker 将镜像和容器的文件存储在瘦供给池(thinpool)中，并将这些内容挂载在<code> /var/lib/docker/devicemapper/</code> 目录下。</p><p>这些目录储存 Docker 的容器和镜像相关数据，目录的数据内容和功能说明如下。</p><ul><li>devicemapper 目录(<code>/var/lib/docker/devicemapper/devicemapper/</code>)：存储镜像和容器实际内容，该目录由一个或多个块设备构成。</li><li>metadata 目录(<code>/var/lib/docker/devicemapper/metadata/</code>)： 包含 Devicemapper 本身配置的元数据信息, 以 json 的形式配置，这些元数据记录了镜像层和容器层之间的关联信息。</li><li>mnt 目录( <code>/var/lib/docker/devicemapper/mnt/</code>)：是容器的联合挂载点目录，未生成容器时，该目录为空，而容器存在时，该目录下的内容跟容器中一致。</li></ul><h3 id="Devicemapper-如何实现镜像分层与共享"><a href="#Devicemapper-如何实现镜像分层与共享" class="headerlink" title="Devicemapper 如何实现镜像分层与共享"></a>Devicemapper 如何实现镜像分层与共享</h3><p>Devicemapper 使用专用的块设备实现镜像的存储，并且像 AUFS 一样使用了<strong>写时复制</strong>的技术来保障最大程度节省存储空间，所以 Devicemapper 的镜像分层也是依赖快照来是实现的。</p><p>Devicemapper 的每一镜像层都是其下一层的快照，最底层的镜像层是我们的瘦供给池，通过这种方式实现镜像分层有以下优点。</p><ul><li><p>相同的镜像层，仅在磁盘上存储一次。例如，我有 10 个运行中的 busybox 容器，底层都使用了 busybox 镜像，那么 busybox 镜像只需要在磁盘上存储一次即可。</p></li><li><p>快照是写时复制策略的实现，也就是说，当我们需要对文件进行修改时，文件才会被复制到读写层。</p><blockquote><p>注意，更新一个 <code>1GB</code> 文件的 <code>32KB</code> 数据只复制一个 <code>64KB</code> 数据块到容器快照。这比在文件级别操作需要复制整个 <code>1GB</code> 文件到容器数据层有明显的性能优势。</p><p>不过在实践中，当容器执行很多小于 <code>64KB</code> 的写操作时，<code>devicemapper</code> 的性能会比 <code>AUFS</code> 要差。</p></blockquote></li><li><p><strong>相比对文件系统加锁的机制，Devicemapper 工作在块级别</strong>，因此可以实现同时修改和读写层中的多个块设备，比文件系统效率更高。</p></li></ul><p>当我们需要读取数据时，如果数据存在底层快照中，则向底层快照查询数据并读取。当我们需要写数据时，则向瘦供给池动态申请存储空间生成读写层，然后把数据复制到读写层进行修改。Devicemapper 默认每次申请的大小是 64K 或者 64K 的倍数，因此每次新生成的读写层的大小都是 64K 或者 64K 的倍数。</p><p><strong>对于写操作较大的，可以采用挂载 <code>data volumes</code>。使用 <code>data volumes</code> 可以绕过存储驱动，从而避免 <code>thin provisioning</code> 和 <code>copy-on-write</code> 引入的额外开销。</strong></p><p>以下是一个运行中的 Ubuntu 容器示意图。</p><p><img src="https://cdn.jsdelivr.net/gh/dutsc/cloud-image/blog-img/202312051654227.png"></p><p>这个 Ubuntu 镜像一共有四层，每一层镜像都是下一层的快照，镜像的最底层是基础设备的快照。当容器运行时，容器是基于镜像的快照。综上，<strong>Devicemapper 实现镜像分层的根本原理就是快照</strong>。</p><p>接下来，我们看下如何配置 Docker 的 Devicemapper 模式。</p><h3 id="如何在-Docker-中配置-Devicemapper"><a href="#如何在-Docker-中配置-Devicemapper" class="headerlink" title="如何在 Docker 中配置 Devicemapper"></a>如何在 Docker 中配置 Devicemapper</h3><p>Docker 的 Devicemapper 模式有两种：第一种是 loop-lvm 模式，该模式主要用来开发和测试使用；第二种是 direct-lvm 模式，该模式推荐在生产环境中使用。</p><h4 id="LVM是什么"><a href="#LVM是什么" class="headerlink" title="LVM是什么"></a>LVM是什么</h4><p> LVM是 Logical Volume Manager，逻辑的概念，Linux用户安装Linux操作系统时遇到的一个常见的难以决定的问题就是<strong>如何正确地评估各分区大小</strong>，以分配合适的硬盘空间。普通的磁盘分区管理方式<strong>在逻辑分区划分好之后就无法改变其大小</strong>，当一个逻辑分区存放不下某个文件时，这个文件因为受上层文件系统的限制，也不能跨越多个分区来存放，所以也不能同时放到别的磁盘上。而遇到出现某个分区空间耗尽时，解决的方法通常是使用符号链接，或者使用调整分区大小的工具，但这只是暂时解决办法，没有从根本上解决问题。<strong>随着Linux的逻辑卷管理功能的出现，这些问题都迎刃而解，用户在无需停机的情况下可以方便地调整各个分区大小</strong>。</p><p>​    PV,VG,LV构成了一种易于管理拥有一个或多个硬盘的主机的文件系统，这些硬盘可能只有一个分区也可能有多个。通过将这些物理存在的分区(或称为卷)PV(physical volume)进行整合，组成一个分区(卷)组VG(volume group)，进而再次进行分配形成逻辑分区(卷)LV(logical volume)。创建成功的逻辑分区对于操作系统来说会想普通分区无异，其好处是可以动态调整分区大小。管理PV,VG,LV的工具称为逻辑卷管理器LVM(logical volume manager)。如下图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/dutsc/cloud-image/blog-img/202312051654162.png"></p><p>需要指出的是，在某个物理卷在加入卷组时，会将物理卷的最小存储单元设定为一个固定的值，这个值称为PE(physical extent)。这个值的创建，是为了保证用统一的最小分配单元来创建逻辑卷，不至于因为分配单元大小不同而造成空间浪费。举个例子：用于远洋运输的集装箱的设计是是有着统一标准的，最重要一点是集装箱大小完全相同，这样做的好处是集装箱相互堆叠在一起不会留下多余的空隙，完全利用了空间，且便于管理。设定PE的原因也与此相同。LVM以最小分配单元来创建逻辑卷，该最小分配单元的值称为LE(logical extent)。一般来说PE&#x3D;LE，PE的大小是可配置的，默认为4MB。</p><p>下面我们逐一配置，首先来看下如何配置 loop-lvm 模式。</p><h4 id="配置-loop-lvm-模式"><a href="#配置-loop-lvm-模式" class="headerlink" title="配置 loop-lvm 模式"></a>配置 loop-lvm 模式</h4><blockquote><p>这个模式使用空闲文件来构建存储池，性能非常低</p></blockquote><p>1.使用以下命令停止已经运行的 Docker：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ sudo systemctl stop docker<br></code></pre></td></tr></table></figure><p>2.编辑<code> /etc/docker/daemon.json</code> 文件，如果该文件不存在，则创建该文件，并添加以下配置：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">&#123;  <br><span class="hljs-string">&quot;storage-driver&quot;</span>: <span class="hljs-string">&quot;devicemapper&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>3.启动 Docker：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ sudo systemctl start docker<br></code></pre></td></tr></table></figure><p>4.验证 Docker 的文件驱动模式：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker info<br>Client: <br> Debug Mode: <span class="hljs-literal">false</span><br>Server:<br> Containers: 1<br> Running: 0<br> Paused: 0<br> Stopped: 1<br>Images: 1<br>Server Version: 19.03.12<br>Storage Driver: devicemapper<br> Pool Name: docker-253:1-423624832-pool<br> Pool Blocksize: 65.54kB<br> Base Device Size: 10.74GB<br> Backing Filesystem: xfs<br> Udev Sync Supported: <span class="hljs-literal">true</span><br> Data file: /dev/loop0 <br> Metadata file: /dev/loop1  <br> Data loop file: /var/lib/docker/devicemapper/devicemapper/data<br> Metadata loop file: /var/lib/docker/devicemapper/devicemapper/metadata  <br> Data Space Used: 22.61MB  <br> Data Space Total: 107.4GB  <br> Data Space Available: 107.4GB  <br> Metadata Space Used: 17.37MB  <br> Metadata Space Total: 2.147GB  <br> Metadata Space Available: 2.13GB  <br> Thin Pool Minimum Free Space: 10.74GB  <br> Deferred Removal Enabled: <span class="hljs-literal">true</span> <br> Deferred Deletion Enabled: <span class="hljs-literal">true</span>  <br> Deferred Deleted Device Count: 0  <br> Library Version: 1.02.164-RHEL7 (2019-08-27)... <br> <span class="hljs-comment">#省略部分输出</span><br></code></pre></td></tr></table></figure><p>可以看到 Storage Driver 为 devicemapper，这表示 Docker 已经被配置为 Devicemapper 模式。</p><p>但是这里输出的 Data file 为 &#x2F;dev&#x2F;loop0，这表示我们目前在使用的模式为 loop-lvm。但是由于 loop-lvm 性能比较差，因此不推荐在生产环境中使用 loop-lvm 模式。下面我们看下生产环境中应该如何配置 Devicemapper 的 direct-lvm 模式。</p><h4 id="配置-direct-lvm-模式"><a href="#配置-direct-lvm-模式" class="headerlink" title="配置 direct-lvm 模式"></a>配置 direct-lvm 模式</h4><blockquote><p>使用块设备来构建精简池来存放镜像和容器的数据。</p></blockquote><ol><li>使用以下命令停止已经运行的 Docker：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ sudo systemctl stop docker<br></code></pre></td></tr></table></figure><ol start="2"><li>编辑 <code>/etc/docker/daemon.json</code> 文件，如果该文件不存在，则创建该文件，并添加以下配置：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash">&#123; <br><span class="hljs-string">&quot;storage-driver&quot;</span>: <span class="hljs-string">&quot;devicemapper&quot;</span>, <br><span class="hljs-string">&quot;storage-opts&quot;</span>: [    <br><span class="hljs-string">&quot;dm.directlvm_device=/dev/xdf&quot;</span>,<br>    <span class="hljs-string">&quot;dm.thinp_percent=95&quot;</span>,<br>    <span class="hljs-string">&quot;dm.thinp_metapercent=1&quot;</span>,<br>    <span class="hljs-string">&quot;dm.thinp_autoextend_threshold=80&quot;</span>,<br>    <span class="hljs-string">&quot;dm.thinp_autoextend_percent=20&quot;</span>,<br>    <span class="hljs-string">&quot;dm.directlvm_device_force=false&quot;</span>  <br>    ]<br>&#125;<br></code></pre></td></tr></table></figure><p>其中 directlvm_device 指定需要用作 Docker 存储的磁盘路径，Docker 会动态为我们创建对应的存储池。例如这里我想把 <code>/dev/xdf </code>设备作为我的 Docker 存储盘，directlvm_device 则配置为 <code>/dev/xdf</code>。</p><ol start="3"><li>启动 Docker：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ sudo systemctl start docker<br></code></pre></td></tr></table></figure><ol start="4"><li>验证 Docker 的文件驱动模式：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker info<br>Client:<br> Debug Mode: <span class="hljs-literal">false</span><br>Server: <br> Containers: 1<br> Running: 0<br> Paused: 0 <br> Stopped: 1 <br>Images: 1 <br>Server Version: 19.03.12 <br>Storage Driver: devicemapper<br> Pool Name: docker-thinpool <br> Pool Blocksize: 65.54kB  <br> Base Device Size: 10.74GB <br> Backing Filesystem: xfs <br> Udev Sync Supported: <span class="hljs-literal">true</span>  <br> Data file:  <br> Metadata file: <br> Data loop file: /var/lib/docker/devicemapper/devicemapper/data<br> Metadata loop file: /var/lib/docker/devicemapper/devicemapper/metadata  <br> Data Space Used: 22.61MB  <br> Data Space Total: 107.4GB <br> Data Space Available: 107.4GB <br> Metadata Space Used: 17.37MB <br> Metadata Space Total: 2.147GB  <br> Metadata Space Available: 2.13GB  <br> Thin Pool Minimum Free Space: 10.74GB <br> Deferred Removal Enabled: <span class="hljs-literal">true</span>  <br> Deferred Deletion Enabled: <span class="hljs-literal">true</span>  <br> Deferred Deleted Device Count: 0  <br> Library Version: 1.02.164-RHEL7 (2019-08-27)... 省略部分输出<br></code></pre></td></tr></table></figure><p>当我们看到 Storage Driver 为 devicemapper，并且 Pool Name 为 docker-thinpool 时，这表示 Devicemapper 的 direct-lvm 模式已经配置成功。</p><h3 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h3><p>Devicemapper 使用块设备来存储文件，运行速度会比直接操作文件系统更快，因此很长一段时间内在 Red Hat 或 CentOS 系统中，Devicemapper 一直作为 Docker 默认的联合文件系统驱动，为 Docker 在 Red Hat 或 CentOS 稳定运行提供强有力的保障。</p><p>早期的Docker运行在Ubuntu和Debian Linux上并使用AUFS作为后端存储。Docker流行之后，越来越多的的公司希望在Red Hat Enterprise Linux这类企业级的操作系统上面运行Docker，但可惜的是RHEL的内核并不支持AUFS。这个时候<strong>红帽公司</strong>出手了，决定和Docker公司合作去开发一种基于Device Mapper技术的后端存储，也就是现在的devicemapper。</p><h2 id="overlayFS"><a href="#overlayFS" class="headerlink" title="overlayFS"></a>overlayFS</h2><p>OverlayFS 的发展分为两个阶段。2014 年，OverlayFS 第一个版本被合并到 Linux 内核 3.18 版本中，此时的 OverlayFS 在 Docker 中被称为overlay文件驱动。由于第一版的overlay文件系统存在很多弊端(例如运行一段时间后Docker 会报 “too many links problem” 的错误)， Linux 内核在 4.0 版本对overlay做了很多必要的改进，此时的 OverlayFS 被称之为overlay2。</p><p>因此，在 Docker 中 OverlayFS 文件驱动被分为了两种，一种是早期的overlay，不推荐在生产环境中使用，另一种是更新和更稳定的overlay2，推荐在生产环境中使用。下面的内容我们主要围绕overlay2展开。</p><h3 id="使用-overlay2-的先决条件"><a href="#使用-overlay2-的先决条件" class="headerlink" title="使用 overlay2 的先决条件"></a>使用 overlay2 的先决条件</h3><p>overlay2虽然很好，但是它的使用是有一定条件限制的。</p><ul><li><p>要想使用overlay2，Docker 版本必须高于 17.06.02。</p></li><li><p>如果你的操作系统是 RHEL 或 CentOS，Linux 内核版本必须使用 3.10.0-514 或者更高版本，其他 Linux 发行版的内核版本必须高于 4.0(例如 Ubuntu 或 Debian)，你可以使用uname -a查看当前系统的内核版本。</p></li><li><p>overlay2最好搭配 xfs 文件系统使用，并且使用 xfs 作为底层文件系统时，d_type必须开启。</p><p>一些前置知识</p><h4 id="xfs文件系统的-d-type是什么"><a href="#xfs文件系统的-d-type是什么" class="headerlink" title="xfs文件系统的 d_type是什么"></a>xfs文件系统的 d_type是什么</h4><p>d_type 是 Linux 内核的一个术语，表示 “目录条目类型”，而目录条目，其实是文件系统上目录信息的一个数据结构。d_type，就是这个数据结构的一个字段，这个字段用来表示文件的类型，是文件，还是管道，还是目录还是套接字等。</p><p>d_type 从 Linux 2.6 内核开始就已经支持了，只不过虽然 Linux 内核虽然支持，但有些文件系统实现了 d_type，而有些，没有实现，有些是选择性的实现，也就是需要用户自己用额外的参数来决定是否开启d_type的支持。</p><h4 id="为什么docker在overlay2（xfs文件系统）需要d-type"><a href="#为什么docker在overlay2（xfs文件系统）需要d-type" class="headerlink" title="为什么docker在overlay2（xfs文件系统）需要d_type"></a>为什么docker在overlay2（xfs文件系统）需要d_type</h4><p>不论是 overlay，还是 overlay2，它们的底层文件系统都是 overlayfs 文件系统。而 overlayfs 文件系统，就会用到 d_type 这个东西用来文件的操作是被正确的处理了。换句话说，docker只要使用 overlay 或者 overlay2，就等于在用 overlayfs，也就一定会用到 d_type。所以，docker 提供了<code>docker info</code> 命令来检测你docker服务，是否在使用overlay的时候正确的使用 d_type。如果用了 overlay&#x2F;overlay2，但 d_type 没有开，就报警告。</p><p>如果在不支持 d_type 的 overlay&#x2F;overlay 驱动下使用docker，也就意味着 docker 在操作文件的时候，可能会遇到一些错误，比如 无法删除某些目录或文件，设置文件或目录的权限或用户失败等等。这些都是不可预料的错误。举个具体的场景，就是，docker构建的时候，可能在构建过程中，删除文件等操作失败，导致构建停止。</p></li><li><p>可以使用以下命令验证 d_type 是否开启：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ xfs_info /var/lib/docker | grep ftype<br>naming =version 2   bsize=4096   ascii-ci=0   ftype=1<br></code></pre></td></tr></table></figure><p>当输出结果中有 ftype&#x3D;1 时，表示 d_type 已经开启。如果你的输出结果为 ftype&#x3D;0，则需要重新格式化磁盘目录，命令如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ sudo mkfs.xfs -f -n ftype=1 /path/to/disk<br></code></pre></td></tr></table></figure><p>另外，在生产环境中，推荐挂载 <code>/var/lib/docker</code> 目录到单独的磁盘或者磁盘分区，这样可以避免该目录写满影响主机的文件写入，并且把挂载信息写入到<code> /etc/fstab</code>，防止机器重启后挂载信息丢失。</p><p>挂载配置中推荐开启<code> pquota</code>，这样可以防止某个容器写文件溢出导致整个容器目录空间被占满。写入到 <code>/etc/fstab</code> 中的内容如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-variable">$UUID</span> /var/lib/docker xfs defaults,pquota 0 0<br></code></pre></td></tr></table></figure><p>其中 UUID 为<code> /var/lib/docker</code> 所在磁盘或者分区的 UUID 或者磁盘路径。</p><p>如果你的操作系统无法满足上面的任何一个条件，那我推荐你使用 AUFS 或者 Devicemapper 作为你的 Docker 文件系统驱动。</p><blockquote><p>通常情况下， overlay2 会比 AUFS 和 Devicemapper 性能更好，而且更加稳定，因为 overlay2 在 inode 优化上更加高效。因此在生产环境中推荐使用 overlay2 作为 Docker 的文件驱动。</p></blockquote><p>下面通过实例，学习如何初始化 <code>/var/lib/docker</code> 目录，为后面配置 Docker 的<code>overlay2</code>文件驱动做准备。</p></li></ul><h3 id="准备-var-lib-docker-目录"><a href="#准备-var-lib-docker-目录" class="headerlink" title="准备 &#x2F;var&#x2F;lib&#x2F;docker 目录"></a>准备 &#x2F;var&#x2F;lib&#x2F;docker 目录</h3><ol><li>使用 lsblk(Linux 查看磁盘和块设备信息命令)命令查看本机磁盘信息：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ lsblk<br>NAME   MAJ:MIN RM  SIZE RO TYPE MOUNTPOINT<br>vda    253:0    0  500G  0 disk <br>`-vda1 253:1    0  500G  0 part /<br>vdb    253:16   0  500G  0 disk<br>`-vdb1 253:17   0    8G  0 part<br></code></pre></td></tr></table></figure><p>可以看到，我的机器有两块磁盘，一块是 vda，一块是 vdb。其中 vda 已经被用来挂载系统根目录，这里我想把 <code>/var/lib/docker</code> 挂载到 vdb1 分区上。</p><ol start="2"><li><p>使用 mkfs 命令格式化磁盘 vdb1：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ sudo mkfs.xfs -f -n ftype=1 /dev/vdb1<br></code></pre></td></tr></table></figure></li><li><p>将挂载信息写入到<code>/etc/fstab</code>，保证机器重启挂载目录不丢失：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ sudo <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;/dev/vdb1 /var/lib/docker xfs defaults,pquota 0 0&quot;</span> &gt;&gt; /etc/fstab<br></code></pre></td></tr></table></figure></li><li><p>使用 mount 命令使得挂载目录生效：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ sudo mount -a<br></code></pre></td></tr></table></figure></li><li><p>查看挂载信息：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ lsblk<br>NAME   MAJ:MIN RM  SIZE RO TYPE MOUNTPOINT<br>vda    253:0    0  500G  0 disk<br>`-vda1 253:1    0  500G  0 part /<br>vdb    253:16   0  500G  0 disk<br>`-vdb1 253:17   0    8G  0 part /var/lib/docker<br></code></pre></td></tr></table></figure><p>可以看到此时<code>/var/lib/docker</code>目录已经被挂载到了 vdb1 这个磁盘分区上。我们使用 xfs_info 命令验证下 d_type 是否已经成功开启：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ xfs_info /var/lib/docker | grep ftype<br>naming   =version 2              bsize=4096   ascii-ci=0 ftype=1<br></code></pre></td></tr></table></figure><p>可以看到输出结果为 ftype&#x3D;1，证明 d_type 已经被成功开启。</p></li></ol><p>准备好<code>/var/lib/docker</code> 目录后，我们就可以配置 Docker 的文件驱动为 overlay2，并且启动 Docker 了。</p><h3 id="如何在-Docker-中配置-overlay2？"><a href="#如何在-Docker-中配置-overlay2？" class="headerlink" title="如何在 Docker 中配置 overlay2？"></a>如何在 Docker 中配置 overlay2？</h3><p>当你的系统满足上面的条件后，就可以配置你的 Docker 存储驱动为 overlay2 了，具体配置步骤如下。</p><ol><li><p>停止已经运行的 Docker：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ sudo systemctl stop docker<br></code></pre></td></tr></table></figure></li><li><p>备份 <code>/var/lib/docker</code> 目录：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ sudo <span class="hljs-built_in">cp</span> -au /var/lib/docker /var/lib/docker.back<br></code></pre></td></tr></table></figure></li><li><p>在 <code>/etc/docker </code>目录下创建 daemon.json 文件，如果该文件已经存在，则修改配置为以下内容：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">&#123;  <br><span class="hljs-string">&quot;storage-driver&quot;</span>: <span class="hljs-string">&quot;overlay2&quot;</span>, <br>    <span class="hljs-string">&quot;storage-opts&quot;</span>: [    <br>    <span class="hljs-string">&quot;overlay2.size=20G&quot;</span>,<br>    <span class="hljs-string">&quot;overlay2.override_kernel_check=true&quot;</span> <br>    ]<br>&#125;<br></code></pre></td></tr></table></figure><p>其中 storage-driver 参数指定使用 overlay2 文件驱动，overlay2.size 参数表示限制每个容器根目录大小为 20G。<strong>限制每个容器的磁盘空间大小是通过 xfs 的 pquota 特性实现</strong>，overlay2.size 可以根据不同的生产环境来设置这个值的大小。我推荐你在生产环境中开启此参数，防止某个容器写入文件过大，导致整个 Docker 目录空间溢出。</p></li><li><p>启动 Docker：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ sudo systemctl start docker<br></code></pre></td></tr></table></figure></li><li><p>检查配置是否生效：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker info<br>Client: <br> Debug Mode: <span class="hljs-literal">false</span><br>Server: <br> Containers: 1  <br> Running: 0  <br> Paused: 0  <br> Stopped: 1 <br>Images: 1<br>Server Version: 19.03.12<br>Storage Driver: overlay2 <br> Backing Filesystem: xfs  <br> Supports d_type: <span class="hljs-literal">true</span>  <br> Native Overlay Diff: <span class="hljs-literal">true</span><br>Logging Driver: json-file<br>Cgroup Driver: cgroupfs ... 省略部分无用输出<br></code></pre></td></tr></table></figure><p>可以看到 Storage Driver 已经变为 overlay2，并且 d_type 也是 true。至此，你的 Docker 已经配置完成。下面我们看下 overlay2 是如何工作的。</p></li></ol><h3 id="overlay2-工作原理"><a href="#overlay2-工作原理" class="headerlink" title="overlay2 工作原理"></a>overlay2 工作原理</h3><p>overlay2 是如何存储文件的？</p><p>overlay2 和 AUFS 类似，它将所有目录称之为层(layer)，overlay2 的目录是镜像和容器分层的基础，而把这些层统一展现到同一的目录下的过程称为<strong>联合挂载</strong>(union mount)。overlay2 把目录的下一层叫作lowerdir，上一层叫作upperdir，联合挂载后的结果叫作merged。</p><blockquote><p>overlay2 文件系统最多支持 128 个层数叠加，也就是说你的 Dockerfile 最多只能写 128 行，不过这在日常使用中足够了。</p></blockquote><p>下面我们通过拉取一个 Ubuntu 操作系统的镜像来看下 overlay2 是如何存放镜像文件的。</p><p>首先，我们通过以下命令拉取 Ubuntu 镜像：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker pull ubuntu:16.04<br>16.04: Pulling from library/ubuntu<br>8e097b52bfb8: Pull complete<br>a613a9b4553c: Pull complete<br>acc000f01536: Pull complete<br>73eef93b7466: Pull complete<br>Digest:<br>sha256:3dd44f7ca10f07f86add9d0dc611998a1641f501833692a2651c96defe8db940<br>Status: Downloaded newer image <span class="hljs-keyword">for</span> ubuntu:16.04<br>docker.io/library/ubuntu:16.04<br></code></pre></td></tr></table></figure><p>可以看到镜像一共被分为四层拉取，拉取完镜像后我们查看一下 overlay2 的目录：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ sudo <span class="hljs-built_in">ls</span> -l /var/lib/docker/overlay2/<br>total 0<br>drwx------. 3 root root      47 Sep 13 08:16 01946de89606800dac8530e3480b32be9d7c66b493a1cdf558df52d7a1476d4a<br>drwx------. 4 root root      55 Sep 13 08:16 0849daa41598a333101f6a411755907d182a7fcef780c7f048f15d335b774deb<br>drwx------. 4 root root      72 Sep 13 08:16 94222a2fa3b2405cb00459285dd0d0ba7e6936d9b693ed18fbb0d08b93dc272f<br>drwx------. 4 root root      72 Sep 13 08:16 9d392cf38f245d37699bdd7672daaaa76a7d702083694fa8be380087bda5e396<br>brw-------. 1 root root 253, 17 Sep 13 08:14 backingFsBlockDev<br>drwx------. 2 root root     142 Sep 13 08:16 l<br></code></pre></td></tr></table></figure><p>可以看到 overlay2 目录下出现了四个镜像层目录和一个<code>l</code>目录，我们首先来查看一下<code>l</code>目录的内容：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ sudo <span class="hljs-built_in">ls</span> -l /var/lib/docker/overlay2/l<br>total 0lrwxrwxrwx. 1 root root 72 Sep 13 08:16 FWGSYEA56RNMS53EUCKEQIKVLQ -<br>&gt; ../9d392cf38f245d37699bdd7672daaaa76a7d702083694fa8be380087bda5e396/diff<br>lrwxrwxrwx. 1 root root 72 Sep 13 08:16 RNN2FM3YISKADNAZFRONVNWTIS -<br>&gt; ../0849daa41598a333101f6a411755907d182a7fcef780c7f048f15d335b774deb/diff<br>lrwxrwxrwx. 1 root root 72 Sep 13 08:16 SHAQ5GYA3UZLJJVEGXEZM34KEE -<br>&gt; ../01946de89606800dac8530e3480b32be9d7c66b493a1cdf558df52d7a1476d4a/diff<br>lrwxrwxrwx. 1 root root 72 Sep 13 08:16 VQSNH735KNX4YK2TCMBAJRFTGT -<br>&gt; ../94222a2fa3b2405cb00459285dd0d0ba7e6936d9b693ed18fbb0d08b93dc272f/diff<br></code></pre></td></tr></table></figure><p>可以看到<code>l</code>目录是一堆软连接，把一些较短的随机串软连到镜像层的 diff 文件夹下，这样做是为了避免达到<code>mount</code>命令参数的长度限制。</p><p>面我们查看任意一个镜像层下的文件内容：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ sudo <span class="hljs-built_in">ls</span> -l /var/lib/docker/overlay2/0849daa41598a333101f6a411755907d182a7fcef780c7f048f15d335b774deb/<br>total 8<br>drwxr-xr-x. 3 root root 17 Sep 13 08:16 diff<br>-rw-r--r--. 1 root root 26 Sep 13 08:16 <span class="hljs-built_in">link</span><br>-rw-r--r--. 1 root root 86 Sep 13 08:16 lower<br>drwx------. 2 root root  6 Sep 13 08:16 work<br></code></pre></td></tr></table></figure><p>镜像层的 link 文件内容为该镜像层的短 ID，diff 文件夹为该镜像层的改动内容，lower 文件为该层的所有父层镜像的短 ID。</p><p>我们可以通过docker image inspect命令来查看某个镜像的层级关系，例如我想查看刚刚下载的 Ubuntu 镜像之间的层级关系，可以使用以下命令： </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker image inspect ubuntu:16.04<br>...省略部分输出<br><span class="hljs-string">&quot;GraphDriver&quot;</span>: &#123; <br><span class="hljs-string">&quot;Data&quot;</span>: &#123;            <br>      <span class="hljs-string">&quot;LowerDir&quot;</span>: <span class="hljs-string">&quot;/var/lib/docker/overlay2/9d392cf38f245d37699bdd7672daaaa76a7d702083694fa8be380087bda5e396/diff:/var/lib/docker/overlay2/94222a2fa3b2405cb00459285dd0d0ba7e6936d9b693ed18fbb0d08b93dc272f/diff:/var/lib/docker/overlay2/01946de89606800dac8530e3480b32be9d7c66b493a1cdf558df52d7a1476d4a/diff&quot;</span>,<br>      <span class="hljs-string">&quot;MergedDir&quot;</span>: <span class="hljs-string">&quot;/var/lib/docker/overlay2/0849daa41598a333101f6a411755907d182a7fcef780c7f048f15d335b774deb/merged&quot;</span>,             <br>      <span class="hljs-string">&quot;UpperDir&quot;</span>: <span class="hljs-string">&quot;/var/lib/docker/overlay2/0849daa41598a333101f6a411755907d182a7fcef780c7f048f15d335b774deb/diff&quot;</span>,             <br>      <span class="hljs-string">&quot;WorkDir&quot;</span>: <span class="hljs-string">&quot;/var/lib/docker/overlay2/0849daa41598a333101f6a411755907d182a7fcef780c7f048f15d335b774deb/work&quot;</span>            &#125;,   <br>      <span class="hljs-string">&quot;Name&quot;</span>: <span class="hljs-string">&quot;overlay2&quot;</span>       <br>      &#125;,<br>...省略部分输出<br></code></pre></td></tr></table></figure><p>其中，MergedDir代表当前镜像层在overlay2存储下的目录。LowerDir代表当前镜像的父层关系，使用：分隔，：最后代表该镜像的最底层。</p><p>下面我们将镜像运行起来成为容器：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker run --name=ubuntu -d ubuntu:16.04 <span class="hljs-built_in">sleep</span> 3600<br></code></pre></td></tr></table></figure><p>我们使用<code>docker inspect</code>命令来查看一下容器的工作目录：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker inspect ubuntu<br>...省略部分输出<br><span class="hljs-string">&quot;GraphDriver&quot;</span>: &#123;           <br><span class="hljs-string">&quot;Data&quot;</span>: &#123;              <br>    <span class="hljs-string">&quot;LowerDir&quot;</span>: <span class="hljs-string">&quot;/var/lib/docker/overlay2/4753c2aa5bdb20c97cddd6978ee3b1d07ef149e3cc2bbdbd4d11da60685fe9b2-init/diff:/var/lib/docker/overlay2/0849daa41598a333101f6a411755907d182a7fcef780c7f048f15d335b774deb/diff:/var/lib/docker/overlay2/9d392cf38f245d37699bdd7672daaaa76a7d702083694fa8be380087bda5e396/diff:/var/lib/docker/overlay2/94222a2fa3b2405cb00459285dd0d0ba7e6936d9b693ed18fbb0d08b93dc272f/diff:/var/lib/docker/overlay2/01946de89606800dac8530e3480b32be9d7c66b493a1cdf558df52d7a1476d4a/diff&quot;</span>,     <br>    <span class="hljs-string">&quot;MergedDir&quot;</span>: <span class="hljs-string">&quot;/var/lib/docker/overlay2/4753c2aa5bdb20c97cddd6978ee3b1d07ef149e3cc2bbdbd4d11da60685fe9b2/merged&quot;</span>,            <br>    <span class="hljs-string">&quot;UpperDir&quot;</span>: <span class="hljs-string">&quot;/var/lib/docker/overlay2/4753c2aa5bdb20c97cddd6978ee3b1d07ef149e3cc2bbdbd4d11da60685fe9b2/diff&quot;</span>,           <br>    <span class="hljs-string">&quot;WorkDir&quot;</span>: <span class="hljs-string">&quot;/var/lib/docker/overlay2/4753c2aa5bdb20c97cddd6978ee3b1d07ef149e3cc2bbdbd4d11da60685fe9b2/work&quot;</span>            &#125;,          <br>    <span class="hljs-string">&quot;Name&quot;</span>: <span class="hljs-string">&quot;overlay2&quot;</span>      <br>    &#125;,<br>...省略部分输出<br></code></pre></td></tr></table></figure><p><strong>MergedDir 后面的内容即为容器层的工作目录，LowerDir 为容器所依赖的镜像层目录。</strong> 然后我们查看下 overlay2 目录下的内容：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ sudo <span class="hljs-built_in">ls</span> -l /var/lib/docker/overlay2/<br>total 0<br>drwx------. 3 root root      47 Sep 13 08:16 01946de89606800dac8530e3480b32be9d7c66b493a1cdf558df52d7a1476d4a<br>drwx------. 4 root root      72 Sep 13 08:47 0849daa41598a333101f6a411755907d182a7fcef780c7f048f15d335b774deb<br>drwx------. 5 root root      69 Sep 13 08:47 4753c2aa5bdb20c97cddd6978ee3b1d07ef149e3cc2bbdbd4d11da60685fe9b2<br>drwx------. 4 root root      72 Sep 13 08:47 4753c2aa5bdb20c97cddd6978ee3b1d07ef149e3cc2bbdbd4d11da60685fe9b2-init<br>drwx------. 4 root root      72 Sep 13 08:16 94222a2fa3b2405cb00459285dd0d0ba7e6936d9b693ed18fbb0d08b93dc272f<br>drwx------. 4 root root      72 Sep 13 08:16 9d392cf38f245d37699bdd7672daaaa76a7d702083694fa8be380087bda5e396<br>brw-------. 1 root root 253, 17 Sep 13 08:14 backingFsBlockDev<br>drwx------. 2 root root     210 Sep 13 08:47 l<br></code></pre></td></tr></table></figure><p>可以看到 overlay2 目录下增加了容器层相关的目录，我们再来查看一下容器层下的内容：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ sudo <span class="hljs-built_in">ls</span> -l /var/lib/docker/overlay2/4753c2aa5bdb20c97cddd6978ee3b1d07ef149e3cc2bbdbd4d11da60685fe9b2total 8<br>drwxr-xr-x. 2 root root   6 Sep 13 08:47 diff<br>-rw-r--r--. 1 root root  26 Sep 13 08:47 <span class="hljs-built_in">link</span><br>-rw-r--r--. 1 root root 144 Sep 13 08:47 lower<br>drwxr-xr-x. 1 root root   6 Sep 13 08:47 merged<br>drwx------. 3 root root  18 Sep 13 08:47 work<br></code></pre></td></tr></table></figure><p>link 和 lower 文件与镜像层的功能一致，<strong>link 文件内容为该容器层的短 ID，lower 文件为该层的所有父层镜像的短 ID 。diff 目录为容器的读写层，容器内修改的文件都会在 diff 中出现，merged 目录为分层文件联合挂载后的结果，也是容器内的工作目录。</strong></p><p>总体来说，overlay2 是这样储存文件的：overlay2将镜像层和容器层都放在单独的目录，并且有唯一 ID，每一层仅存储发生变化的文件，最终使用联合挂载技术将容器层和镜像层的所有文件统一挂载到容器中，使得容器中看到完整的系统文件。</p><h3 id="overlay2-如何读取、修改文件？"><a href="#overlay2-如何读取、修改文件？" class="headerlink" title="overlay2 如何读取、修改文件？"></a>overlay2 如何读取、修改文件？</h3><p>overlay2 的工作过程中对文件的操作分为读取文件和修改文件。</p><h4 id="读取文件"><a href="#读取文件" class="headerlink" title="读取文件"></a>读取文件</h4><p>容器内进程读取文件分为以下三种情况。</p><ul><li>文件在容器层中存在：当文件存在于容器层并且不存在于镜像层时，直接从容器层读取文件；</li><li>当文件在容器层中不存在：当容器中的进程需要读取某个文件时，如果容器层中不存在该文件，则从镜像层查找该文件，然后读取文件内容；</li><li>文件既存在于镜像层，又存在于容器层：当我们读取的文件既存在于镜像层，又存在于容器层时，将会从容器层读取该文件。</li></ul><h4 id="修改文件或目录"><a href="#修改文件或目录" class="headerlink" title="修改文件或目录"></a>修改文件或目录</h4><p>overlay2 对文件的修改采用的是<strong>写时复制</strong>的工作机制，这种工作机制可以最大程度节省存储空间。具体的文件操作机制如下。</p><ul><li><p>第一次修改文件：当我们第一次在容器中修改某个文件时，overlay2 会触发写时复制操作，overlay2 首先从镜像层复制文件到容器层，然后在容器层执行对应的文件修改操作。这与AUFS和Devicemapper相同。</p><blockquote><p>overlay2 写时复制的操作将会复制整个文件，如果文件过大，将会大大降低文件系统的性能，因此当我们有大量文件需要被修改时，overlay2 可能会出现明显的延迟。好在，写时复制操作只在第一次修改文件时触发，对日常使用没有太大影响。</p><p>这点与AUFS相同</p><p>与Devicemapper是否相同？？</p></blockquote></li><li><p>删除文件或目录：当文件或目录被删除时，overlay2 并不会真正从镜像中删除它，因为镜像层是只读的，overlay2 会创建一个特殊的文件或目录，这种特殊的文件或目录会阻止容器的访问。</p></li></ul><h3 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h3><p>overlay2 目前已经是 Docker 官方推荐的文件系统了，也是目前安装 Docker 时默认的文件系统，因为 overlay2 在生产环境中不仅有着较高的性能，它的稳定性也极其突出。但是 overlay2 的使用还是有一些限制条件的，例如要求 Docker 版本必须高于 17.06.02，内核版本必须高于 4.0 等。因此，在生产环境中，如果你的环境满足使用 overlay2 的条件，请尽量使用 overlay2 作为 Docker 的联合文件系统。</p><h2 id="存储驱动的比较"><a href="#存储驱动的比较" class="headerlink" title="存储驱动的比较"></a>存储驱动的比较</h2><h3 id="AUFS-VS-OverlayFS"><a href="#AUFS-VS-OverlayFS" class="headerlink" title="AUFS VS OverlayFS"></a>AUFS VS OverlayFS</h3><p>AUFS和Overlay都是联合文件系统，但AUFS有多层，而Overlay只有两层，所以在做写时复制操作时，如果文件比较大且存在比较低的层，则AUSF可能会慢一些。而且Overlay并入了linux kernel mainline，AUFS没有。目前AUFS已基本被淘汰。</p><h3 id="OverlayFS-VS-Device-mapper"><a href="#OverlayFS-VS-Device-mapper" class="headerlink" title="OverlayFS VS Device mapper"></a>OverlayFS VS Device mapper</h3><p>OverlayFS是文件级存储，Device mapper是块级存储，当文件特别大而修改的内容很小，Overlay不管修改的内容大小都会复制整个文件，对大文件进行修改显示要比小文件要消耗更多的时间，而块级无论是大文件还是小文件都只复制需要修改的块，并不是整个文件，在这种场景下，显然device mapper要快一些。因为块级的是直接访问逻辑盘，适合IO密集的场景。而对于程序内部复杂，大并发但少IO的场景，Overlay的性能相对要强一些。</p><h2 id="常用存储驱动对比"><a href="#常用存储驱动对比" class="headerlink" title="常用存储驱动对比"></a>常用存储驱动对比</h2><table><thead><tr><th align="left">存储驱动</th><th align="left">特点</th><th align="left">优点</th><th align="left">缺点</th><th align="left">适用场景</th></tr></thead><tbody><tr><td align="left">AUFS</td><td align="left">联合文件系统、未并入内核主线、文件级存储</td><td align="left">作为docker的第一个存储驱动，已经有很长的历史，比较稳定，且在大量的生产中实践过，有较强的社区支持</td><td align="left">有多层，在做写时复制操作时，如果文件比较大且存在比较低的层，可能会慢一些</td><td align="left">大并发但少IO的场景</td></tr><tr><td align="left">overlayFS</td><td align="left">联合文件系统、并入内核主线、文件级存储</td><td align="left">只有两层</td><td align="left">不管修改的内容大小都会复制整个文件，对大文件进行修改显示要比小文件消耗更多的时间</td><td align="left">大并发但少IO的场景</td></tr><tr><td align="left">Devicemapper</td><td align="left">并入内核主线、块级存储</td><td align="left">块级无论是大文件还是小文件都只复制需要修改的块，并不是整个文件</td><td align="left">不支持共享存储，当有多个容器读同一个文件时，需要生成多个复本，在很多容器启停的情况下可能会导致磁盘溢出</td><td align="left">适合io密集的场景</td></tr><tr><td align="left">Btrfs</td><td align="left">并入linux内核、文件级存储</td><td align="left">可以像devicemapper一样直接操作底层设备，支持动态添加设备</td><td align="left">不支持共享存储，当有多个容器读同一个文件时，需要生成多个复本</td><td align="left">不适合在高密度容器的paas平台上使用</td></tr><tr><td align="left">ZFS</td><td align="left">把所有设备集中到一个存储池中来进行管理</td><td align="left">支持多个容器共享一个缓存块，适合内存大的环境</td><td align="left">COW使用碎片化问题更加严重，文件在硬盘上的物理地址会变的不再连续，顺序读会变的性能比较差</td><td align="left">适合paas和高密度的场景</td></tr></tbody></table><h1 id="Docker-Compose"><a href="#Docker-Compose" class="headerlink" title="Docker Compose"></a>Docker Compose</h1><blockquote><p>Docker官方的单机多容器管理系统</p></blockquote><p>本质是一个python脚本，通过解析用户编写的yaml文件，调用Docker API实现动态的创建和管理多个容器。</p><h1 id="Docker-Swarm"><a href="#Docker-Swarm" class="headerlink" title="Docker Swarm"></a>Docker Swarm</h1><blockquote><p>管理规模更大的容器集群</p></blockquote><ul><li>分布式：Raft协议</li><li>安全：TLS双向认证</li><li>简单：从Docker1.12版本后，被内置到了Docker中</li></ul><h3 id=""><a href="#" class="headerlink" title=""></a></h3>]]></content>
    
    
    
    <tags>
      
      <tag>学习记录</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
